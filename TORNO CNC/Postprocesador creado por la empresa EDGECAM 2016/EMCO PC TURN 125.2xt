;Template=2AXLATHE=Turn 4CY ISO

*********************************
*
*  Code Wizard Templates
*  File 4cyb-AdvTurn.cgs
*
* Template source file for 2 axis lathes based on ISO G code formats
*
* Created from old templates 10 June 2003
* Placed under change control
* Richard Halton
*
**********************************
* 23/12/03 RHA DEV00009701 Change version and date. Set up v8.5 templates
* 18/02/04 RHA DEV00010264 Set version 8.50.14
* 16/08/05 RHA DEV00014427 Add KT defaults include file
* Version 10.5
* 16/08/05 RHA DEV00015397 Add Whiteboard include file
* Version 2011.2
* 23/02/11 RHA W42941 Re-organise Notes section & add macro number details
* Version 2014.2
* 14/11/13 RHA W61589 Implement additional turrets
* 18/12/13 RHA W62161 Fix Synch Calls and stub procedures
* Version 2015.2
* 06/01/15 GST W66367 Separate common procedures for ToM and Turn
* 19/01/15 GST W66367 Restructure - last batch
*


;****************************************************
;			              *	ISO Template Notes	    *
;****************************************************


;*************************************************************************
; Machine independant Code Generator include file
; Technical notes for user customisation of Code Generator and CGE files
;*************************************************************************

* Within Code Generator the use of macro numbers is restricted as follows:
*    1 - 3999 Reserved for cam system Use
* 4000 - 4999 Reserved for Code Wizard Template use
* 5000 - 5999 Reserved for PDI customisation
* 6000 - 9999 Reserved for user defined customisation
*
* Customisation of Code Generator files, both direct and
* through CGEs must be limited to  the 6000-9999 range
*
;*************************************************************************
; End technical notes
;*************************************************************************

*			*******************************
*			* General template Notes Area *
*			*******************************
* Notes must be defined outside of all procedures using the following syntax
* Text is displayed in the machine NOTES area of the CGD but does not show in CG source


**************************************************************************
*   Machine independant Code Generator include file
*   Filename:	CWT Notes Turn General.cgi
*	Author:		RHA
*   Date:       23 February 2011
**************************************************************************
*   Change History - At end of file
* Version 2011.2
*          FIRST ISSUE
* 23/02/11 RHA W42941 Document user macro ranges
*
**************************************************************************
*
*********************************
*
*  Code Wizard Templates
*  File Turn-Initialise.cgi
*
*********************************
*
* Created from old templates 10 June 2003
* Placed under change control
* Richard Halton
*
* File contains Variable Declarations, Token Definitions and Format Table
* references for turn templates.
*
*  General fixes also implemented here
* 05/08/03 RHA DEV00008306 Separate vars for rapid and feed polar/cartesian mode
* 07/08/03 RHA DEV00007890 Make R word calculation in cycles switchable
* 12/08/03 RHA DEV00007046 Function Off tokens in Rapid to TC and Home
* 12/08/03 RHA DEV00008119 Add FLUTE length to set up data
* 20/08/03 RHA DEV00008484 Correct multi-start threads
* 26/08/03 RHA DEV00008539 Add warnings counter

*Change Control
* 14/11/03 RHA DEV00009364 Correct coolant settings
* 20/11/03 RHA DEV00009231 Combined spindle and coolant codes added
* 28/11/03 RHA DEV00009456 AVN Feedback - Tool Change options
* 01/12/03 RHA DEV00009047 Complete spindle synch
* 05/12/03 RHA DEV00007048 Add Rigid Tapping Option
* 15/12/03 RHA DEV00009616 Remove all Q67 series uservars, Turret side now uses USERVAR4
* 15/12/03 RHA DEV00009612 Add new date tokens
* 16/12/03 RHA DEV00009384 Pull Out token for threading
* 15/01/04 RHA DEV00008184 Give GEARMCODE its own format address
* 15/01/04 RHA DEV00009858 New token for Fanuc Polar output
* 19/01/04 RHA DEV00008669 Use MAXRPM sys var in MAXRPM token
* 21/01/04 RHA DEV00009848 Make Convert No-Convert modal
* 26/01/04 RHA DEV00009967 Polar setting for Radila/Diametral #POLARDIAM
* 26/01/04 RHA DEV00009953 Token for second leg return to ToolChange
* 27/01/04 RHA DEV00009963 Add [ ] Tokens
* 30/01/04 RHA DEV00008184 Make token call to C Axis codeconstructor modal
* 02/02/04 RHA DEV00010088 add diametral switches for axial/radial machining
* 03/02/04 RHA DEV00002228 Work round calculation problem in token definitions
* 05/02/04 RHA DEV00009977 Tokens for user defined toolstore variables
* 06/02/04 RHA DEV00010176 Re-assign CY_SPINDIR to MCODE address
* 10/02/04 RHA DEV00010088 Correct #DIAM switching
* 12/02/04 RHA DEV00004642 Token COOLTHRTLOFF
* 13/02/04 RHA DEV00010219 Separate Z reverse switch for sub spindle driven tools
* 08/03/04 RHA DEV00010387 Set gear for maxrpm
* 11/03/04 RHA DEV00010521 CSS speed check optional
* 22/03/04 RHA DEV00010537 Correct retract G codes
* Version 900
* 07/05/04 RHA DEV00010784 Next tool tokens have own format addresses
*                          Add Retract Ejector Token
*                          Add more spindle select variants,driven tool
*                          Procedure for driven tool codes to allow for subspindle
* 07/05/04 RHA DEV00010872 Token for Push Check Code Constructor
* 10/05/04 RHA DEV00010872 Add separate control for polar in hole cycles
* 13/05/04 RHA DEV00010924 Tool Change corrections, alternative code constructors etc
* 21/05/04 RHA DEV00010783 Add #MACHINEMINRPM
* 07/06/04 RHA DEV00010712 Separate token for CY Cycle dwell
* 09/06/04 RHA DEV00011069 TLO fixes, #TLOSHIFT
* 15/07/04 RHA DEV00008178 Add multi level/depth to hole cycles
* 15/07/04 RHA DEV00010735 Cancel canned cycle for radial holes - X Clearance move
* 19/07/04 RHA DEV00011202 Implement arc bulge control, remove #ARCTOL
* 19/07/04 RHA DEV00010739 B Axis formatting corrections
* 20/07/04 RHA DEV00010907 Put MAXRPM tokens in all start macros
* 20/07/04 RHA DEV00009388 Datum choice for sub spindle movements
* 21/07/04 RHA DEV00010739 B Axis XABSORIGIN now uses #BREFDIAM
* 29/07/04 RHA DEV00011469 Add X Reversal options
* Version 950
* 30/11/04 RHA DEV00012029 Add #RADNEG
* 01/12/04 RHA DEV00011681 Additional mill tool tokens
* 07/12/04 RHA DEV00012698 Manual option for Polar control #POLARAUTO,#POLARMAN
* 08/12/04 RHA DEV00012014 Add Turret Priority Token for Spindle Control
* 08/12/04 RHA DEV00012305 Add ABS abd INC tokens for R to TC moves (Integrex)
* 09/12/04 RHA DEV00012305 Rigid Tapping G Codes, Variables
* 14/12/04 RHA DEV00012766 Speed modality, change REVS token output variable
* 14/12/04 RHA DEV00012765 Make hole cycle approach context sensitive #PREPOSITION
* 21/12/04 RHA DEV00012864 Correct helix ZEND, Make KVALUE=PITCH switchable #KVALPITCH
* 23/12/04 RHA DEV00012874 Turning Spindle Stop token
* 13/01/05 RHA DEV00012533 G55 datum token
* Version 9.75
* 04/03/05 RHA DEV00013026 Add Tool Direction selection
* 09/03/05 RHA DEV00012875 Add User Numeric Tokens 11-20
* Version 10
* 20/05/05 RHA DEV00014066 Reverse driven tools G2/3 on sub spindle
* 24/05/05 RHA DEV00013998 Call SPINDLE setting from GEARMCODE token, Add LOWGEAR token
* 02/06/05 RHA DEV00013861 Make HOLD values available at code constructors again
* 06/06/05 RHA DEV00009954 #CYCLEPOINTS Hole Cycle Points code constructor
* 08/06/05 RHA DEV00014175 Radial unwrapped data
* 07/07/05 RHA DEV00013851 Spindle initialisation control tokens
* 22/07/05 RHA DEV00013858 Correct thread approach checks
* 01/08/05 RHA DEV00014365 Add separtae C axis reversals for sub spindle
* 02/08/05 RHA DEV00014365 Add Sub Spindle C offset
* 22/08/05 RHA DEV00014785 Tokens IF_NEXT_DIFFERENT, AUTOBRAKE, HIGHGEAR
* 31/08/05 RHA DEV00014854 Declare #BSUBREVERSE
* 12/09/05 RHA DEV00014785 B axis Z reference follows #ZMAINREVERSE
* 21/09/05 RHA DEV00015042 Separate C angle offset/reversal for Lower Turret
* 22/09/05 RHA DEV00015104 Allow RPLANE to be diametral for radial hole cycles
* 30/09/05 RHA DEV00015213 Implement AutoCoolant option
* Version 10.5
* 28/11/05 RHA DEV00015639 Add user tokens to MCODE definition
* 19/12/05 RHA DEV00015823 Spindle Clamp Control
* 25/01/06 RHA DEV00016090 Add token for If Through Tool Coolant
* 26/01/06 RHA DEV00016091 Make Y suppression optional
* 27/01/06 RHA DEV00015773 Correct spindle selection in chuck clamping tokens
* Version 10.75
* 21/04/06 RHA DEV00014455 Combine two spindle clamping mechanisms #AUTOCLAMP
* 25/04/06 RHA DEV00016963 Add 5 axis tokens and variables
* 24/05/06 RHA DEV00015514 #INDEXTLO - Rapid after toolchange following lathe index
* Version 11.0
* 01/08/06 RHA DEV00017802 Correct setting of OFFSETX token for rough and finish turn
* 07/08/06 RHA DEV00017776 Add Spindle not started warning option
* Version 11.5
* 20/09/06 RHA DEV00017909 Expand trace options
* 10/10/06 RHA DEV00018318 Create template for WFL Siemens840
* 06/11/06 RHA DEV00016817 Cancel TLO, control improvements
* 08/11/06 RHA DEV00016814 Stop options on turret synch
* 14/11/06 RHA DEV00012251 Implement cylindrical mode for radial tools
* 20/11/06 RHA DEV00018318 Additions for Gildemeister
* 22/11/06 RHA DEV00018299 Correct part catcher codes
* 22/11/06 RHA DEV00013667 Correct setting of #DRIVENKEEP
* 24/11/06 RHA DEV00017578 Var for suppression of duplicate B settings
* 07/12/06 RHA DEV00018666 Add synchronous speed tokens etc for Daewoo
* 19/12/06 RHA             Add Bar Pull Capability
* 20/12/06 RHA DEV00018813 Gildemeister docking requirements
* 08/01/07 RHA DEV00018930 Add Peck Safe Distance token
* 16/01/07 RHA DEV00018815 Additional Gildemeister provisions
* 08/02/07 RHA DEV00019202 Correct CY cycle depth for radial
* 09/02/07 RHA DEV00019202 Move change to Siemens Code Constructor
* Version 11.75
* 20/03/07 RHA DEV00019499 Tokens for 4 axis subspin moves
* 20/03/07 RHA DEV00019508 Change dwell G code to dedicated variable
* 12/04/07 RHA DEV00019713 Implement output options for multi-turret - #SUPPSPEED
* 24/04/07 RHA DEV00019798 Bar Pull Datum Shift
* 24/04/07 RHA DEV00018666 Docking CSS Preserve
* 04/05/07 RHA DEV00019931 Bar Pull Z values and dock warning
* 22/05/07 RHA DEV00019989 Close bracket token for C Move - Siemens
* Version 12.00
* 12/07/07 RHA DEV various Make G Codes more robust G00 G01 G80
* 13/07/07 RHA F Spec      Spindle brake strategy enhancements
* 16/07/07 RHA F Spec      Length offset adjustment for Mazak sub spindle
* 19/07/07 RHA DEV various Make G Codes more robust G00 G01 G80, introdce #DRGCODE
* 23/07/07 RHA F Spec      Additional work for Mazak Matrix CGD
* 30/07/07 RHA F Spec      Fusion format - U word in CY R to TC
* 22/08/07 RHA DEV00020772 Remove duplicate declarations
* 23/08/07 RHA DEV00020782 Force TLO after 5 axis ON option
* 14/09/07 RHA DEV00021011 #BRAKEFORCE1,#BRAKEFORCE2 for Integrex
* 17/09/07 RHA DEV00021033 Spinbrake token availability
* 18/09/07 RHA DEV00021048 Spindle clamping improvements
* 18/09/07 RHA DEV00021011 Default cut inc, CY Hole cycles
* 21/09/07 RHA DEV00021088 CY G Code references in tokens
* 21/09/07 RHA DEV00021090 Lower turret hole array reversals
* Version 12.25
* 07/11/07 RHA DEV00011484 Token availabilty and maxtools initialisation
* 08/11/07 RHA DEV00019011 Switchable ability to suppress unwanted LT start/end calls
* 14/11/07 RHA DEV00020978 Allocate SS warnings to Turret
* 16/11/07 RHA DEV00019501 Allow modality control of TLO Cancel
* 19/11/07 RHA DEV00021600 Add new tokens for Tool ID and Group
* 11/12/07 RHA DEV00021736 Machine Variable tokens
* 13/12/07 RHA DEV00021845 New token to set Radial/Diametral
* Version 12.5
* 03/12/07 RHA DEV00021142 Siemens Coolant Format Reference
* 18/01/08 RHA DEV00021841, DEV00021908 New optional warnings
* 14/02/08 RHA DEV00022338 Add token for TOOLEN
* 29/02/08 RHA DEV00022594 Integrex Tool ID lookup
* 29/02/08 RHA DEV00022593 Added #FORCEG92
* 04/03/08 RHA DEV00022638 Place sub spin var setting in subsidiary code con
* 04/03/08 RHA DEV00022642 Tool Pos adjustment, LT SS
* 07/03/08 RHA DEV00022711 Arithmetic expression corrupted by Wizard - Workround
* 10/03/08 RHA DEV00022572 Tool tokens new and renamed
* 11/03/08 RHA DEV00022711 Use procedure for calculation
* 14/03/08 RHA DEV00022827 Correct BRAKEHOLD setting from tokens
* Version 2009.1
* 10/04/08 RHA DEV00022717 5 Axis TLO
* 14/04/08 RHA DEV00018979 Correct BNUM reset
* 18/04/08 RHA DEV00020823 Add exact stop code to token calculations
* 22/04/08 RHA DEV00023110 Constant offset token etc for turn cycles
* 28/04/08 RHA DEV00022293 Correct checking of SUBFUNCT in coolant macro
* 30/04/08 RHA DEV00021029 Tapping spindle reversals - Siemens
* 22/05/08 RHA DEV00023233 Check for Y0C0 at polar switch
* 06/06/08 RHA DEV00023578 Move declarations to initialise file
* 16/06/08 RHA DEV00023548 Add M-function to stop/start NC output
* 07/07/08 RHA DEV00023548 M Function to suspend NC Code output
* 09/07/08 RHA DEV00023795/7 Add back bore and helical hole cycle capability
* 16/07/08 RHA DEV00023008 Add chuck name tokens for start and set up code constructors
* 07/08/08 RHA DEV000022514 Allow polar switching at B0 and B180
* 13/08/08 RHA DEV00024387 Correct Format Table reference for token CYCLE_PITCH
* 28/08/08 RHA DEV00023797 ToolDiameter token - helical hole
* Version 2009.2
* 24/10/08 RHA DEV00025000 Allow Rapid after tool change with null move
* 31/10/08 RHA DEV00025355 Correct ;TEXT and token descriptions etc
* 04/11/08 RHA DEV00025072 Helical canned cycle
* 04/11/08 RHA DEV00025327 ORIENT_ANGLE token prevents compilation
* 07/11/08 RHA DEV00025098 Make tool angle available in setup & core tool change
* 21/11/08 RHA DEV00025098 Use new system variable for Included tool angle
* 07/01/09 RHA DEV00025831 Add token for holdertype
* 08/01/09 RHA DEV00022131 Allow Y reversals on driven tools
* 08/01/09 RHA DEV00025770 Bar Feed coords should use reverse and diam settings
*              DEV00024568 Make Tool Unit available in toolchange. Set variable on token
* 16/01/09 RHA DEV00025921 Turret Parking for Integrex
* 04/02/09 RHA DEV00026063 Add force feedtype options
* 04/02/09 RHA DEV00024564 Tool hand, mode  and reversal passed to NC
* 25/02/09 RHA DEV00025921 Safe Park. New tokens for turret datum position
* 03/03/09 RHA DEV00026314 New token for diametral thread depth (Okuma)
* 05/03/09 RHA DEV00026198 Use Job data instead of ASK questions
* 24/03/09 RHA DEV00026748 Thread turn tokens
* 26/03/09 RHA DEV00026063 Feed mode settings for hole cycles
* 02/04/09 RHA DEV00026929 Position token for turret park
* 06/04/09 RHA DEV00026690 Set FEEDMODEHOLD only when G code is output
* 09/04/09 RHA DEV00026853 Correct BAXBRAKE-OFF Format reference
* Version 2010.1
* 02/06/09 RHA DEV00026691 Correct tooling list for lower turret - merged files
* 11/08/09 RHA WI35385 Allow Tool ID default to be 0 instead of null
* Version 2010.1 SP1
* 04/11/09 RHA W36693 Rapid feedrate for lower turret
* Version 2010.2
* 11/11/09 RHA W36658 Add new Thread Mill and canned cycle
* 13/11/09 RHA W36658 Thread Mill depth token
* 23/11/09 RHA W32626 Improve output of hole cycle G codes
* 24/11/09 RHA W33740 Improve Exact Stop Handling
* 11/12/09 RHA W36903 Add "Ask Once" to the NC Styles > Interactive Startup options
* 04/01/10 RHA W33326 Default XZ Offsets to Constant Offset
* 28/01/10 RHA W35391 Allow control of PITCH sign
* 17/02/10 RHA W37659 Add KEEP for cartesian X and use in Polar switching
* 23/02/10 RHA W37859 Add Use Index switch
* 15/03/10 RHA W36738 Support for mini turrets
* Version 2011.1
* 27/05/10 RHA W38292 Add G code Spindle Select token, Okuma and Gneeric ISO
* 27/05/10 RHA W38151 Lower turret cycle start tokens
* 28/05/10 RHA W38151 Use specific Format Table refs to allow for Siemens
* 14/06/10 RHA W38003 Thread mill canned cycle - Moriseiki
* 15/06/10 RHA W38856 Lower Turret CY Arcend formats
* 15/06/10 RHA W37934 Thread mill canned cycle - Siemens
* 06/07/10 RHA W38003 Detail adjustments
* 13/07/10 RHA W39785 Implement tap type setting at toolchange
* 09/08/10 RHA W39968 Output Roughing Contour Start for Siemens
* 10/08/10 RHA W34977 CY milling, more spindle brake control options
* 19/08/10 RHA W32695 Control allowable chamfer for helical hole cycle
* 20/08/10 RHA W40114 Enable force feed at start of turning cycles
* 25/08/10 RHA W36639 Add lengthoffset to tooling data and set up sheet
* Version 2011.2
* 15/11/10 RHA W33503 Remove unwanted ;CODE: from OKUMA output blocks
* 16/11/10 RHA W33504 Remove unwanted ;CODE: from NAKAMURA output blocks
* 17/11/10 RHA W33503 Remove unwanted ;CODE: from OKUMA output blocks
* 17/11/10 RHA W40496 Use procedure for precision rounding & apply to angular values
* 19/11/10 RHA W33504 Remove unwanted ;CODE: from NAKAMURA output blocks
* 22/11/10 RHA W33504 Fix Tool Convert angle and Work Piece Angle
* 23/11/10 RHA W35497 Add Half distance token for Push Check
* 26/11/10 RHA W35497 Integrex Matrix, Z APPROACH token wrt Main
* 30/11/10 RHA W35497 Integrex Matrix, Declare #HALF1, fix calculation and format
* 02/12/10 RHA W35497 Fix half push formatting - separate table entry
* 02/12/10 RHA W41737 Improve IF_CSS IF_RPM tokens
* 03/12/10 RHA W41935 Option for cycle approach inside/outside cycle definition
* 09/12/10 RHA W41998 Add peck token to tapping cycle
* 16/12/10 RHA W41935 Fix Siemens START tokens
* 05/01/11 RHA W30504 Incremental B angle flag
* 10/01/11 RHA W40121 Fix CRC Register in Rapid After Toolchange
* 24/01/11 RHA W35876 Add Lower Turret Main options
* 28/01/11 RHA W42399 Add tapping type code for Siemens
* 01/02/11 RHA W41464 Add warning if no Rapid To Toolchange
* 07/02/11 RHA W42491 Correct tool change monitoring for twin turrets #TOOLCHANGE0,#TOOLCHANGE1
* 09/02/11 RHA W42815 Set #ATREFPT at Home and protect for merged twin turrets
* 11/02/11 RHA W42491 Check #TOOLCHANGE in PT_OUTPUT_FEED for spindle processing
* Version 2012.1
* 17/05/11 RHA W44357 Check spindle speeds in Docking procedure
* 23/05/11 RHA W44087 Allow gear code output for single gear spindles
* 24/05/11 RHA W42981 Find gear when spindle stopped (option)
* 09/06/11 RHA W30605 Implement Rough Profile canned cycle
* 22/06/11 RHA W42241 Selective threadmill canned cycles
* 23/08/11 RHA W45835 Implement Tool Offset modifier in linear feed and arc blocks
* 24/08/11 RHA        Remove duplicate declaration #XAPPROACH
* 30/08/11 RHA W45928 Correct #THRDINT variable use clash
* 25/08/11 RHA W45902 Turret Park variables and tokens
* 14/09/11 RHA W36919 Programmable Tailstock fixes
* 06/10/11 RHA W46662 Corrections to Change Offset coding
* Version 2012.2
* 27/10/11 RHA W46914 Add REPEAT_ID token for use with CHANGEOFFSET
* 31/10/11 RHA W46914 Use procedure to set variables for Offset Change
* 01/11/11 RHA W46653 Tailstock movement options
* 08/11/11 RHA W47189 Options for G68 datum
* 07/11/11 RHA W46019 Make diametral rounding optional
* 09/11/11 RHA W46914 Use procedure to set variables for CHANGEOFFSET2
* 21/12/11 RHA W47111 Force GCode after Dwell
* 05/01/12 RHA W44024 Additional Lower Turret code swaps
* 14/02/12 RHA W47190 Additional token availability and m/c datum option
* 15/03/12 RHA W39775 Implement Combined Coolant options in CY coolant control
* 29/03/12 RHA W49819 Expand steady movement options
* Version 2013.1
* 14/06/12 RHA W47992 & W50538 Separate format address for POLAR_Y on sub spindle
* 12/07/12 RHA W42904 Add Specified Range to Tool Offset options
* 17/07/12 RHA W42904 Set default format for Siemens 840 (PGZ Manual)
* 18/07/12 RHA W51315 Correct spindle speed settings - individual spindle tokens
* 31/07/12 RHA W51030 Implement multi-turret synch for Siemens template
* 09/08/12 RHA W30772 Add CY_ZSAFE and CY_ZLEVEL tokens for CY hole cycles
* 09/08/12 RHA W51763 Add NEXT_GROUP_NUMBER token for Integrex
* 21/08/12 RHA W51030 Changes for more than 2 turrets
* 21/08/12 RHA W30772 Add ZSAFE and ZLEVEL tokens to fixed tool hole cycles
* 22/08/12 RHA W52427 Correct use of #TEMP in CODECON_RA-AFTER-TOOLCHANGE
* 23/08/12 RHA W50546 New token for 5Axis C move on sub spindle - Integrex
* 28/08/12 RHA W52552 Fix TLO extra options
* 30/08/12 RHA W43286 Support peck tapping via cycle point calls
* 05/09/12 RHA W52580 Siemens hole cycle parameter corrections
* 12/09/12 RHA W52580 Siemens tapping formats, Rigid tap code description
* 03/10/12 RHA W31018 Correct CPL tool tip option for Rapid to Tool Change
* 17/10/12 RHA W53223 Correct use of tool change position - multiple turrets
* Version 2013.1
* 14/11/12 RHA W53887 Correct Toolchange move from PARK macros
* Version 2013.2
* 22/03/13 GST W54195 Create NEXT tokens for toolchange parameters
* 25/03/13 GST W54191 Force feed type - implement independet floating x rigid tapping
* 22/05/13 RHA W56631 Parking, correct for initial CPL variations, tidy declarations
* 28/05/13 RHA W56631 Parking, Initial CPL (Spindle) now in system variables
* Version 2014.1
* 08/10/13 RHA W56677 Implement new coolant controls
* 23/10/13 RHA W57656 Declare #G200HOLEFLAG
* Version 2014.2
* 05/02/14 RHA W58922 Implement CRC check in rapid moves
* 05/03/14 RHA W55287 variable for Executive Macro reference
* Version 2015.1
* 19/06/14 RHA W65355 Move FEEDGCODE setting to utility procedure
* 16/07/14 RHA W66005 Multiple Turrets - Synchronisation of specific turrets (Templates)
* 30/07/14 RHA W59462 Add angular precision setting
* 30/07/14 RHA W44710 Implement Caxis Helical Code Constructors
* Version 2015.2
* 10/12/14 RHA W80346 Separate set-up sheet for each turret
* 04/02/15 RHA W81327 Tidy declarations for G200
* 11/02/15 RHA W81419 Add Transfer from Sub to Main macro (268)
* 12/02/15 RHA W79953 Option to force XZ at canned start/end blocks
* 21/02/15 RHA W81563 Change Sub Spindle X move format to !FT_XMOVE
* 30/04/15 RHA W82984 Correct sub spindle end movement in Pick and Return
* Version 2016.1
* 17/06/15 RHA ECAM-1016 Provide alternative Speed address format in CY (Okuma)
* 16/06/15 GST W83495 Allow thread turn on YZ plane
* 17/06/15 RHA ECAM-1016 Provide CSS speed format and token (Siemens)
* 06/07/15 GST ECAM-113 Implement MTM Siemens
* 28/07/15 RHA ECAM-2341 Implement angle at Tool Change
* 05/08/15 RHA ECAM-1150 Initialise B angle at Tool Change
*
***********************************************************************************
*
*
;Define^!RAPIDGCODE^1
;Define^!FEEDGCODE^2
;Define^!CIRCGCODE^3
* 1 more
;Define^!DWELLGCODE^5
;Define^!EXACTGCODE^9
* 1 more
;Define^!SETTOOLGCODE^11
;Define^!PLANEGCODE^13
* 2 more
;Define^!UNITSGCODE^16
* 1 more
;Define^!THREADGCODE^18
;Define^!PRESETGCODE^24
;Define^!WORKGCODE^25
* 5 more
;Define^!FINTURNGCODE^32
* Is this used ?
;Define^!RGHTURNGCODE^33
;Define^!CHIPBREAKGCODE^35
;Define^!DRILLGCODE^36
* At least 4 more
;Define^!FEEDMODEGCODE^46
* 1 more
;Define^!CSSGCODE^44
* 1 more
;Define^!ABSINCRGCODE^48
* 1 more
;Define^!RETRACTGCODE^50
* 1 more
;Define^!SIMPLETURNGCODE^53
* 1 more
*	C & Y Axis (Milling) Specific
;Define^!CYRAPIDGCODE^60
;Define^!CYFEEDGCODE^61
;Define^!CYCIRCGCODE^62
;Define^!CYDRILLGCODE^65
*  more
;Define^!CYRETRACTGCODE^74
* 1 more
;Define^!CYPOLARGCODE^76
* 1 more
*
;Define^!HOMEGCODE^78
;Define^!COMPGCODE^85
*   Specific for Okuma turning cycles
;Define^!LAPCODE^88
*
* Rough Profile Cycle
;Define^!PROTURNGCODE^92
*
* Alternative cycle G codes for side and b axis.
;Define^!CYSIDEDRILLGCODE^100
;Define^!BDRILLGCODE^110
*	M Codes
;Define^!STOPMCODE^1
;Define^!SPINMCODE^4
;Define^!TLCHMCODE^7
;Define^!COOLMCODE^8
;Define^!SPINDRIVEMCODE^11
;Define^!SPINCOOLMCODE^14
;Define^!CHUCKOPENMCODE^16
;Define^!CHUCKPSIMCODE^18
;Define^!INDEXTURRETMCODE^20
;Define^!PARTCATCHMCODE^24
;Define^!CONVEYORMCODE^26
;Define^!TAILSTOCKMCODE^28
;Define^!TAILQUILLMCODE^30
;Define^!THREADCHAMFMCODE^32
;Define^!SUBPROGMCODE^34
;Define^!GEARMCODE^36
* CY M Codes
;Define^!CYSPINMCODE^44
* Sub Spindle
;Define^!AIRBLOW^60
;Define^!SUBCLAMP^64
;Define^!CRELEASE^66
;Define^!EJECTMCODE^68
*
*********************************
*
*  Variable Declarations
*
*********************************
*
%DECLARE=#OUTPUTC1,#OUTPUTC2,#SAVEC1HOLD,#SAVEC1KEEP,#SAVEC2HOLD,#SAVEC2KEEP,#ROTDIRSIGN  ; 2304a
%DECLARE=#APPENDHOLD,#USECAMDIR,#ROT1DIR,#ROTROT
%DECLARE=#G54XDATUM,#G55XDATUM
%DECLARE=#C1FIRST,#C2FIRST
%DECLARE=#Y0FORCED
%DECLARE=#TCANGLE,#TCANGLE1,#TCANGLE2,#TCANGLE3,#TCANGLE4
%DECLARE=#CSSSPEED
%DECLARE=#FORCESTART,#FORCEEND
%DECLARE=#SUBXPOS,#SUBZPOS,#SUBGRIPZ ; 3004
%DECLARE=#ACTIVE
%DECLARE=#FIRSTCALL,#TEMPDEPTH,#XMOVEA
%DECLARE=#USERADSH
%DECLARE=#G59,#OUTPUTSHIFTS
%DECLARE=#BASETYPE,#TURNZDATUM,#HOLDZDATUM
%DECLARE=#ARCSWAPYZ
%DECLARE=#CWITHLINEAR
%DECLARE=#OUTPUTSTOP
%DECLARE=#ANGPRECISION,#ANGINCR,#USEHELIXCC,#HELICALPITCH
%DECLARE=#EXECMACRO
%DECLARE=#FIRSTSPINDLE
%DECLARE=#ZAPPKEEP,#XAPPKEEP
%DECLARE=#FORCELEG2
%DECLARE=#TSADJUST,#TSADJUST1
%DECLARE=#RPMHOLD,#ROUGHMACRO,#XREVB180
%DECLARE=#SAVE1,#SAVE2,#SAVE3
%DECLARE=#REFSHIFT,#XFIXED,#YFIXED,#ZFIXED
%DECLARE=#PTCYPECKTAP,#TAPLOOP,#TAPDEPTH,#TAPCOUNT,#ZMOVEA
%DECLARE=#MAXTOOLS3,#MAXTOOLS4,#MACROTEMP,#5AXCMOVE2
%DECLARE=#NEXTGROUPNUM

%DECLARE=$FLAGTUR1,$SYNCHON1,$SYNCHOFF1  ; First Upper
%DECLARE=$FLAGTUR3,$SYNCHON3,$SYNCHOFF3  ; Second Upper
%DECLARE=$FLAGTUR2,$SYNCHON2,$SYNCHOFF2  ; First Lower
%DECLARE=$FLAGTUR4,$SYNCHON4,$SYNCHOFF4  ; Second Lower
%DECLARE=#SYNCALL

%DECLARE=#MAXREG,#DEFAULTREG,#VARI
%DECLARE=#F1HOLD,#POLARMOVE2
%DECLARE=#DRFWDCOOL,#DRREVCOOL
%DECLARE=#STEADYSHIFT,#PMCODE
%DECLARE=#LOWERCYCRC,#SWAPLOWERG2G3CY,#COMPGCODETOTAL
%DECLARE=#FORCEAFTERDWELL
%DECLARE=#ROUNDIAM,#ABSDIAM,#INVDIAM
%DECLARE=#CLOSEDIA,#SCLAMP
%DECLARE=#TAILDATUM,#G68DATUM,#G68SHIFT
%DECLARE=$IDINTEGREX2,#SWARFMCODE
%DECLARE=#HCODEHOLD,#POSREP
%DECLARE=#RESTRELEASE,#RESTCLAMP,#SRCLOSE,#SROPEN,#SRMCODE
%DECLARE=#THRUSTCODE,#ZQUILL,#LOWTHRUST,#MEDTHRUST,#HIGHTHRUST,#QUILLMODE
%DECLARE=#TEMPCOUNT
%DECLARE=#ALLOWSTANG,#ALLOWTAPER,#ALLOWMSTART
%DECLARE=#ROUGHPROF2,#ROUGHPROF1
%DECLARE=#ONEGEARFLG,#GEARWHENSTOP
%DECLARE=#XCYCLEAPP,#ZCYCLEAPP
%DECLARE=#INPUTLEN,$CHAR,$NEWSTRING,$TEMP,#TOOLSTRIP
%DECLARE=#ZPITCH,#NUMSTARTS,#XSTART,#YSTART,#ZSTART,#XTHRDSHIFT,#ZTHRDSHIFT,#ALLOWG76STARTS
%DECLARE=#GEARHOLD
%DECLARE=#CANGOFFSETL,#CANGREVERSE2L
%DECLARE=#USEMAXFEED
%DECLARE=#DRCANNED,#RMCANNED,#BRCANNED,#CHCANNED,#TPCANNED
%DECLARE=#FDRCANNED,#FRMCANNED,#FBRCANNED,#FCHCANNED,#FTPCANNED
%DECLARE=#TOOLRAPWARN,#TOOLRAPWARN1
%DECLARE=#TAPONE,#TAPCHIP,#TAPBREAK
%DECLARE=#COMPDTEMP
%DECLARE=#INCBANGLE
%DECLARE=#LHCYPECKTAP,#LHFPECKTAP
%DECLARE=#APPROACHIN
%DECLARE=#POLARAUTO2
%DECLARE=#SPINCHANGE,#SPINZSHIFT,#SPINTEMP
%DECLARE=#SHIFTACTIVE0,#SHIFTACTIVE1
%DECLARE=#HALF1
%DECLARE=#TEMPSIGN,#TEMPROUND
%DECLARE=#TSIDE,#MAINSIDE,#SUBSIDE,#TOOLCONVERT,#WORKANGLE
%DECLARE=#FORCEFEED3,#FORCEFEED4,#FORCEFEED5
%DECLARE=#OLDMILLMODE,#HECHAMFER
%DECLARE=#TAPWARN,#TAPTYPE
%DECLARE=#SWITCH44
%DECLARE=#TOOLCHANGE2
%DECLARE=#TRCYCLSUB,$TMPSTR,$CYCLTYPE
%DECLARE=#CYCENDSKIP,#TEMPENDMOVE
%DECLARE=#MODEHOLD
%DECLARE=#TRSPEED
%DECLARE=#TOOLCHANGEROT
%DECLARE=#XFIELD12,#ZFIELD12,#ENDSTYLE
%DECLARE=#CONVERTEDMOVE
%DECLARE=#SKIPTAP
%DECLARE=#THRDFLAG
%DECLARE=#CSSXMOVE
%DECLARE=#SPINWARNSAVE

%DECLARE=#CLEARTYPE,#THRDCLEAR
%DECLARE=#KEEPPOINTS,#FIRSTDWELL,#TKEEPLEVEL,#TKEEPDEPTH,#MULTICALL,#THISDEPTH
%DECLARE=#THREADDIA2,#THRDDIST,#TMILLG80,#THRDHEIGHT
%DECLARE=#MULTIPOINT,#MPTCODE,#MPTSTART,#MPTCODEINC,#MPTANGINC,#MPTCHECK
%DECLARE=#XCARTKEEP,#USECINDEX
%DECLARE=#PITCHMODE
%DECLARE=#OFFSETPAR
%DECLARE=#GOTPV,#GOTPR,#GOTDE,#GOTID
%DECLARE=#EXACTMODE,#EXACTGCODE

* For thread mill cycle
%DECLARE=#THRDLEVEL,#THRDSTARTZ,#THRDPITCH,#THRDFEED,#THRDPOSFEED,#THREADDIA
%DECLARE=#THRDEPTH,#THRDEPMODE2,#THRDEPMODE,#TURNS,#THRDPLUNGE,#RTYPE,$THRDHAND
%DECLARE=#THRDPITCHMODE,#THRDMILL,#THRDARCOUT,#THRDCLW,#THRDCCLW,#TMILLUPWARD,#TMPCLEAR
%DECLARE=#THRDUPCUT,#THRDCLIMB,#THRDINOUT,#THRDINCODE,#THRDOUTCODE
%DECLARE=#THREADCANNED,$THRDLEFT,$THRDRIGHT,#THREADMIN,#MILLPOINTS

%DECLARE=$TOOLIDNULL,#CODEWARN
%DECLARE=#PASSKEEP
%DECLARE=$PARKPOS,$UPPERMAIN,$UPPERSUB,$LOWERMAIN,$LOWERSUB
%DECLARE=#DEPTH2,#DEPTH3,#DEPTH4
%DECLARE=#QUESTION
%DECLARE=$TOOLHAND,$TOOLREVERSE,$TOOLMODE
%DECLARE=$TOOLLEFT,$TOOLNEUTRAL,$TOOLRIGHT
%DECLARE=$TOOLSTATIC,$TOOLDRIVEN
%DECLARE=$TOOLREVYES,$TOOLREVNO
%DECLARE=#FTYPETURN,#FTYPETHRD,#FTYPEMILL,#FTYPETAP,#FTYPETAPRIG
%DECLARE=#XTPARK,#YTPARK,#ZTPARK
%DECLARE=#XPARK,#YPARK,#ZPARK
%DECLARE=#XPARKINC,#YPARKINC,#ZPARKINC
%DECLARE=#XT1PARK1,#YT1PARK1,#ZT1PARK1
%DECLARE=#XT1PARK2,#YT1PARK2,#ZT1PARK2
%DECLARE=#XT2PARK1,#YT2PARK1,#ZT2PARK1
%DECLARE=#XT2PARK2,#YT2PARK2,#ZT2PARK2
%DECLARE=#XT3PARK1,#YT3PARK1,#ZT3PARK1
%DECLARE=#XT3PARK2,#YT3PARK2,#ZT3PARK2
%DECLARE=#XT4PARK1,#YT4PARK1,#ZT4PARK1
%DECLARE=#XT4PARK2,#YT4PARK2,#ZT4PARK2
%DECLARE=#BARX,#BARZSTART,#BARZEND
%DECLARE=#YREVERSE,#YMAINDRIVEN,#YSUBDRIVEN,#YBSUBREVERSE
%DECLARE=#SWORD
%DECLARE=#ENDHELICAL,#HELAX,#CYCLEVEL
%DECLARE=#FORCEAFTERTC
%DECLARE=#BBCYCLE,#BFCYCLE,#HECYCLE,#HOLE2DIAM
%DECLARE=#BBGCODE1,#BFGCODE1,#HELGCODE1,#BBGCODE2,#BFGCODE2,#HELGCODE2
%DECLARE=#ZCLEAR2,#G200HOLES
%DECLARE=#CFIRST
%DECLARE=#XAXIS,#YAXIS,#ZAXIS
%DECLARE=#CHECKZERO,#CHECKBPOLAR
%DECLARE=#CYLMODE
%DECLARE=#MASKHOLD,#MASKHOLD2,#MASKHOLD3,#NCSUPPRESS
%DECLARE=#REVAXIALB
%DECLARE=#APPROACH3D
%DECLARE=$IDINTEGREX,#TLOSHIFT5AX
%DECLARE=$TOOLID1,$TOOLID2,$TOOLID3,$TOOLID4,$TOOLID5,$TOOLID6,$TOOLID7,$TOOLID8,$TOOLID9
%DECLARE=$TOOLID10,$TOOLID11,$TOOLID12,$TOOLID13,$TOOLID14,$TOOLID15,$TOOLID16,$TOOLID17,$TOOLID18,$TOOLID19
%DECLARE=$TOOLID20,$TOOLID21,$TOOLID22,$TOOLID23,$TOOLID24,$TOOLID25,$TOOLID26,$TOOLID27,$TOOLID28,$TOOLID29
%DECLARE=$TOOLID30,$TOOLID31,$TOOLID32,$TOOLID33,$TOOLID34,$TOOLID35,$TOOLID36,$TOOLID37,$TOOLID38,$TOOLID39
%DECLARE=$TOOLID40,$TOOLID41,$TOOLID42,$TOOLID43,$TOOLID44,$TOOLID45,$TOOLID46,$TOOLID47,$TOOLID48,$TOOLID49
%DECLARE=$TOOLID50,$TOOLID51,$TOOLID52
%DECLARE=#FORCEG92
%DECLARE=#TAPERWARN,#SUBWARN
%DECLARE=#SSTURRET
%DECLARE=#ARRAYREV1,#ARRAYREV2,#LTSTART
%DECLARE=#CYCUTINC
%DECLARE=#BRAKEFORCE1,#BRAKEFORCE2
%DECLARE=#X2POLARREV,#5AXTLO
%DECLARE=#ITEMP,#KTEMP
%DECLARE=#SUBREVCRCDRIVEN
%DECLARE=$SUBSHIFT,#SSDAT
%DECLARE=#CHECKRAPID,#COMPACTIVE
%DECLARE=#COMPCON,#COMPCOFF,#COMPMAIN,#COMPSUB,#COMPCANCEL
%DECLARE=#COMPOSITEMODE,#COMPOSITEON,#COMPOSITEOFF
%DECLARE=#SUBTLOADJUST,#SUBPOSADJUST
%DECLARE=#COMPDCODE1
%DECLARE=#TRC,#TRR
%DECLARE=#XRAWHOLD,#YRAWHOLD,#RRAWHOLD,#CRAWHOLD
%DECLARE=#BSUBREVERSE,#BSUBREVERSE2
%DECLARE=#BMODAL,#5AXDIAM
%DECLARE=#RKEEP
%DECLARE=#LOOP2
%DECLARE=#HOLEFLAG
%DECLARE=#POLARMOVEHOLD
%DECLARE=#G12FLAG
%DECLARE=#XCYCSTART,#ZCYCSTART,#BNUMTEMP
%DECLARE=#CYCENDMOVE
%DECLARE=#YSTOREABS
%DECLARE=#LOWERREVCRC
%DECLARE=#G200TYPE
%DECLARE=#X2RADIAL,#X2DRIVEN,#XSUBRADIAL

%DECLARE=#DRGCODE,#CYCSPINBRAKE
%DECLARE=#DOCKPOS,#BPZOFFSET,#BPZPOS
%DECLARE=#DWELLGCODE
%DECLARE=#PECKSAFE,#BARDIAM
%DECLARE=#SYNCHDIR,#SYNCHSTOP,#SYNCHFWD,#SYNCHREV
%DECLARE=$NEXTCOM,#BMOVE2,#TOOLORI
%DECLARE=#PREVHEADER,#HEADERPLUS,$PATHNAME,$MAINDRIVENCODE1,$SUBDRIVENCODE1
%DECLARE=#BREFXHOLD,#BREFYHOLD,#BREFZHOLD,#SUPPRESSB
%DECLARE=#RADCYL,#CYLGCODE,#CYLOFFGCODE
%DECLARE=#XREV,#CYLX
%DECLARE=#TLOMODAL,#CANCELCODE,#TLOACTIVE
%DECLARE=#DIAMABS,$RADIAL,$DIASTRING,$DIAMETRAL
%DECLARE=$TLCOS,$TLCOSHOLD,$TLCOSTURN,$TLCOSAX,$TLCOSRAD,$TLCOSB
%DECLARE=#THRDTYPE,#THRDINTFLG,#THRDINT,#THRDEXT,#THRDROOT
%DECLARE=#TZRABSINCR,#TRETRACTINC,#TCLEARINC
%DECLARE=#FGROUPCX,#FGROUPCZ,#FGROUPON
%DECLARE=$SPINSELECT,$MAINSPINDLECODE,$SUBSPINDLECODE,$MAINDRIVENCODE,$SUBDRIVENCODE
%DECLARE=#CLEARINC,#FORCEGCODE
%DECLARE=#DIRECTION1,#DIRECTION2,#DIRECTION3,#DIRECTION4,#SPEED1,#SPEED2,#SPEED3,#SPEED4,#GEARMCODE1,#GEARMCODE2,#GEARMCODE3,#GEARMCODE4
%DECLARE=$BRAKE,$BRAKEHIGH,$SUBBRAKEHIGH,$BRAKEOFF,$SUBBRAKEOFF,$SUBBRAKELOW,$BRAKELOW
%DECLARE=$IBRKT,$JBRKT,$KBRKT,$C1BRKT,$C2BRKT
%DECLARE=$TCMAC,$TCU,$TCUD,$TCL,$TCLD,$SCON,$NEXTDESCR
%DECLARE=$NEXTGROUP,$NEXTGROUPSTRING,$NEXTID,$NEXTIDSTRING
%DECLARE=#NEXTIDNUMBER
%DECLARE=#TRPLANE,#TRDEPTH,#TRTHREAD,#TRHOLE,#TRENDS,#TRMACHINE,#TRMODE,#TRSTARTS,#TRX,#TRY,#TRZ,#TRC1,#TRC2,#TRB
%DECLARE=#SPINWARN,#SPINHOLD
%DECLARE=#INDEXTLO,#SPINBLOCK
* 5 Axis
%DECLARE=#AX5MODE,#FIVEAXISKEEP,#AX5USEIJK,#AX5IJK,#AX5ON,#AX5OFF,#AX5INVTIME,#AX5FEED
* Spindle clamp variables
%DECLARE=#BRAKEON,#BRAKELOW,#BRAKEHIGH,#BRAKEOFF
%DECLARE=#SUBBRAKEON,#SUBBRAKELOW,#SUBBRAKEHIGH,#SUBBRAKEOFF
%DECLARE=#SPINBRAKE,#AUTOCLAMP
%DECLARE=#BRAKESTRAT1,#BRAKESTRAT2,#BRAKESTRAT3,#BRAKESTRAT4,#BRAKESTRAT5,#BRAKESTRAT6
%DECLARE=#BRAKESTRAT2A,#BRAKESTRAT2B,#BRAKESTRAT2C
*********************************
%DECLARE=#YSUPPRESS
%DECLARE=#XZRADIAL
%DECLARE=#RPDIAM
%DECLARE=#G76CHECK
%DECLARE=#TDIR,#AXIAL,#RADIAL,#REVAXIAL,#AXIAL180,#RADIAL180,#REVAXIAL180
%DECLARE=#KVALPITCH
%DECLARE=#PREPOSITION
%DECLARE=#POLARAUTO,#POLARMAN
%DECLARE=#LASTBMOVE,#SHUFFLE,#XTHRDHOLD,#YTHRDHOLD,#ZTHRDHOLD
%DECLARE=#REVERSEFACE
%DECLARE=#COMPGCODEKEEP
%DECLARE=#RADNEG
%DECLARE=#SPINDATUM,#SPINSHIFT,#SPINSHIFTX
%DECLARE=#MAXMAIN,#MAXSUB,#MINMAIN,#MINSUB
%DECLARE=#TLOSHIFT
%DECLARE=#USECCONDRIVEN
%DECLARE=#CSSRPMCHECK
%DECLARE=$TURRETUPPER,$TURRETCODE,$TURRETLOWER
%DECLARE=$BRKT1,$BRKT2
%DECLARE=#POLARMOVE,#POLARDIAM
%DECLARE=#RIGIDTAP,#RIGIDRIGHT,#RIGIDLEFT,#RIGIDRIGHT2,#RIGIDLEFT2
%DECLARE=#SYNCHSPEED,#SYNCHPHASE,#SYNCHOFF
%DECLARE=#TURRETSIDECODE,#TURRETLEFT,#TURRETRIGHT
%DECLARE=#SPINDLE,#PRIORITYMAIN,#PRIORITYSUB
%DECLARE=#CHUCKPOS,#IGNORESTATICB
%DECLARE=#TEMPFEEDHOLD,#TEMPSPEEDHOLD
%DECLARE=#MILLGEAR1,#MILLGEAR2,#MILLGEAR3,#MILLGEAR4
%DECLARE=#ORIENTATION,#MAINORIENTATION,#SUBORIENTATION
%DECLARE=$UPPER,$LOWER
%DECLARE=#SUPPORTMDEPTH
%DECLARE=#WARNCOUNT,#EJECT,#EJECT2
%DECLARE=#THDBLKCOUNT,#THDSHIFT,#THDPASSES,#THDPITCH
%DECLARE=#THDPASSCOUNT,#THDLAST

%DECLARE=#RETRACTINC
%DECLARE=#RAPIDPOLAR,#FEEDPOLAR,#HOLEPOLAR,#LISTCODE,#BLOCKTMP
%DECLARE=#BOTHHEADERS
%DECLARE=#SETUPHEAD,#SETUPTRAIL

%DECLARE=#XSUB1,#BREFDIAM
%DECLARE=#TMPGCODE
%DECLARE=#CSSRAD,#SETCSSNEXT
%DECLARE=#CSSGHOLD,#NOCSSRAD,#NOCSSSPIN
%DECLARE=#CAXISHOLD,#CSWITCH,#CANGLIMIT
%DECLARE=$PROCEDURE,$SPC,#PROCTRACE,#PROCTRACE2
%DECLARE=#XTOOL,#ZTOOL,#MACRO,#XTEMP,#DIAM,#IKDIAM,#CONVERTUNITS,#XSAFE
* #TEST,#PROF
%DECLARE=#ZSAFE,$CYCLE,#INCHINCR,#MMINCR,#LEADER,#PROGID,#INCANGLE,#TRUE,#FALSE,#PI
*	Block Numbering
%DECLARE=#BNUM,#BNUMSTART,#BNUMINC,#USEBNUM,#BNUMVAR,#RESTARTSUBSBNUM,#BNUMHOLD,#FORCEBNUM
%DECLARE=#SBNUMCOUNT,#FORCESBNUM,#SBNUM,#USESBNUM,#SBNUMINC
*	G (preparatory) codes
%DECLARE=#PLANEGCODE,#GCODE,#UNITSGCODE,#EXACTSTOP
*		Circular Interpolation
%DECLARE=#JVALUE,#KVALUE,#BEARING1,#BEARING2,#OUTPUTRADS,#INCR,#IVALUE,#RADIUS
%DECLARE=#XCENTRE,#ARCTYPE,#USERADS,#STEP,#BEARING
*	Spindle / Gears
%DECLARE=#STEPS,#AUTOGEAR,#GEAR,#GEARMCODE,#RPM
%DECLARE=#SPEEDPTR,#STEPSPTR,#RPMMATCH,#MINRPM,#MAXRPM,#MAXRPMPTR,#USRMAXPTR,#USRMAXRPM,#SCODE,#SCODEINCR
%DECLARE=#MINSCODE,#MAXSCODE,#RPMINC,#TESTRPM,#RPMDIFF,#HOLDRANGE,#USERMAXRPM
%DECLARE=#SPEEDHOLD,#HOLDSCODE
*	General Coordinate Systems
%DECLARE=#XHOME,#ZHOME,#XMOVE,#ZMOVE,#XHOLD,#ZHOLD,#INCRXYZ,#INCRSUBS,#XREVERSE
%DECLARE=#ZREVERSE,#ZSUBREVERSE,#ZMAINREVERSE,#ZSUBDRIVEN
%DECLARE=#XSTOREABS,#ZSTOREABS,#UZERO,#VZERO,#WZERO
*	Rapid Traverse
%DECLARE=#RAPIDFEEDRATE1,#RAPIDFEEDRATE2,#RAPIDFEEDRATE
%DECLARE=#FEEDRAPIDS,#RAPDIST,#FEEDMODEGCODE,#FEEDMODEHOLD,#FEEDMODETEMP,$RAPOLAR
*	Hole Cycles
%DECLARE=#ZRABSINCR,#RETRACT,#RETRACTGCODE,#ZDEPTH,#RPLANE,#DEGR,#DEPTH,#ZCLEAR
%DECLARE=#BOREOFFSET
*	Toolchange / Tooling
%DECLARE=#TOOLCHANGE,#TOOLCHANGE0,#TOOLCHANGE1
%DECLARE=#TLOCOMP,#NEXTTOOL,#FIRSTTOOL,#TOOLDIA,#HCODE,#HCODE5AX
%DECLARE=#ZGAUGE,#XGAUGE,#MAXTOOLS,#MAXTOOLS1,#MAXTOOLS2,$TOOLDESCRIPTION,#TCFUNCT,#MANUALIDX
%DECLARE=#INDEXTURDIR,#TOOLXSET,#TOOLZSET,#SETTOOLGCODE,#TNRX,#TNRZ,#QUAD
%DECLARE=#G92XSET,#G92ZSET,#XGHOLD,#ZGHOLD,#REMOVEDUPLICATES,#HOMEGCODE,#HOMETYPE
*	Subroutines
%DECLARE=#SUBSTARTMCODE,#SUBENDMCODE,#SUBNOSTART,#SUBROUTINE
*	Cutter Radius Compensation
%DECLARE=#COMPGCODE,#COMPDCODE,#COMPON,#CANCELCOMP,#WARNCRC,#WARNCRC90,#AUTOREG
%DECLARE=#WARNCRCARC
*
%DECLARE=$CONDEBUG,$TESTSTRING,$ID,$TYPE,$UNIT,$DESCR,$NAME
%DECLARE=$PROGVER,$MANREADABLE
%DECLARE=#TMP,#TMP1,#TMP2,#MOVE
*  #NEGINCR
%DECLARE=#DELETE,#DIRECTION,#FEED,#FIRSTIME,#FUNNY,#COOL,#COOLSET,#COOLHOLD,#DIRECTHOLD,#DIRHOLD
%DECLARE=#TOOLSHEET,#TOOLSHEET2,#HEADER,#LOOP,#MCODE,#MCODE2,#MCODE3,#SIGN,#SPEED,#TEMP,#UNIT
*	Datum Shifting
%DECLARE=#ZTEMP,#WORKGCODE,#PRESETGCODE,$MCODE
*	Turning Cycles
%DECLARE=#OFFSETXDIAM,#OFFSETX,#OFFSETZ,#CHIP,#CHIPF,#CHIPT,#RTGCODE,#DIRCUT,#DEPTHTURN,#DEPTHFACE,#STURNTYPE
%DECLARE=#XCYCLESTART,#YCYCLESTART,#ZCYCLESTART
%DECLARE=#XSAVESTART,#ZSAVESTART
%DECLARE=#XCYCLEEND,#ZCYCLEEND
*	Threading Cycles
%DECLARE=#CUTCOUNT,#CHAMFSTAT,#MINDOC,#INTHRD,#COANG,#THRDANGLE
%DECLARE=#NUMVECS,#PERPBRG,#CIANG,#ANG,#XPOINT,#BRG,#COS,#COLEN,#PITCH,#IPITCH,#KPITCH
%DECLARE=#ITAPER,#KTAPER,#THREADING,#CHAMFMCODE,#PASSCNT,#THDSTART,#PSTYLE
%DECLARE=#TOTALDEPTH,#NUMCUTS,#XRETRACT
*	Turning General
%DECLARE=#CSSGCODE,#CSS,#CSSOUT,#CSSFACTOR,#SFM
* 4 Axis
%DECLARE=#SYNC1,#SYNC0
%DECLARE=#SYNCNUMINCR,#X2REVERSE,#SWAPG2G3,#UMOVE,#WMOVE,#SYNC,#SYNCL,#TAPEOUTPUT
%DECLARE=$TURRETNAME,#SYNCNUMSTART,#NUMTOOLS
*	Caxis / Yaxis (Milling)
%DECLARE=#USERADSTEMP,#USERADSCY,#USERADSHOLD,#ARCTYPECY,#ARCTYPEHOLD
%DECLARE=#CAXINTERP,#CMOVE,#CMOVE1,#CMOVE2,#RMOVE,#POLARGCODE,#CONVERTCAXRAP
%DECLARE=#CHOLD,#C1HOLD,#C2HOLD,#DRCYCLE,#HOLECYCLES,#SUPPORTG98G99
%DECLARE=$POLAR,$CAXENGAGED
%DECLARE=#YMOVE,#YHOLD,#YTEMP,#CINCR,#NEGCINCR,#ZLEVEL

%DECLARE=$MOVEANG
%DECLARE=#ZINC,#YINC,#ABSZINC,#ABSYINC,#YSTART,#YCENTRE,#YEND
%DECLARE=#WRAPHEIGHT,#WRAPHOLD,#WRAPTYPE,#WRAPRADIUS
%DECLARE=#SUPPSPEED,$WARNING,$MACHINE
%DECLARE=#THREADDIR

* CY Thread Milling
%DECLARE=#COMPCYCLE,#TYPE,#BLOCKSMISSED,#THREADMOVE,#NEXTLOOP,#STARTRAD,#NEXTRADIUS,#ENDRAD,#ARCRADIUS
%DECLARE=#SKIP,$MOVETYPE,#THREADSINGLE,#OUTPUTHELIX,#THISRAD,#NEXTTYPE,#KVAL,#KVALSAVE,#THRDLEAD
%DECLARE=#ZCENTRE

* Compensation
%DECLARE=$COMPOUTPUT,#LEADOUTCOUNT,#COMPGCODEHOLD
* NOTHING SET TO THIS VARIABLE AS YET ?????????
%DECLARE=#PRECISION
* #TOOLYSET,$FIXED,
%DECLARE=#TMP3
*
%DECLARE=#CANGREVERSEL,#CANGREVERSEANGLEL
%DECLARE=#CANGREVERSE,#CANGMODE,#CANGINCREMENT,#CANGREVERSEANGLE,#RESET360
%DECLARE=#CANGREVERSE2,#CANGREVERSEANGLE2,#CANGREVERSEANGLE2L,#CANGOFFSET2,#CANGOFFSET2L
*User variables for ;CODE command
%DECLARE=#USER1,#USER2,#USER3,#USER4,#USER5,#USER6,#USER7,#USER8,#USER9,#USER10,#USER11,#USER12,#USER13,#USER14,#USER15,#USER16,#USER17,#USER18,#USER19,#USER20
%DECLARE=$USER1,$USER2,$USER3,$USER4,$USER5,$USER6,$USER7,$USER8,$USER9,$USER10,$USER11,$USER12,$USER13,$USER14,$USER15,$USER16,$USER17,$USER18,$USER19,$USER20,$USER


%DECLARE=#INCRSUBNUMBER,#XSUB,#YSUB,#ZSUB,#INCRXYZHOLD

******************************
* Advanced Turn Declarations
******************************

*CHANGE
%DECLARE=#MILLMODE,#MILLPLANAR,#MILLROTARY
%DECLARE=#IVECTOR,#JVECTOR,#KVECTOR ; CPL vectors for B axis milling
%DECLARE=#FACEANGLE                 ; Angle of face for B axis milling (R Word)
%DECLARE=#BMOVE,#BANGREVERSE,#BANGMAX,#BANGMIN,#BANGINCREMENT,#BANGADJUST
%DECLARE=#MACHINEMINRPM,#MACHINEMAXRPM ; Machine RPM limits for current spindle
%DECLARE=#SPINSELECT,#SPINSELECTHOLD ; Spindle selection M code
%DECLARE=#DIRECTHOLDSUB,#DIRECTHOLDTOOL ; Spindle directions
%DECLARE=#BHOLD ; Previous value
%DECLARE=#BINDEXPOS
%DECLARE=#ATREFPT,#ATREFPT0,#ATREFPT1 ; Turret at Home/ToolChange
%DECLARE=#BRAKE,#BRAKEHOLD,#BRAKEHOLD2,#BRAKETMP
%DECLARE=#BAXBRAKE,#BAXBRAKEON,#BAXBRAKEOFF
%DECLARE=#MBRAKE,#MBRAKEON,#MBRAKEOFF
%DECLARE=#AUTOBRAKE,#ABRAKEMAIN,#ABRAKESUB
%DECLARE=#ADVMCODE,#ADVANCE,#ADVANCEHOLD ; Sub Spindle movement
%DECLARE=#SUBG2G3,#SUBG2G3DRIVEN,#SUBG2G3DRIVEN2 ; Sub Spindle G2/3 swap
%DECLARE=#MCMINRPM,#MCMAXRPM ; Machine spindle rev limits
%DECLARE=#BDIAM,#DIAMHOLD,#ADIAM,#RDIAM,#TURNDIAM ; Diam settings
* Vars for M codes, spindle 2
%DECLARE=#SPIN2CHUCKCLAMP,#SPIN2CHUCKUNCLAMP,#SPIN2ORIENTATE
%DECLARE=#SPINCREL,#SPIN2CREL,#SPIN2PRESSUREHIGH,#SPIN2PRESSURELOW
%DECLARE=#MAINDATUMCODE,#SUBDATUMCODE,#MAINSPINDLECODE,#SUBSPINDLECODE,#MAINDRIVENCODE,#SUBDRIVENCODE
%DECLARE=#SPINDLECODE; Spindle D word
%DECLARE=#TOOLSTATIC,#TOOLDRIVEN,#SUBTOOLSTATIC,#SUBTOOLDRIVEN,#DRIVENTOOL,#DRIVENKEEP ; Driven tool flags
%DECLARE=#CMOVEHOLD,#CSTAT,#VMOVE
%DECLARE=#ACLAMP,#ACLAMPHOLD ;A Axis clamp
%DECLARE=#LOWERTOOLPOS
%DECLARE=#COORDNUM,#G54,#G55,#G56,#G57,#G58,#UNIQUEDATUMS,#SYSID
* Misc control functions G or M
%DECLARE=#AIRBLOW1,#AIRBLOW2,#PROGEND,#SPINID,#SPINSYNCH,#DOOR,#TCHANGE,#CANCELTLO
%DECLARE=#SUBSPING ; sub spindle movement G code
%DECLARE=#UPPERTYPE,#LOWERTYPE ; Tool Change types
%DECLARE=#DRIVEN,#PUSHG,#AUTOTLO,#AUTOTLO2
%DECLARE=#CCONVERT,#CCONVON,#CCONVOFF
*
* Coolant
%DECLARE=#AIRCOOL,#AIRCOOL1,#AIRCOOL2
%DECLARE=#AUTOCHUCKFACE,#AUTOTURRET,#AUTOSPINDLE
%DECLARE=#CHUCKFACE1AIR,#CHUCKFACE2AIR,#TURRETFACE1AIR,#TURRETFACE2AIR
%DECLARE=#CHUCKFACE,#TURRETFACE,#THROUGHTOOL,#THROUGHSPIN
%DECLARE=#CHUCKFACE1,#CHUCKFACE2,#CHUCKFACE1ON,#CHUCKFACE1OFF,#CHUCKFACE2ON,#CHUCKFACE2OFF
%DECLARE=#TURRETFACE1,#TURRETFACE2,#TURRETFACE1ON,#TURRETFACE1OFF,#TURRETFACE2ON,#TURRETFACE2OFF
%DECLARE=#THROUGHTOOL1,#THROUGHTOOL2,#THROUGHTOOL1ON,#THROUGHTOOL1OFF,#THROUGHTOOL1HIGH,#THROUGHTOOL2ON,#THROUGHTOOL2OFF,#THROUGHTOOL2HIGH
%DECLARE=#THROUGHSPIN1,#THROUGHSPIN2,#THROUGHSPIN1ON,#THROUGHSPIN1OFF,#THROUGHSPIN2ON,#THROUGHSPIN2OFF
%DECLARE=#CPRESS,#COOLCHANGE
%DECLARE=#CHUCKFACE1HOLD,#CHUCKFACE2HOLD,#TURRETFACE1HOLD,#TURRETFACE2HOLD,#THROUGHTOOL1HOLD,#THROUGHTOOL2HOLD,#THROUGHSPIN1HOLD,#THROUGHSPIN2HOLD
%DECLARE=#NEEDTHROUGH,#SETCHUCKCOOL,#SETTURRETCOOL,#SETSPINDLECOOL,#SETALLCOOL

%DECLARE=#XAPPROACH,#ZAPPROACH,#ZAPPMAIN,#CODETECT,#CODETECTCODE,#DOCK

%DECLARE=#TRANSFERSHIFT,#TRANSFERPOS,#G54ZDATUM,#G55ZDATUM,#SUBSPINDLETOFACE1

%DECLARE=#LEVELCHANGE,#ZLEVELHOLD,#ZDEPTHHOLD

%DECLARE=#XCLEAR

%DECLARE=#XMAINREVERSE,#XSUBREVERSE,#XSUBDRIVEN,#TEMPDIAM

%DECLARE=#CONTROL,#MAINUPPER,#MAINLOWER,#SUBUPPER,#SUBLOWER

%DECLARE=#ABSINC

%DECLARE=#LOWMAIN,#LOWSUB,#HIGHMAIN,#HIGHSUB
%DECLARE=#CSSKEEP

%DECLARE=#CYCLEPOINTS
* To pass HOLD values to code constructors
%DECLARE=#XKEEP,#ZKEEP,#YKEEP,#C1KEEP,#C2KEEP,#BKEEP,#POLARKEEP

%DECLARE=#WRAP,#FEEDMODESAVE,#AUTOCOOL,#AUTOTAPOFF

* Move from Daewoo
%DECLARE=#TAPLEFT,#TAPLEFTON,#TAPLEFTOFF
%DECLARE=#CONVERSION,#TURNTOOLBANG,#JVAL,#PULLG
%DECLARE=#DWORD
%DECLARE=#SPINREL
%DECLARE=#NCLAST,#NCSPIN,#G400MISS
%DECLARE=#G400DRMISS

* Controller variables - Integrex
%DECLARE=$MACVAR1,$MACVAR2,$MACVAR3,$MACVAR4,$MACVAR5,$MACVAR6,$MACVAR7,$MACVAR8
%DECLARE=#SUBJAWMOVE
%DECLARE=#DIAMOFF,#DIAMODE,#DIAMON

* IndexG200 variables in standard files
%DECLARE=#G200HOLEFLAG
%DECLARE=#TRANSMITMODE
%DECLARE=#XMOVEmode0,#YMOVEmode0,#ZMOVEmode0
*********************************
*
*  Code Constructor Token Definitions
*
*********************************
*
*Token^token name^format^desc^action before output^action after output^Turret designation

*	G-Codes	:	General
;Token^<75>^RAPIDGCODE^[#GCODE=!FT_GCODE]^<76>Rapid Code
;Token^<77>^FEEDGCODE^[#GCODE=!FT_GCODE]^<78>Feed Code
;Token^<79>^CLWGCODE^[#GCODE=!FT_GCODE]^<80>CLW Code
;Token^<81>^CCLWGCODE^[#GCODE=!FT_GCODE]^<82>CCLW Code
;Token^<83>^COMPGCODE^[#COMPGCODE=!FT_GCODE]^<84>TNR Compensation Code
;Token^<1635>^COMP OFF^[#COMPGCODE=!FT_GCODE]^<1636>Initialise CRC Off
;Token^<85>^DWELLGCODE^[#DWELLGCODE=!FT_GCODE]^<86>Dwell Code
;Token^<87>^EXACTSTOPGCODE^[#EXACTGCODE=!FT_GCODE]^<88>Exact Stop Code
;Token^<89>^PLANEGCODE^[#PLANEGCODE=!FT_GCODE]^<90>Coordinate Plane
;Token^<91>^UNITSGCODE^[#UNITSGCODE=!FT_GCODE]^<92>NC program Units
;Token^<912>^ABS-INC^[#ABSINC=!FT_GCODE]^<913>Absolute/Incremental Coords Code

* Added for Integrex only at present
;Token^<2237>^ABS-CODE^[#ABSINC=!FT_GCODE]^<913>Absolute/Incremental Coords Code
;Token^<2238>^INC-CODE^[#ABSINC=!FT_GCODE]^<913>Absolute/Incremental Coords Code

*	G Codes	:	Hole Cycles
;Token^<93>^RETRACTGCODE^[#RETRACTGCODE=!FT_GCODE]^<94>Cycle Retract Code
;Token^<95>^DRILLGCODE^[#DRGCODE=!FT_GCYCLE]^<27>Drill Cycle
;Token^<96>^SPOTGCODE^[#DRGCODE=!FT_GCYCLE]^<97>Spot Face Cycle
;Token^<98>^PECKGCODE^[#DRGCODE=!FT_GCYCLE]^<99>Peck Drill Cycle
;Token^<100>^TAPGCODE^[#DRGCODE=!FT_GCYCLE]^<28>Tapping Cycle
;Token^<2120>^RIGIDTAP^[#RIGIDTAP=!FT_MCODE]^<2147>Rigid Tapping M Code
;Token^<101>^REAMGCODE^[#DRGCODE=!FT_GCYCLE]^<102>Ream / Bore Cycle
;Token^<103>^BOREGCODE^[#DRGCODE=!FT_GCYCLE]^<104>Bore Cycle
;Token^<105>^ENDCYCLEGCODE^[#DRGCODE=!FT_GCYCLE]^<106>End Canned Cycle
;Token^<107>^CHIPBREAKGCODE^[#DRGCODE=!FT_GCYCLE]^<108>Chipbreak Drill Cycle
;Token^<109>^PRESETGCODE^[#PRESETGCODE=!FT_GCODE]^<35>MAX RPM / Preset Registers
;Token^<110>^WORKGCODE^[#WORKGCODE=!FT_WORKGCOORD]^<111>Work / Fixture Offset
;Token^<112>^FEEDMODEGCODE^[#FEEDMODEGCODE=!FT_GCODE]^<113>Feed REV / MIN
;Token^<3730>^FEEDMODEBLOCK^^<3731>Calls Feed Mode Change if Needed

*	G Codes	:	Turning Cycles
;Token^<114>^RGHTURNGCODE^[#GCODE=!FT_GCYCLE]^<115>Rough Turn / Face Cycle
;Token^<116>^SIMTURNGCODE^[#GCODE=!FT_GCYCLE]^<117>Simple Turn / Face Cycle
;Token^<118>^FINTURNGCODE^[#GCODE=!FT_GCYCLE]^<119>Finish Turn Cycle
;Token^<1326>^CYCPROFGCODE^[#GCODE=!FT_GCYCLE]^<1327>Start of Cycle Profile G Code
;Token^<1393>^PROFTURNGCODE^[#GCODE=!FT_GCYCLE]^<1394>Profile Turn Cycle G Code

*	G Codes - Threading
;Token^<120>^THREADGCODE^[#GCODE=!FT_GCODE]^<121>Threading Cycle

*	G Codes - Rapid Home/Toolchange
;Token^<968>^HOMEGCODE^[#HOMEGCODE=!FT_GCODE]^<969>Rapid Home/Toolchange Code
;Token^<2122>^SECOND_LEG^^<2123>Calls second leg code constructor

*	M Codes	:	Coolant
;Token^<1817>^COOLCHUCKFACE^[#CHUCKFACE=!FT_MCODE]^<1818>Chuck Face Coolant
;Token^<1819>^COOLTHROSPIN^[#THROUGHSPIN=!FT_MCODE]^<1820>Through Spindle Coolant
;Token^<1821>^COOLTURRETFACE^[#TURRETFACE=!FT_MCODE]^<1822>Turret Face Coolant
;Token^<1823>^COOLTHROTOOL^[#THROUGHTOOL=!FT_MCODE]^<1824>Through Tool Coolant
;Token^<2124>^COOLTHRTLOFF^[#THROUGHTOOL=!FT_MCODE]^<2125>Through Tool Coolant Off
;Token^<1825>^COOLANT^[#COOL=!FT_MCODE]^<1826>Coolant On/Off
;Token^<124>^COOLANT OFF^[#COOL=!FT_MCODE]^<125>Coolant Off 
;Token^<4379>^COOLANT_TAPS^^<4380>Coolant Code Constructor

*	M Codes	:	General
;Token^<126>^SPINDIR^[#DIRECTION=!FT_MCODE]^<127>Spindle Direction
;Token^<2239>^TURNSTOP^[#DIRECTION=!FT_MCODE]^<2240>Turning Spindle Stop
;Token^<1682>^SPINSTOP^[#DIRECTION=!FT_MCODE]^<49>Spindle Stop
;Token^<1940>^SPINSYNCH^[#SPINSYNCH=!FT_MCODE]^<2126>Spindle Synchronise

;Token^<2938>^PROG_STOP^^<129>Program / Optional Stop
;Token^<128>^STOPMCODE^[#MCODE=!FT_MCODE]^<129>Program / Optional Stop
;Token^<4192>^PROGSTOPMCODE^[#PMCODE=!FT_MCODE]^<45>Program Stop
;Token^<2939>^SAFESTART^^<2940>Call Safe Restart Block
;Token^<1801>^WARNCOUNT^^<1802>Output Warnings Count
;Token^<1827>^EJECT^[#EJECT=!FT_MCODE]^<1828>Eject Part
;Token^<2196>^RETR-EJECT^[#EJECT2=!FT_MCODE]^<2197>Retract Ejector

*	M Codes	:	Chuck
;Token^<1829>^CHUCK-OPEN^[#MCODE=!FT_MCODE]^<57>Chuck Open
;Token^<1830>^CHUCK-CLOSE^[#MCODE=!FT_MCODE]^<1831>Chuck Close
;Token^<1832>^CHUCK2-OPEN^[#MCODE=!FT_MCODE]^<1833>Sub Spin Chuck Open
;Token^<1834>^CHUCK2-CLOSE^[#MCODE=!FT_MCODE]^<1835>Sub Spin Chuck Close
;Token^<130>^CHUCKSTATUS^[#MCODE=!FT_MCODE]^<131>Chuck Open / Closed
;Token^<132>^CHUCKPSI^[#MCODE=!FT_MCODE]^<133>Chuck Pressure

*	M Codes	:	Miscellaneous M-Codes
;Token^<134>^INDEXTURRET^[#INDEXTURDIR=!FT_MCODE]^<135>Turret Index Direction
;Token^<136>^PARTCATCHER^[#MCODE=!FT_MCODE]^<137>Part Catcher Status
;Token^<138>^CONVEYOR^[#SWARFMCODE=!FT_MCODE]^<139>Swarf Conveyor Status
*
* Tailstock tokens
;Token^<140>^TAILSTOCK^[#MCODE3=!FT_MCODE]^<141>Tailstock Status
;Token^<142>^TAILQUILL^[#MCODE2=!FT_MCODE]^<143>Tailstock Quill Status
;Token^<4108>^TS-ZPOSITION^[#ZAPPROACH=!FT_TS_ADV]^<4109>Tailstock Z Approach
;Token^<4110>^TS-ZQUILLPOSITION^[#ZQUILL=!FT_Quill]^<4111>Tailstock Quill Z
;Token^<4112>^TS-THRUST^[#THRUSTCODE=!FT_MCODE]^<4113>Thrust M Code
;Token^<4114>^TS-CLAMP^[#ACLAMP=!FT_MCODE]^<4115>Tailstock Clamp
;Token^<4116>^TS-RELEASE^[#ACLAMP=!FT_MCODE]^<4117>Tailstock Release Clamp
*
* Steady tokens
;Token^<4118>^SR-CLAMP^[#SCLAMP=!FT_MCODE]^<4119>Steady Rest Clamp
;Token^<4120>^SR-RELEASE^[#SCLAMP=!FT_MCODE]^<4121>Steady Rest Release Clamp
;Token^<4122>^SR-MCODE^[#SRMCODE=!FT_MCODE]^<4123>Steady Rest MCode
;Token^<4124>^SR-XAPPROACH^[#XAPPROACH=!FT_SR_X]^<4125>Steady Rest X Approach
;Token^<4126>^SR-ZAPPROACH^[#ZAPPROACH=!FT_SR_Z]^<4127>Steady Rest Z Approach
;Token^<4178>^SR-DIAM^[#CLOSEDIA=!FT_SR_DIA]^<4179>Steady Rest Close Diameter


*	M Codes	:	Threading
;Token^<144>^THREADCHAMFMCODE^[#CHAMFMCODE=!FT_MCODE]^<145>Chamfer Thread

*	General
;Token^<146>^DELETE^[#DELETE=!FT_DELETE]^<147>Block Delete
;Token^<148>^BLKNUM^[#BNUM=!FT_BLKNUM]^<149>Block Number
;Token^<1328>^NATBLKNUM^[#BNUM=!FT_SSNUM]^<1329>Block Number (NAT)
;Token^<150>^SAFEBLKNUM^[#SBNUM=!FT_SAFEBLKNUM]^<151>Safe / Toolchange Block Number
;Token^<152>^PROGDESCR^[$DESCR]^<3732>Ask Program Description
;Token^<154>^XHOME^[#XHOME=!FT_XMOVE]^<155>X Home Position
;Token^<156>^YHOME^[#YMOVE=!FT_YMOVE]^<157>Y Home Position
;Token^<158>^ZHOME^[#ZHOME=!FT_ZMOVE]^<159>Z Home Position
;Token^<1208>^RHOME^[#ZHOME=!FT_RHOME]^<1209>R(Z) Home Position
;Token^<160>^XTOOL^[#XTOOL=!FT_XMOVE]^<161>X Toolchange Position
;Token^<162>^YTOOL^[#YMOVE=!FT_YMOVE]^<163>Y Toolchange Position
;Token^<164>^ZTOOL^[#ZTOOL=!FT_ZMOVE]^<165>Z Toolchange Position
;Token^<1265>^RTOOL^[#ZTOOL=!FT_RHOME]^<1266>R(Z) Tool Position
;Token^<970>^WARNING^[$WARNING]^<971>Warning messages
* CY Movements
;Token^<1836>^CY_XTOOL^[#XTOOL=!FT_CYXMOVE]^<1837>X Toolchange Position Milling
;Token^<1838>^CY_YTOOL^[#YMOVE=!FT_CYYMOVE]^<1839>Y Toolchange Position Milling
;Token^<1840>^CY_ZTOOL^[#ZTOOL=!FT_CYZMOVE]^<1841>Z Toolchange Position Milling
;Token^<1842>^CY_XHOME^[#XHOME=!FT_CYXMOVE]^<1843>X Home Position Milling
;Token^<1844>^CY_YHOME^[#YMOVE=!FT_CYYMOVE]^<1845>Y Home Position Milling
;Token^<1846>^CY_ZHOME^[#ZHOME=!FT_CYZMOVE]^<1847>Z Home Position Milling

* Main movement axes, upper and lower turrets
;Token^<166>^XMOVE^[#XMOVE=!FT_XMOVE]^<167>X Move
;Token^<166>^XMOVE^[#UMOVE=!FT_UMOVE]^<167>X Move
;Token^<168>^YMOVE^[#YMOVE=!FT_YMOVE]^<169>Y Move
;Token^<168>^YMOVE^[#VMOVE=!FT_VMOVE]^<169>Y Move
;Token^<170>^ZMOVE^[#ZMOVE=!FT_ZMOVE]^<171>Z Move
;Token^<170>^ZMOVE^[#WMOVE=!FT_WMOVE]^<171>Z Move
;Token^<1848>^CY_XMOVE^[#XMOVE=!FT_CYXMOVE]^<1849>X Move Milling
;Token^<1850>^CY_YMOVE^[#YMOVE=!FT_CYYMOVE]^<1851>Y Move Milling
;Token^<1852>^CY_ZMOVE^[#ZMOVE=!FT_CYZMOVE]^<1853>Z Move Milling
;Token^<1848>^CY_XMOVE^[#XMOVE=!FT_CYUMOVE]^<1849>X Move Milling
;Token^<1850>^CY_YMOVE^[#YMOVE=!FT_CYVMOVE]^<1851>Y Move Milling
;Token^<1852>^CY_ZMOVE^[#ZMOVE=!FT_CYWMOVE]^<1853>Z Move Milling

;Token^<172>^ZINITIAL^[#ZMOVE=!FT_ZMOVE]^<173>Initial Plane
;Token^<174>^FEED^[#FEED=!FT_FEED]^<175>Feedrate
;Token^<176>^SPEED^[#SPEED=!FT_SPEED]^<177>Spindle Speed

;Token^<178>^MAXRPM^[MAXRPM=!FT_SPEED1]^<2070>Spindle Speed (RPM)
;Token^<2071>^REVS^[#SPEED=!FT_SPEED1]^<2070>Spindle Speed (RPM)

*	Toolchange / Tooling
;Token^<182>^SETTOOLGCODE^[#SETTOOLGCODE=!FT_GCODETSET]^<43>Set Tool Data
;Token^<183>^TURRETNO^[POSITION=!FT_TPOSN]^<184>Turret / Position Number
;Token^<4128>^REPEAT_TURRETNO^[#POSREP=!FT_TPOSNREP]^<184>Turret / Position Number
;Token^<1854>^TURRETNO_ATC^[POSITION=!FT_ATCPOSN]^<184>Turret / Position Number
;Token^<4015>^TURRETNO2_ATC^[POSITION=!FT_ATCPOSN2]^<4016>Turret / Position Number - alternative address
;Token^<3899>^MPOINT_INDEX^[#MULTIPOINT=!FT_MPOINT]^<3900>MultiPoint Index
;Token^<3901>^MPOINT_NAME^[MULTIPOINT]^<3902>MultiPoint Tool ID
;Token^<185>^NEXTTOOL^[#NEXTTOOL=!FT_NEXTPOSN]^<186>Pre-select Next Tool
;Token^<1855>^NEXTTOOL_ATC^[#NEXTTOOL=!FT_NEXTATCPOSN]^<186>Pre-select Next Tool
;Token^<2951>^NEXTDESCR^[$NEXTDESCR]^<2952>Next Tool Description
;Token^<2953>^NEXTCOMMENT^[$NEXTCOM]^<2954>Next Tool Comment
;Token^<4323>^NEXT_GROUP^[$NEXTGROUP]^<4324>Next Group
;Token^<4248>^NEXT_GROUP_NUMBER^[#NEXTGROUPNUM=!FT_TSTORE3]^<4249>Next Group Number
;Token^<4325>^NEXT_GROUP_TEXT^[$NEXTGROUPSTRING]^<4326>Next Group Text
;Token^<4327>^NEXT_ID^[$NEXTID]^<4328>Next ID
;Token^<4329>^NEXT_ID_NUMBER^[#NEXTIDNUMBER=!FT_TSTORE4]^<4330>Next ID Number
;Token^<4331>^NEXT_ID_TEXT^[$NEXTIDSTRING]^<4332>Next ID Text
;Token^<187>^FIRSTTOOL^[#FIRSTTOOL=!FT_TPOSN]^<188>Re-select First Tool
;Token^<189>^LENGTHOFFSET^[#HCODE=!FT_TLONO]^<190>Tool Length Offset

;Token^<4129>^CHANGEOFFSET^[#HCODE=!FT_TLONO3]^<4130>Change Length Offset

;Token^<191>^ZGAUGELENGTH^[#ZGAUGE=!FT_ZGAUGETSET]^<192>Tool Z Gauge Length
;Token^<193>^XGAUGELENGTH^[#XGAUGE=!FT_XGAUGETSET]^<194>Tool X Gauge Length
;Token^<195>^TOOLDIAM^[#TOOLDIA=!FT_DIATSET]^<196>Tool Diameter
;Token^<197>^TOOLRADIUS^[TOOLRAD=!FT_RADTSET]^<198>Tool Radius
;Token^<199>^CSSGCODE^[#CSSGCODE=!FT_GCODE]^<200>CSS / RPM
;Token^<2759>^RPM_MODE^[#CSSGCODE=!FT_GCODE]^<2760>Force RPM Code
;Token^<2761>^IF_CSS^^<2762>Output if in CSS Mode
;Token^<2763>^IF_RPM^^<2764>Output if in RPM Mode
;Token^<2765>^IF_NEXT_DIFFERENT^^<2766>Output if Different Tool
;Token^<2831>^IF_THROUGH_ON^^<2832>Output for Through Tool Coolant
;Token^<2127>^TURRET_SIDE^[#TURRETSIDECODE=!FT_TSCODE]^<2128>Turret Left/Right
;Token^<1856>^TOOLCHANGE^^<1857>Core Tool Change Blocks
;Token^<1858>^TOOLCHANGE-ATC^^<1857>Core Tool Change Blocks
;Token^<1668>^LBRKT^[$BRKT1]^<2129>Left Square Bracket character
;Token^<1670>^RBRKT^[$BRKT2]^<2130>Right Square Bracket character

;Token^<2230>^CORNER^[CORNERRAD=!FT_REALSETUP]^<2231>Tool Corner radius
;Token^<2232>^REACH^[REACH=!FT_REALSETUP]^<2233>Tool Reach

;Token^<2131>^TSTORE_USER1^[TSTOREUSER1=!FT_TSTORE1]^<2132>ToolStore Numeric (User Defined)
;Token^<2133>^TSTORE_USER2^[TSTOREUSER2=!FT_TSTORE2]^<2132>ToolStore Numeric (User Defined)
;Token^<2134>^TSTORE_STRING1^[STRTSTOREUSER1]^<2135>ToolStore String (User Defined)
;Token^<2136>^TSTORE_STRING2^[STRTSTOREUSER2]^<2135>ToolStore String (User Defined)

;Token^<3397>^TOOL_GROUP^[GROUP]^<3398>Tool Group
;Token^<3399>^TOOL_GROUP_TEXT^[GROUPSTRING]^<3400>Tool Group Leading Text
;Token^<3401>^TOOL_GROUP_NUMBER^[GROUPNUMBER=!FT_TSTORE3]^<3402>Tool Group Number
;Token^<3403>^TOOL_ID^[ID]^<3404>Tool ID
;Token^<3405>^TOOL_ID_TEXT^[IDSTRING]^<3406>Tool ID Leading Text
;Token^<3407>^TOOL_ID_NUMBER^[IDNUMBER=!FT_TSTORE4]^<3408>Tool ID Number
;Token^<3733>^HOLDER_TYPE^[HOLDERTYPE]^<3734>Tool Holder Type

;Token^<3409>^CONVERTED_ID^[$IDINTEGREX]^<3410>Integrex Converted ID
;Token^<4180>^REPEAT_ID^[$IDINTEGREX2]^<3410>Integrex Converted ID

;Token^<3735>^TOOL_HAND^[$TOOLHAND]^<3736>Hand of Tool
;Token^<3737>^TOOL_REVERSE^[$TOOLREVERSE]^<3738>Tool Reversal State
;Token^<3739>^TOOL_MODE^[$TOOLMODE]^<3740>Tool Fixed or Driven

* Note that *1 is needed on next line to avoid DEV00002228 (subtract operation)
;Token^<1619>^CSSRAD^[#CSSRAD=!FT_CSSRAD]^<1620>CSS Radial Distance

*	G50/G92 Tool Settings
;Token^<201>^G92X_SET^[#G92XSET=!FT_XMOVE]^<202>Preset X Coordinate
;Token^<203>^G92Z_SET^[#G92ZSET=!FT_ZMOVE]^<204>Preset Z Coordinate
;Token^<205>^G92X_RETURN^[#XMOVE=!FT_XMOVE]^<206>Return to Preset X Coordinate
;Token^<207>^G92Z_RETURN^[#ZMOVE=!FT_ZMOVE]^<208>Return to Preset Z Coordinate


*	Tooling Data for use in NC Program
;Token^<209>^LOOPNUMBER^[#LOOP=!FT_LOOPTSET]^<210>Loop Number
;Token^<211>^GEARMCODE^[#GEARMCODE=!FT_GMCODE]^<212>Gear Range
;Token^<2767>^LOWGEAR^[#GEARMCODE=!FT_GMCODE]^<2768>Startup Gear
;Token^<2769>^HIGHGEAR^[#GEARMCODE=!FT_GMCODE]^<2768>Startup Gear
;Token^<213>^NOSERAD-X^[#TNRX=!FT_TNRXTSET]^<214>Tool Nose Radius X Value
;Token^<215>^NOSERAD-Z^[#TNRZ=!FT_TNRZTSET]^<216>Tool Nose Radius Z Value
;Token^<972>^QUADRANT^[#QUAD=!FT_QUAD]^<973>Tool Tip Quadrant


*	Cutter Radius Compensation
;Token^<217>^CRC REGISTER^[#COMPDCODE=!FT_CRCNO]^<218>TNR Compensation Register
;Token^<4017>^CRC PRESET^[#COMPDCODE=!FT_CRCNO]^<4018>Compensation Register Preset

*	Circular Interpolation
;Token^<219>^XARCEND^[#XMOVE=!FT_XMOVE]^<220>Arc End X Coord
;Token^<221>^YARCEND^[#YMOVE=!FT_YMOVE]^<222>Arc End Y Coord
;Token^<223>^ZARCEND^[#ZMOVE=!FT_ZMOVE]^<224>Arc End Z Coord
;Token^<225>^IVALUE^[#IVALUE=!FT_IMOVE]^<226>Arc I Value
;Token^<227>^JVALUE^[#JVALUE=!FT_JMOVE]^<228>Arc J Value
;Token^<229>^KVALUE^[#KVALUE=!FT_KMOVE]^<230>Arc K Value
;Token^<231>^ARCRADIUS^[#RADIUS=!FT_ARCRAD]^<232>Arc Radius
;Token^<233>^XCENTRE^[XCENTRE=!FT_XMOVE]^<234>Arc Centre X Coord
;Token^<235>^YCENTRE^[YCENTRE=!FT_YMOVE]^<236>Arc Centre Y Coord
;Token^<237>^ZCENTRE^[ZCENTRE=!FT_ZMOVE]^<238>Arc Centre Z Coord
;Token^<2932>^NUMTURNS^[#TURNS=!FT_TURNS]^<2933>Number of Full Turns in Helix
;Token^<4458>^ARCPITCH^[#HELICALPITCH=!FT_AR_PITCH]^<4459>Pitch of Helical Arc

;Token^<1859>^CY_XARCEND^[#XMOVE=!FT_CYXMOVE]^<1860>Arc End X Coord Milling
;Token^<1861>^CY_YARCEND^[#YMOVE=!FT_CYYMOVE]^<1862>Arc End Y Coord Milling
;Token^<1863>^CY_ZARCEND^[#ZMOVE=!FT_CYZMOVE]^<1864>Arc End Z Coord Milling
;Token^<1859>^CY_XARCEND^[#XMOVE=!FT_CYUMOVE]^<1860>Arc End X Coord Milling
;Token^<1861>^CY_YARCEND^[#YMOVE=!FT_CYVMOVE]^<1862>Arc End Y Coord Milling
;Token^<1863>^CY_ZARCEND^[#ZMOVE=!FT_CYWMOVE]^<1864>Arc End Z Coord Milling

*	Hole Cycles
;Token^<239>^CYCLEZFEED^[#FEED=!FT_FCYCLE]^<240>Hole Cycle Z Feedrate
;Token^<241>^CYCLESPEED^[#SPEED=!FT_SPEED]^<177>Spindle Speed

;Token^<1229>^CYCLESPINDIR^[#DIRECTION=!FT_DIRCYCLE]^<4307>Cycle Spindle Direction
;Token^<242>^DWELLTIME^[DWELL=!FT_DWELL]^<243>Dwell Time
;Token^<244>^CYCLEDWELLTIME^[DWELL=!FT_DWCYCLE]^<245>Counterbore Dwell Time
;Token^<246>^RPLANE^[#RPLANE=!FT_RETRACTCYCLE]^<247>R Plane
;Token^<248>^ZCLEAR^[#ZCLEAR=!FT_CLEARCYCLE]^<249>Z Clearance Plane
;Token^<250>^PECKDEPTH^[#DEPTH=!FT_PECKCYCLE]^<251>Pecking Depth
;Token^<2941>^PECKSAFE^[#PECKSAFE=!FT_PECKCYCLE2]^<2942>Peck Safe Distance
;Token^<252>^COMMENT^[USERDEFINEDSTRING]^<253>Operator Message
;Token^<254>^PITCH^[PITCH=!FT_PITCHCYCLE]^<255>Thread / Tap Pitch
;Token^<256>^DEGRESSION^[#DEGR=!FT_DEGCYCLE]^<257>Cycle Degression
;Token^<258>^SPINREVERSE^[#DIRECTION=!FT_MCODE]^<259>Reverse Spindle
;Token^<4288>^CYCLE_ZSAFE^[#ZSAFE=!FT_ZSCYCLE]^<4289>Hole Cycle Z Safe Distance
;Token^<4290>^CYCLE_ZLEVEL^[#ZLEVEL=!FT_ZLCYCLE]^<4291>Hole Cycle Z Level
*
* Turn Cycles
;Token^<260>^XSAFE^[#XSAFE=!FT_XSAFE]^<261>X Safe Distance
;Token^<262>^ZSAFE^[#ZSAFE=!FT_ZSAFE]^<263>Z Safe Distance
;Token^<1037>^ZLEVEL^[#ZLEVEL=!FT_ZLEVEL]^<1038>Z Level
*
*	Datum Shift : Translate
;Token^<1865>^BAXISREF-X^[#XSUB1=!FT_XREF]^<1866>B Axis Reference Coordinate
;Token^<1867>^BAXISREF-Y^[YSUBTURN=!FT_YREF]^<1866>B Axis Reference Coordinate
;Token^<1868>^BAXISREF-Z^[#ZSUB=!FT_ZREF]^<1866>B Axis Reference Coordinate
;Token^<264>^XABSORIGIN^[#XSUB1=!FT_XMOVE]^<265>Absolute X Origin
;Token^<266>^YABSORIGIN^[#YSUB=!FT_YMOVE]^<267>Absolute Y Origin
;Token^<268>^ZABSORIGIN^[#ZSUB=!FT_ZMOVE]^<269>Absolute Z Origin
;Token^<270>^XINC^[#XMOVE=!FT_XMOVE]^<271>Incremental X Origin
;Token^<272>^YINC^[#YMOVE=!FT_YMOVE]^<273>Incremental Y Origin
;Token^<274>^ZINC^[#ZMOVE=!FT_ZMOVE]^<275>Incremental Z Origin
;Token^<734>^G54ZOFFSET^[ZSUB=!FT_ZMOVE]^<735>Machine Datum to Initial CPL (Z)
;Token^<2241>^G55ZOFFSET^[#G55ZDATUM=!FT_ZMOVE]^<735>Machine Datum to Initial CPL (Z)
;Token^<736>^G54XOFFSET^[XSUB=!FT_XMOVE]^<737>Machine Datum to Initial CPL (X)
*
*      New
;Token^<276>^CPLNAME^[GROUPDESCRIPTION]^<277>CPL Name
;Token^<842>^WORKREGISTER^[#COORDNUM=!FT_LOOPTSET]^<1869>Work Datum Register

*
*	Tooling Sheet / Program Information
;Token^<298>^CYCLETIME^[MACHTIME1=!FT_REALSETUP]^<299>Cycle Time (including toolchange)
;Token^<4292>^CYCLETIME3^[MACHTIME3=!FT_REALSETUP]^<4293>Cycle Time (Turret3) (including toolchange)
;Token^<893>^CYCLETIME2^[MACHTIME2=!FT_REALSETUP]^<894>Cycle Time (Turret2) (including toolchange)
;Token^<4294>^CYCLETIME4^[MACHTIME4=!FT_REALSETUP]^<4295>Cycle Time (Turret4) (including toolchange)
;Token^<895>^IDLE1^[IDLE1=!FT_REALSETUP]^<896>Idle Time (Turret1)
;Token^<4296>^IDLE3^[IDLE3=!FT_REALSETUP]^<4297>Idle Time (Turret3)
;Token^<897>^IDLE2^[IDLE2=!FT_REALSETUP]^<898>Idle Time (Turret2)
;Token^<4298>^IDLE4^[IDLE4=!FT_REALSETUP]^<4299>Idle Time (Turret4)
*
;Token^<3693>^TOOL-ANGLE^[INCLUDEDANGLE=!FT_REALSETUP]^<3694>Tool Angle
;Token^<278>^HDR-TURRETNO^[POSITION=!FT_INTSETUP]^<184>Turret / Position Number
;Token^<1870>^LIST-TURRETNO^[POSITION=!FT_LIST_TUR]^<1871>Tool List Turret Number
;Token^<279>^TOOLDESCR^[$TOOLDESCRIPTION]^<280>Tool Description
;Token^<281>^HDR-TOOLDIAM^[#TOOLDIA=!FT_REALSETUP]^<196>Tool Diameter
;Token^<282>^TOOLTYPE^[$TYPE=8]^<283>Tool Type
;Token^<284>^HDR-TOOLZGAUGE^[TOOLZSET=!FT_REALSETUP]^<285>Tool Zgauge
;Token^<286>^HDR-TOOLXGAUGE^[TOOLXSET=!FT_REALSETUP]^<287>Tool Xgauge
;Token^<288>^HDR-NOSERAD^[TOOLRAD=!FT_REALSETUP]^<289>Tool Nose Radius
;Token^<3955>^HDR-LENGTHOFFSET^[#HCODE=!FT_INTSETUP]^<190>Tool Length Offset
;Token^<1792>^FLUTE^[FLUTELENGTH=!FT_REALSETUP]^<1793>Tool Flute Length
;Token^<290>^TOOLUNITS^[$UNIT]^<291>Tool Units
;Token^<292>^PROGID^[#PROGID=!FT_PROGID]^<3741>Ask Program ID
;Token^<294>^SEQID^[$SEQID=23]^<295>Machining Sequence
;Token^<296>^MACHINENAME^[MACHINENAME]^<297>Machine Description
;Token^<300>^DATE^[DATE]^<301>Program creation Date
;Token^<2105>^UKDATE^[UKDATE]^<2106>Program creation Date (UK Format)
;Token^<2107>^DAY^[DAY=!FT_INTSETUP]^<2108>Program creation Day
;Token^<2109>^MONTH^[MONTH=!FT_INTSETUP]^<2110>Program creation Month
;Token^<2111>^YEAR^[YEAR=!FT_INTSETUP]^<2112>Program creation Year
;Token^<302>^TIME^[TIME]^<303>Program creation Time
;Token^<304>^PROGVERSION^[$PROGVER]^<3742>Ask Program Version No.
;Token^<306>^PROGRAMMER^[$ID]^<3743>Ask Programmer's Name
;Token^<308>^MANREADABLE^MANREADABLE=[$MANREADABLE]^<3744>Enter Manreadable (Punch Tape)
;Token^<310>^LEADER^LEADER=[#LEADER=23]^<311>Leader (Punch Tape)
;Token^<312>^PARTNAME^[PARTNAME]^<313>Input Part Name
;Token^<314>^SEQUENCENAME^[SEQUENCENAME]^<315>M/C Sequence Name
*	Subroutines
;Token^<316>^SUBCALL^[#SUBSTARTMCODE=!FT_MCODE]^<317>Subroutine Call M-Code
;Token^<318>^SUBNO^[#SUBROUTINE=!FT_SUBID]^<319>Subroutine Program Number
;Token^<320>^SUBNOCALL^[#SUBROUTINE=!FT_SUBCALL]^<321>Call Subroutine Program Number
;Token^<322>^SUBEND^[#SUBENDMCODE=!FT_MCODE]^<323>Subroutine End M-Code
*	By block number
;Token^<324>^N-SUBSTART^[STARTSUB=!FT_SSNUM]^<325>Block Number Start
;Token^<326>^N-SUBEND^[ENDSUB=!FT_SENUM]^<327>Block Number End
*	Position : Before, after, in-line with main NC Program
;Token^<328>^SUBROUTINES^^<329>Subroutines position

*	Turning Cycles
;Token^<3506>^CONSTOFFSET^[OFFSET=!FT_OFFC]^<3507>Constant Parallel Offset
;Token^<332>^OFFSETX^[#OFFSETX=!FT_OFFX]^<333>Stock Offset in X (Actual)
;Token^<334>^OFFSETZ^[#OFFSETZ=!FT_OFFZ]^<335>Stock Offset in Z
;Token^<336>^OFFSETXDIAM^[#OFFSETXDIAM=!FT_OFFXDIA]^<337>Stock Offset in X (Diameter)
;Token^<338>^DEPTH^[#DEPTH=!FT_DOCTFCYC]^<738>Turn/Face Cycle Depth of Cut
;Token^<739>^DEPTH (TURN)^[#DEPTHTURN=!FT_DOCTCYC]^<339>Turning Cycle Depth of Cut
;Token^<740>^DEPTH (FACE)^[#DEPTHFACE=!FT_DOCFCYC]^<741>Facing Cycle Depth of Cut
;Token^<4131>^PROFILECUTS^[#NUMCUTS=!FT_NPASSPROF]^<4132>Number of Profiling Cuts

;Token^<340>^CHIPBREAK^[#CHIP=!FT_CHPTCYC]^<1762>Turn/Face Cycle Chipbreak Depth
;Token^<1395>^CHIPBREAK (FACE)^[#CHIPF=!FT_CHPFCYC]^<1396>Facing Cycle Chipbreak Depth
;Token^<1397>^CHIPBREAK (TURN)^[#CHIPT=!FT_CHPTCYC]^<341>Turning Cycle Chipbreak Depth

;Token^<342>^XCYCLESTART^[#XCYCLESTART=!FT_XSTART]^<343>Cycle Start X Co-ordinate
;Token^<342>^XCYCLESTART^[#XCYCLESTART=!FT_XSTART2]^<343>Cycle Start X Co-ordinate
;Token^<4490>^YCYCLESTART^[#YCYCLESTART=!FT_YSTART]^<4491>Cycle Start Y Co-ordinate
;Token^<344>^ZCYCLESTART^[#ZCYCLESTART=!FT_ZSTART]^<345>Cycle Start Z Co-ordinate
;Token^<344>^ZCYCLESTART^[#ZCYCLESTART=!FT_ZSTART2]^<345>Cycle Start Z Co-ordinate
;Token^<1210>^ENDTCYC^[#ZCYCLEEND=!FT_ZEND]^<1211>Cycle End Z Co-ordinate
;Token^<1212>^ENDFCYC^[#XCYCLEEND=!FT_XEND]^<1213>Cycle End X Co-ordinate
;Token^<346>^RCOORD^[#XMOVE=!FT_RMOVE]^<347>Radius (Current X Coordinate)

*	Threading Cycles
;Token^<349>^IPITCH^[#IPITCH=!FT_ITAPER]^<350>I Pitch
;Token^<351>^KPITCH^[#KPITCH=!FT_KTAPER]^<352>K Pitch
;Token^<353>^THRDTOTDEPTH^[#TOTALDEPTH=!FT_TOTDOCTHRD]^<354>Total Depth of Thread
;Token^<3745>^THRDTOTDEPTHDIAM^[#TOTALDEPTH=!FT_TOTDOCTHRD]^<3746>Total Depth of Thread (Diameter)
;Token^<355>^THRDDEPTH^[DEPTH=!FT_STARTDEPTH]^<356>1st Depth of Cut
;Token^<357>^THRDANGLE^[#THRDANGLE=!FT_ANGTHRD]^<358>Thread Included Angle
;Token^<359>^SPRINGCUTS^[FPASS=!FT_SPRINGTHRD]^<360>Number of Spring Cuts
;Token^<361>^STARTS^[FIELD1=!FT_STARTSTHRD]^<362>Number of Starts
;Token^<363>^THRDNUMCUTS^[#NUMCUTS=!FT_NPASSTHRD]^<364>Number of Threading Passes
;Token^<365>^MINDEPTH^[FIELD3=!FT_MINDOCTHRD]^<974>MIN Depth of Cut
;Token^<367>^CHASEINANG^[#CIANG=!FT_CHASEANGTHRD]^<368>Chase In Angle
;Token^<369>^ITAPER^[#ITEMP=!FT_ITAPER]^<370>I Taper
;Token^<371>^KTAPER^[#KTEMP=!FT_KTAPER]^<372>K Taper
;Token^<2137>^PULLOUT^[USERVAR8=!FT_PSTYLE]^<2138>Pull Out Distance
;Token^<742>^START_DEPTH^[#DEPTH2=!FT_STARTDEPTH]^<743>Start Depth of Cut
;Token^<744>^FINAL_DEPTH^[#DEPTH3=!FT_FINALDEPTH]^<745>Final Depth of Cut
;Token^<746>^SPRING_DEPTH^[#DEPTH4=!FT_SPRINGDEPTH]^<747>Spring Depth of Cut
;Token^<3747>^START_DEPTHDIAM^[#DEPTH2=!FT_STARTDEPTH]^<3748>Start Depth of Cut (Diameter)
;Token^<3749>^FINAL_DEPTHDIAM^[#DEPTH3=!FT_FINALDEPTH]^<3750>Final Depth of Cut (Diameter)
;Token^<3751>^SPRING_DEPTHDIAM^[#DEPTH4=!FT_SPRINGDEPTH]^<3752>Spring Depth of Cut (Diameter)
;Token^<1280>^XRETRACT^[#XRETRACT=!FT_XRETRACT]^<1281>Incremental Retract X Distance

*	Rapid to Home / Toolchange
;Token^<375>^U0^[#UZERO=!FT_UZERO]^<376>X Incremental Zero move
;Token^<1719>^V0^[#VZERO=!FT_VZERO]^<1720>Y Incremental Zero move
;Token^<377>^W0^[#WZERO=!FT_WZERO]^<378>Z Incremental Zero move
* NB XYZ zero tokens use same variables with XYZ addresses
;Token^<3265>^X0^[#UZERO=!FT_XMOVE]^<376>X Incremental Zero move
;Token^<3266>^Y0^[#VZERO=!FT_YMOVE]^<1720>Y Incremental Zero move
;Token^<3267>^Z0^[#WZERO=!FT_ZMOVE]^<378>Z Incremental Zero move

*	Ge style G1 X.. Z.. F0 rapid
;Token^<379>^F0^[#FEED=!FT_FEED]^<380>Rapid F0 "Feedrate"

*	C & Y Axis (Milling)
;Token^<1872>^CMOVE-MAIN^[#CMOVE1=!FT_CMOVE1]^<1873>C Axis Move Main Spindle
;Token^<1874>^CMOVE-SUB^[#CMOVE2=!FT_CMOVE2]^<1875>C Axis Move Sub Spindle
;Token^<2139>^POLAR_Y^[#POLARMOVE=!FT_CMOVE3]^<2140>Pseudo-Polar Y Coordinate
;Token^<4250>^POLAR_Y_SUB^[#POLARMOVE2=!FT_CMOVE4]^<2140>Pseudo-Polar Y Coordinate

;Token^<750>^CY_POLARGCODE^[#POLARGCODE=!FT_CYGCODE]^<751>C/Y Axis Polar Code

;Token^<752>^CY_RAPIDGCODE^[#GCODE=!FT_CYGCODE]^<753>C/Y Axis Rapid Code
;Token^<754>^CY_FEEDGCODE^[#GCODE=!FT_CYGCODE]^<755>C/Y Axis Feed Code
;Token^<756>^CY_CLWGCODE^[#GCODE=!FT_CYGCODE]^<757>C/Y Axis CLW Code
;Token^<758>^CY_CCLWGCODE^[#GCODE=!FT_CYGCODE]^<759>C/Y Axis CCLW Code

;Token^<760>^CY_DRILLGCODE^[#DRGCODE=!FT_CYGCODE]^<761>C/Y Axis Drill Cycle
;Token^<762>^CY_SPOTGCODE^[#DRGCODE=!FT_CYGCODE]^<763>C/Y Axis Spot Face Cycle
;Token^<764>^CY_PECKGCODE^[#DRGCODE=!FT_CYGCODE]^<765>C/Y Axis Peck Drill Cycle
;Token^<766>^CY_TAPGCODE^[#DRGCODE=!FT_CYGCODE]^<767>C/Y Axis Tapping Cycle
;Token^<768>^CY_REAMGCODE^[#DRGCODE=!FT_CYGCODE]^<769>C/Y Axis Ream / Bore Cycle
;Token^<770>^CY_BOREGCODE^[#DRGCODE=!FT_CYGCODE]^<771>C/Y Axis Bore Cycle
;Token^<772>^CY_ENDCYCLEGCODE^[#DRGCODE=!FT_CYGCODE]^<773>C/Y Axis End Canned Cycle
;Token^<774>^CY_CHIPBREAKGCODE^[#DRGCODE=!FT_CYGCODE]^<775>C/Y Axis Chipbreak Drill Cycle
;Token^<980>^CY_CYCLEDWELLTIME^[DWELL=!FT_DWCYCLECY]^<2198>C/Y Cycle Dwell Time
;Token^<4308>^CY_CYCLESPINDIR^[#DIRECTION=!FT_DIRCYCLECY]^<4307>Cycle Spindle Direction

;Token^<776>^CY_RETRACTGCODE^[#RETRACTGCODE=!FT_CYGCODE]^<777>C/Y Axis Cycle Retract Code
;Token^<539>^ZDEPTH^[#ZMOVE=!FT_ZMOVE]^<540>Z Depth
;Token^<542>^BORESTANDOFF^[#BOREOFFSET=!FT_OFFCYCLE]^<543>Bore Stand Off Distance

;Token^<850>^WRAP HEIGHT^[#WRAPHEIGHT=!FT_WRAPHEIGHT]^<851>Wrap Height (Radius/Diameter)
;Token^<2943>^CYL_HEIGHT^[#CYLX=!FT_CYLX]^<2944>Cylindrical X Coordinate (Radius/Diameter)
;Token^<2945>^CYL_GCODE^[#GCODE=!FT_CYLGCODE]^<2946>Cylindrical Code

* Additional tokens for Siemens 3T  7/10/98
;Token^<1214>^CYCLEZMOVE^[#ZMOVE=!FT_CYCLEZMOVE]^<171>Z Move
* For S840 July 2012
;Token^<4251>^TURNCYCLEDWELL^[DWELL=!FT_DWCYCLE2]^<4252>Turn Cycle Dwell Time
* CYCLEFEED also used in INDEXG200
;Token^<2632>^CYCLEFEED^[#FEED=!FT_RTFEED]^<4253>Turn Cycle Feedrate
;Token^<4254>^VARI^[#VARI=!FT_VARI]^<4255>Machining Conditions

* Thread Mill Canned Cycle
;Token^<3847>^T-MILL-HAND^[$THRDHAND]^<3848>Hand of Thread Description
;Token^<2339>^T-MILL-TYPE^[#THRDINOUT=!FT_TM_TYPE]^<2340>Internal External Thread Cycle
;Token^<2341>^T-MILL-DIA^[#THREADDIA=!FT_TM_DIA]^<2342>Thread Mill Nominal Diameter
;Token^<3849>^T-MILL-MINOR^[#THREADMIN=!FT_TM_DIA]^<3850>Thread Mill Minor Diameter
;Token^<2343>^T-MILL-LEAD^[#THRDLEAD=!FT_TM_LEAD]^<2344>Thread Mill Lead
;Token^<3851>^T-MILL-PITCH^[#THRDPITCH=!FT_TM_PITCH]^<3852>Thread Mill Pitch
;Token^<3853>^T-MILL-STARTS^[STARTS=!FT_TM_START]^<3854>Thread Mill Number of Starts
;Token^<4133>^T-MILL-START_ANGLE^[STARTANGLE=!FT_TM_START]^<4134>Thread Mill Start Angle
;Token^<4135>^T-MILL-TAPER^[INCLUDEDANGLE=!FT_TM_START]^<4136>Thread Mill Taper Angle
;Token^<2347>^T-MILL-APPROACH^[#THRDPOSFEED=!FT_TM_APP]^<2348>Thread Mill Approach Feed
;Token^<2349>^T-MILL-MODE^[#THRDMILL=!FT_TM_MODE]^<2350>Thread Mill Climb or Upcut
;Token^<3855>^T-MILL-DIR^[#THRDARCOUT=!FT_TM_DIR]^<3856>Thread Mill Direction
;Token^<3903>^T-MILL-DEPTH^[#THRDEPTH=!FT_TM_DEP]^<3904>Thread Mill Cycle Depth
* Added for Moriseiki canned cycle
;Token^<3956>^T-MILL-DIA2^[#THREADDIA2=!FT_TM_DIA2]^<3957>Thread Mill Diameter at Depth
;Token^<3958>^T-MILL-DIST^[#THRDDIST=!FT_TM_DIST]^<3959>Thread Mill Approach Distance
;Token^<2353>^T-MILL-LEVEL^[#THRDLEVEL=!FT_TM_LEV]^<2354>Thread Mill Level
;Token^<3960>^T-MILL-HEIGHT^[#THRDHEIGHT=!FT_TM_HT]^<3961>Thread Mill Height of Thread
* Added for Siemens canned cycle
;Token^<3857>^T-MILL-X^[#XMOVE=!FT_TM_X]^<3858>Thread Mill X Centre
;Token^<3859>^T-MILL-Y^[#YMOVE=!FT_TM_Y]^<3860>Thread Mill Y Centre
;Token^<2355>^T-MILL-CLEAR^[#THRDCLEAR=!FT_TM_CLEAR]^<2356>Thread Mill Z Clear

* probably not needed
* Token^T-MILL-RETR^[#THRDPLUNGE=!FT_TM_RETR]^Thread Mill Retract
* Token^T-MILL-CLEAR^[#TMPCLEAR=!FT_TM_CLEAR]^Thread Mill Z Clear^%CALL=PT_ZCLEAR
* Token^T-MILL-FEED^[#THRDFEED=!FT_TM_FEED]^Thread Mill Cutting Feed

***********************************************************
* C Axis Tokens
***********************************************************

;Token^<975>^CY_ZDEPTH^[#ZMOVE=!FT_ZCYCLECY]^<976>Hole Cycle Z Depth
* Siemens uses CY_LEVEL, all others use CY_ZLEVEL. Different Format refs
;Token^<2947>^CY_LEVEL^[#ZLEVEL=!FT_ZCYCLECY]^<2948>Hole Cycle Level
;Token^<4256>^CY_ZLEVEL^[#ZLEVEL=!FT_LCYCLECY]^<2948>Hole Cycle Level
*
;Token^<4257>^CY_ZSAFE^[#ZSAFE=!FT_CYZSAFE]^<4258>Hole Cycle Safe Distance
;Token^<977>^CY_CYCLEZFEED^[#FEED=!FT_FCYCLECY]^<240>Hole Cycle Z Feedrate
;Token^<978>^CY_CYCLESPEED^[#SPEED=!FT_SCYCLECY]^<177>Spindle Speed
;Token^<981>^CY_RPLANE^[#RPLANE=!FT_RETRACTCYCLECY]^<247>R Plane
;Token^<982>^CY_ZCLEAR^[#ZCLEAR=!FT_CLEARCYCLECY]^<249>Z Clearance Plane
;Token^<2199>^CY_XCLEAR^[#XCLEAR=!FT_XMOVE]^<2200>X Clearance Position
;Token^<983>^CY_PECKDEPTH^[#DEPTH=!FT_PECKCYCLECY]^<251>Pecking Depth
;Token^<984>^CY_PITCH^[PITCH=!FT_PITCHCYCLECY]^<255>Thread / Tap Pitch
;Token^<985>^CY_DEGRESSION^[#DEGR=!FT_DEGCYCLECY]^<257>Cycle Degression
;Token^<987>^CY_SPINDIR^[#DIRECTION=!FT_MCODE]^<127>Spindle Direction
;Token^<1876>^C_MOVE^^<1877>C Move Block
;Token^<2833>^SPINDLE_CLAMP^^<2915>Spindle Clamping

***********************************************************
* Job Record Tokens
***********************************************************
;Token^<1637>^JM-DESC^[JOBDESC]^<1638>Job Manager Description
;Token^<1639>^JM-COM^[JOBCOM]^<1640>Job Manager Comment
;Token^<1641>^JM-FAM^[JOBFAM]^<1642>Job Manager Family
;Token^<1643>^JM-MACH^[JOBMACH]^<1644>Job Manager Machine
;Token^<1645>^JM-CUST^[JOBCUST]^<1646>Job Manager Customer
;Token^<1647>^JM-PROG^[JOBPROG]^<1648>Job Manager Programmer
;Token^<1649>^JM-MATL^[JOBMATL]^<1650>Job Manager Material
;Token^<1651>^JM-REV^[JOBREV]^<1652>Job Manager Revision

***********************************************************
* Setup Tokens
***********************************************************
;Token^<1878>^PARTLENGTH^[PARTLENGTH=!FT_REALSETUP]^<1879>Part Length
;Token^<1880>^MAINPARTSTICKOUT^[MAINPARTSTICKOUT=!FT_REALSETUP]^<1881>Stick out amount of part when loaded in the Main Spindle
;Token^<1882>^SUBPARTSTICKOUT^[SUBPARTSTICKOUT=!FT_REALSETUP]^<1883>Stick out amount of part when transferred to the Sub Spindle
;Token^<1884>^MAINDATUMTOCHUCKFACE^[MAINDATUMTOCHUCKFACE=!FT_REALSETUP]^<1885>Machine Datum to Chuck Face on Main Spindle
;Token^<1886>^SUBDATUMTOCHUCKFACE^[SUBDATUMTOCHUCKFACE=!FT_REALSETUP]^<1887>Sub Spindle Datum to Chuck Face on Main Spindle
;Token^<2072>^MAINDATUMTOSUBCHUCK^[#CHUCKPOS=!FT_REALSETUP]^<2073>Sub Spindle Chuck Face Position
;Token^<1888>^MCSUBDATUMX^[MCSUBDATUMX=!FT_REALSETUP]^<1889>Machine to Sub Spindle Datum X distance
;Token^<1890>^MCSUBDATUMY^[MCSUBDATUMY=!FT_REALSETUP]^<1891>Machine to Sub Spindle Datum Y distance
;Token^<1892>^MCSUBDATUMZ^[MCSUBDATUMZ=!FT_REALSETUP]^<1893>Machine to Sub Spindle Datum Z distance
;Token^<1894>^DOCKGRIPZ^[DOCKGRIPZ=!FT_REALSETUP]^<1895>Grip Position for Sub Spindle transfer (relative to Main Spindle CPL)
;Token^<1896>^MAINSAFEZ^[MAINSAFEZ=!FT_REALSETUP]^<1897>Z Extents of safe cutting on Main Spindle.
;Token^<1898>^SUBSAFEZ^[SUBSAFEZ=!FT_REALSETUP]^<1899>Z Extents of safe cutting on Sub Spindle
;Token^<2141>^TRANS_SHIFT^[#TRANSFERSHIFT=!FT_REALSETUP]^<2142>Distance moved on part transfer
;Token^<2143>^TRANS_POSITION^[#TRANSFERPOS=!FT_REALSETUP]^<2144>Grip Position for Sub Spindle Transfer (relative to Machine Datum)

* DEV00022711 Original line corrupted by Wizard when writing cxt file.
* Token^SUBJAWS-Z0^[#SUBJAWMOVE=!FT_REALSETUP]^Sub Jaws Distance to Main Z0^#SUBJAWMOVE=(#ADVANCE+SUBDATUMTOCHUCKFACE)-DOCKGRIPZ
* Token^SUBJAWS-Z0^[#SUBJAWMOVE=!FT_REALSETUP]^Sub Jaws Distance to Main Z0^#SUBJAWMOVE=SUBDATUMTOCHUCKFACE+#ADVANCE:#SUBJAWMOVE=#SUBJAWMOVE-DOCKGRIPZ
;Token^<3268>^SUBJAWS-Z0^[#SUBJAWMOVE=!FT_REALSETUP]^<3269>Sub Jaws Distance to Main Z0

;Token^<1900>^CALL_TOOLING^^<1901>Tooling Set Up Loop
;Token^<1902>^CALL_DATUMS^^<1903>Work Datum Loop
;Token^<3411>^CALL_SUBSPIN_SET^^<3412>Sub Spindle Variable Setting

;Token^<3523>^MAIN_CHUCK_NAME^[CHUCKMAIN]^<3524>Name of Main Spindle Chuck
;Token^<3525>^SUB_CHUCK_NAME^[CHUCKSUB]^<3526>Name of Sub Spindle Chuck

***********************************************************
* User tokens for ;CODE commands
***********************************************************
;Token^<1497>^USER-STRING^[$USER]^<1498>User String Token
;Token^<1597>^USER-STRING-1^[$USER1]^<1498>User String Token
;Token^<1598>^USER-STRING-2^[$USER2]^<1498>User String Token
;Token^<1599>^USER-STRING-3^[$USER3]^<1498>User String Token
;Token^<1600>^USER-STRING-4^[$USER4]^<1498>User String Token
;Token^<1601>^USER-STRING-5^[$USER5]^<1498>User String Token
;Token^<1499>^USER-1^[#USER1=!FT_USER-1]^<1602>User Numeric Token
;Token^<1501>^USER-2^[#USER2=!FT_USER-2]^<1602>User Numeric Token
;Token^<1503>^USER-3^[#USER3=!FT_USER-3]^<1602>User Numeric Token
;Token^<1603>^USER-4^[#USER4=!FT_USER-4]^<1602>User Numeric Token
;Token^<1604>^USER-5^[#USER5=!FT_USER-5]^<1602>User Numeric Token
;Token^<1605>^USER-6^[#USER6=!FT_USER-6]^<1602>User Numeric Token
;Token^<1606>^USER-7^[#USER7=!FT_USER-7]^<1602>User Numeric Token
;Token^<1607>^USER-8^[#USER8=!FT_USER-8]^<1602>User Numeric Token
;Token^<1608>^USER-9^[#USER9=!FT_USER-9]^<1602>User Numeric Token
;Token^<1609>^USER-10^[#USER10=!FT_USER-10]^<1602>User Numeric Token
;Token^<2492>^USER-11^[#USER11=!FT_USER-11]^<1602>User Numeric Token
;Token^<2493>^USER-12^[#USER12=!FT_USER-12]^<1602>User Numeric Token
;Token^<2494>^USER-13^[#USER13=!FT_USER-13]^<1602>User Numeric Token
;Token^<2495>^USER-14^[#USER14=!FT_USER-14]^<1602>User Numeric Token
;Token^<2496>^USER-15^[#USER15=!FT_USER-15]^<1602>User Numeric Token
;Token^<2497>^USER-16^[#USER16=!FT_USER-16]^<1602>User Numeric Token
;Token^<2498>^USER-17^[#USER17=!FT_USER-17]^<1602>User Numeric Token
;Token^<2499>^USER-18^[#USER18=!FT_USER-18]^<1602>User Numeric Token
;Token^<2500>^USER-19^[#USER19=!FT_USER-19]^<1602>User Numeric Token
;Token^<2501>^USER-20^[#USER20=!FT_USER-20]^<1602>User Numeric Token

***********************************************************
*	M-Functions (Used to create default Code Constructor)
***********************************************************
;Token^<381>^MCODE^[$MCODE]^<382>M-Code from list
;Define User Macro^$MCODE
;Use Tokens^<146>DELETE^<148>BLKNUM^<381>MCODE
;Use Tokens^<1497>USER-STRING^<1597>USER-STRING-1^<1598>USER-STRING-2^<1599>USER-STRING-3^<1600>USER-STRING-4^<1601>USER-STRING-5
;Use Tokens^<1499>USER-1^<1501>USER-2^<1503>USER-3^<1603>USER-4^<1604>USER-5^<1605>USER-6^<1606>USER-7^<1607>USER-8^<1608>USER-9^<1609>USER-10
;Use Tokens^<2492>USER-11^<2493>USER-12^<2494>USER-13^<2495>USER-14^<2496>USER-15^<2497>USER-16^<2498>USER-17^<2499>USER-18^<2500>USER-19^<2501>USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[MCODE]

*
************************************************************
*					4 Axis Turning
************************************************************
*
;Token^<885>^TURRETNAME^[$TURRETNAME]^<886>Turret Name
;Token^<2145>^TURRETCODE^[$TURRETCODE]^<2146>Turret Code


;Token^<653>^UARCEND^[#UMOVE=!FT_UMOVE]^<654>Arc End U Coord
;Token^<887>^WARCEND^[#WMOVE=!FT_WMOVE]^<888>Arc End W Coord

;Token^<889>^SYNCNUM^[#SYNC=!FT_SYNCNUM]^<890>Synchronisation Number
;Token^<1771>^SYNCNUM-L^[#SYNCL=!FT_SYNCNUM]^<1772>Synchronisation Number - Lower Turret
*  Token^TURRETGCODE^[#TURRETGCODE=!FT_GTURRET]^Select Turret G-Code

* Multi-turret synch selection
;Token^<4259>^SYNC_UPPER1^[$FLAGTUR1]^<4260>Synch Flag First Upper
;Token^<4261>^SYNC_UPPER2^[$FLAGTUR3]^<4262>Synch Flag Second Upper
;Token^<4263>^SYNC_LOWER1^[$FLAGTUR2]^<4264>Synch Flag First Lower
;Token^<4265>^SYNC_LOWER2^[$FLAGTUR4]^<4266>Synch Flag Second Lower

* For Okuma only
;Token^<2242>^CONTROL-GCODE^[#CONTROL=!FT_GCODE]^<2243>Controlling Turret Code
;Token^<4019>^NEXTSPEED^[NEXTSPEED=!FT_CYNSPEED]^<4020>Next Spindle Speed
;Token^<4492>^CY_SPEED^[#SPEED=!FT_CYSPEED]^<177>Spindle Speed

************************************************************
* Tokens for Bar Feed
************************************************************
;Token^<1904>^BFSTARTX^[#BARX=!FT_XMOVE]^<1905>Bar Feed X Start
;Token^<1282>^BFSTARTZ^[#BARZSTART=!FT_ZMOVE]^<1283>Bar Feed Z Start
;Token^<1284>^BFENDZ^[#BARZEND=!FT_ZMOVE]^<1285>Bar Feed Z End
;Token^<3143>^BPZOFFSET^[#BPZOFFSET=!FT_BPOFFSET]^<3144>Bar Pull Datum Shift Z
************************************************************
*B Axis Tokens
************************************************************
;Token^<1906>^BMOVE^[#BMOVE=!FT_ADV-B]^<1907>B Axis Move
;Token^<4021>^BMOVE2^[#BMOVE=!FT_ADV-B2]^<4022>B Axis Move -alternative address
;Token^<4493>^BMOVE_TC^[#TCANGLE=!FT_ADV-B]^<4494>Tool Change B Angle
;Token^<1908>^SPINBRAKE^[#BRAKE=!FT_MCODE]^<1909>Spindle Brake
;Token^<3188>^CYCSPINBRAKE^[#CYCSPINBRAKE=!FT_MCODE]^<3189>Spindle Brake on Canned Cycle
;Token^<2074>^MILLBRAKE^[#MBRAKE=!FT_MCODE]^<2075>Milling Spindle Brake
;Token^<2076>^SPINBRAKE-ON^[#BRAKE=!FT_MCODE]^<1909>Spindle Brake
;Token^<2077>^SPINBRAKE-OFF^[#BRAKE=!FT_MCODE]^<1909>Spindle Brake
;Token^<2078>^BAXBRAKE-ON^[#BAXBRAKE=!FT_MCODE]^<2079>B Axis Brake On
;Token^<2080>^BAXBRAKE-OFF^[#BAXBRAKE=!FT_MCODE]^<2081>B Axis Brake OF
;Token^<2770>^AUTO_BRAKE^[#AUTOBRAKE=!FT_MCODE]^<2771>Auto Spindle Brake
;Token^<1912>^FACEANGLE^[#FACEANGLE=!FT_FACEANG]^<1913>CPL Face Angle
************************************************************
*B Axis Index Turret (Nakamurra)
************************************************************
;Token^<4023>^TURRETSIDE^[#TSIDE=!FT_TSIDE]^<4024>Turret Side Code
;Token^<4025>^TOOLCONVERT^[#TOOLCONVERT=!FT_TCONV]^<4026>Tool Offset Conversion Angle
;Token^<4027>^FACEANGLE2^[#FACEANGLE=!FT_FACEANG2]^<4028>CPL Face Angle - alternative address
;Token^<4029>^WORKANGLE^[#WORKANGLE=!FT_WORKANG]^<4030>Workpiece Angle
************************************************************
* Spin-select indicates which spindle is active with codes for driven and static tools
;Token^<1910>^SPIN-SELECT^[#SPINSELECT=!FT_MCODE]^<3962>Spindle Select M Code
;Token^<3963>^SPIN-SELECT-G^[#SPINSELECT=!FT_GCODE]^<3964>Spindle Select G Code
;Token^<1914>^C_RELEASE^[#CSTAT=!FT_MCODE]^<1915>C-Axes Independant
;Token^<1916>^C_JOINT^[#CSTAT=!FT_MCODE]^<1917>C-Axes Synchronised
;Token^<2082>^C_AUTO_STAT^[#CSTAT=!FT_MCODE]^<2083>C-Axes Status (Auto)
* DRIVEN indicates whether the tool is driven or static with codes available for sub and main spindles
;Token^<1918>^DRIVEN^[#DRIVENTOOL=!FT_ADV-D]^<1786>Tooling Driven/Static
;Token^<2084>^MILL_MODE^[#MILLMODE=!FT_GCODE]^<2085>Mill Mode Planar/Rotary

* Misc control functions G or M
;Token^<1919>^AIRBLOW1-ON^[#AIRBLOW1=!FT_MCODE]^<1920>Air Blow On, Spindle1
;Token^<1921>^AIRBLOW1-OFF^[#AIRBLOW1=!FT_MCODE]^<1922>Air Blow Off, Spindle1
;Token^<1923>^AIRBLOW2-ON^[#AIRBLOW2=!FT_MCODE]^<1924>Air Blow On, Spindle2
;Token^<1925>^AIRBLOW2-OFF^[#AIRBLOW2=!FT_MCODE]^<1926>Air Blow Off, Spindle2
;Token^<1927>^PROGEND^[#PROGEND=!FT_MCODE]^<1928>Program End Code
;Token^<1929>^DOOR-OPEN^[#DOOR1=!FT_MCODE]^<1930>Door Open
;Token^<1931>^DOOR-CLOSE^[#DOOR2=!FT_MCODE]^<1932>Door Close
;Token^<1933>^SUBCLAMP^[#ACLAMP=!FT_MCODE]^<1934>Sub Spindle Clamp
;Token^<1935>^SUBRELEASE^[#ACLAMP=!FT_MCODE]^<1936>Sub Spindle Release Clamp
;Token^<1937>^SUBSPINGCODE^[#SUBSPING=!FT_GCODE]^<1938>Sub Spindle Movement Code
*
* Spindleid indicates which work spindle is being programmed
;Token^<1939>^SPINDLEID^[#SPINID=!FT_SPINID]^<1787>Spindle ID Code
;Token^<2086>^TOOLORIENT^[#ORIENTATION=!FT_MCODE]^<1787>Spindle ID Code
;Token^<1940>^SPINSYNCH^[#SPINSYNCH=!FT_SPINSYNCH]^<1788>Spindle Synch Code
;Token^<1941>^TCHANGE^[#TCHANGE=!FT_TCHANGE]^<1789>Tool Change Code
;Token^<1942>^CANCELTLO^[#CANCELCODE=!FT_CANCELTLO]^<1790>Cancel Tool Length Offset
*
;Token^<1943>^CONVERT^[#CCONVERT=!FT_CCONVERT]^<1944>Coordinate conversion ON
;Token^<1945>^NO-CONVERT^[#CCONVERT=!FT_CCONVERT]^<1946>Coordinate conversion OFF

************************************************************
* Sub Spindle Movement
************************************************************
;Token^<1947>^X-APPROACH^[#XAPPROACH=!FT_XMOVE]^<1948>sub spindle X Approach
;Token^<1949>^Z-APPROACH^[#ZAPPROACH=!FT_ADV-A]^<1950>sub spindle Z Approach
;Token^<3270>^SET-Z-APPROACH^[#ZAPPROACH=!FT_REALSETUP]^<3271>Z Approach Value
;Token^<4031>^SET-Z-APP-MAIN^[#ZAPPMAIN=!FT_REALSETUP]^<4032>Z Approach Value (relative to Main Spindle CPL)
;Token^<1951>^GRIP-Z^[#SUBGRIPZ=!FT_ADV-A]^<1952>Sub Spindle Position
;Token^<3272>^SET-GRIP-Z^[#SUBGRIPZ=!FT_REALSETUP]^<3273>Sub Spindle Position Value
;Token^<1953>^SUB-Z^[#SUBZPOS=!FT_ADV-A]^<4495>Sub Spindle Z Position
;Token^<4496>^SUB-X^[#SUBXPOS=!FT_XMOVE]^<4497>Sub Spindle X Position  ; new


;Token^<4498>^GRIPDIAM^[GRIPDIAMETER=!FT_REALSETUP]^<4499>Transfer Grip Diameter ; new
;Token^<1954>^CUT-OFF-CHECK^[#CODETECT=!FT_MCODE]^<1955>Cut Off Detect Code
;Token^<1956>^PUSH-CHECK^[FIELD1=!FT_PCHECK]^<1957>Docking Push Check Distance
* Token^HALF-PUSH^[#HALF1=!FT_PCHECK]^Docking Half Push Distance^#HALF1=FIELD1/2
;Token^<4033>^HALF-PUSH^[#HALF1=!FT_HCHECK]^<4034>Docking Half Push Distance
;Token^<1958>^BACKOFF^[FIELD2=!FT_BOFF]^<1959>Docking Back Off Distance
;Token^<1960>^PUSHGCODE^[#PUSHG=!FT_GCODE]^<1961>Docking Push Check G Code
;Token^<2201>^PUSHCHECKBLOCK^^<2202>Push Check Block

;Token^<2203>^MAXRPM-MAIN^[#MAXMAIN=!FT_INTSETUP]^<2070>Spindle Speed (RPM)
;Token^<2204>^MAXRPM-SUB^[#MAXSUB=!FT_INTSETUP]^<2070>Spindle Speed (RPM)

* 5 Axis IKJ
;Token^<2856>^5AXISMODE^[#AX5MODE=!FT_AX5CODE]^<2857>5 Axis Machining Mode
;Token^<642>^IVECTOR^[INORMAL=!FT_AX5ICODE]^<2858>5 Axis I Vector
;Token^<644>^JVECTOR^[JNORMAL=!FT_AX5JCODE]^<2859>5 Axis J Vector
;Token^<646>^KVECTOR^[KNORMAL=!FT_AX5KCODE]^<2860>5 Axis K Vector

*********************************
* New Tokens for Siemens
*********************************
;Token^<1581>^SEMICOLON^[$SCON]^<1582>Semi Colon character
;Token^<2949>^TCMACRO^[$TCMAC]^<2950>Tool Change Macro

;Token^<4267>^CY_CYCLE^[#DRGCODE=!FT_CYGCODE2]^<4268>C/Y Axis CYCLE Code
;Token^<2955>^CYCLE_DEPTH^[#ZMOVE=!FT_ZCYCLE]^<540>Z Depth
;Token^<2956>^CYCLE_LEVEL^[#ZLEVEL=!FT_CYCLEVEL]^<1038>Z Level
;Token^<2957>^CYCLE_RTRACT^[#RPLANE=!FT_RETRACTCYCLE]^<247>R Plane
;Token^<2958>^CYCLE_PITCH^[PITCH=!FT_PITCHCYCLE]^<433>Thread Pitch
;Token^<4035>^CYCLEBREAKS^[#TAPBREAK=!FT_CYCLEBREAKS]^<4036>Chip Break Type Code

;Token^<2959>^ICLOSE^[$IBRKT]^<2960>I Value  )
;Token^<2961>^JCLOSE^[$JBRKT]^<2962>J Value  )
;Token^<2963>^KCLOSE^[$KBRKT]^<2964>K Value  )
;Token^<3145>^CCLOSE-MAIN^[$C1BRKT]^<3146>C Move ) Main
;Token^<3147>^CCLOSE-SUB^[$C2BRKT]^<3148>C Move ) Sub

*Token^COOLCHUCKFACE2^[#CHUCKFACE=!FT_MCOOL3]^Chuck Face Coolant^%IF #SPINDLE=SPINDLEID2 %THEN #CHUCKFACE=#CHUCKFACE2 %ELSE #CHUCKFACE=#CHUCKFACE1
*Token^COOLTHROSPIN2^[#THROUGHSPIN=!FT_MCOOL3]^Through Spindle Coolant^%IF #SPINDLE=SPINDLEID2 %THEN #THROUGHSPIN=#THROUGHSPIN2 %ELSE #THROUGHSPIN=#THROUGHSPIN1
*Token^COOLTURRETFACE2^[#TURRETFACE=!FT_MCOOL3]^Turret Face Coolant^%IF TURRET=0 %THEN #TURRETFACE=#TURRETFACE1 %ELSE #TURRETFACE=#TURRETFACE2
*Token^COOLTHROTOOL2^[#THROUGHTOOL=!FT_MCOOL3]^Through Tool Coolant^%IF TURRET=0 %THEN #THROUGHTOOL=#THROUGHTOOL1 %ELSE #THROUGHTOOL=#THROUGHTOOL2
;Token^<2969>^COOLTHRTLOFF2^[#THROUGHTOOL=!FT_MCOOL3]^<2125>Through Tool Coolant Off
*Token^COOLANT2^[#COOL=!FT_MCOOL3]^COOLANT On/Off
*Token^COOLANT OFF2^[#COOL=!FT_MCOOL3]^Coolant Off ^%CALL=PT_COOL_CANCEL^#COOL=#COOLHOLD

;Token^<2973>^SPIN-BRAKE^[$BRAKE]^<1909>Spindle Brake
;Token^<2974>^MAIN-SPEED^[#SPEED1=!FT_SPEED]^<177>Spindle Speed
;Token^<2975>^SUB-SPEED^[#SPEED2=!FT_SPEED2]^<177>Spindle Speed
;Token^<2976>^CY-SPEED^[#SPEED3=!FT_SPEED3]^<177>Spindle Speed
;Token^<2977>^CY-SPEED-LWR^[#SPEED4=!FT_SPEED4]^<177>Spindle Speed
;Token^<4500>^CSS_SPEED^[#CSSSPEED=!FT_CSSSPEED]^<4501>CSS Spindle Speed

;Token^<3508>^SETSPINREVERSE^^<259>Reverse Spindle
;Token^<2978>^MAIN-SPINDIR^[#DIRECTION1=!FT_MCODE1]^<127>Spindle Direction
;Token^<2979>^SUB-SPINDIR^[#DIRECTION2=!FT_MCODE2]^<127>Spindle Direction
;Token^<2980>^CY-SPINDIR^[#DIRECTION3=!FT_MCODE3]^<3695>Spindle 3 Direction
;Token^<2981>^CY-SPINDIR-LWR^[#DIRECTION4=!FT_MCODE4]^<3696>Spindle 4 Direction

;Token^<2982>^MAIN-GEARMCODE^[#GEARMCODE1=!FT_MCODE1]^<212>Gear Range
;Token^<2983>^SUB-GEARMCODE^[#GEARMCODE2=!FT_MCODE2]^<212>Gear Range
;Token^<2984>^CY-GEARMCODE^[#GEARMCODE3=!FT_MCODE3]^<212>Gear Range
;Token^<2985>^CY-GEARMCODE-LWR^[#GEARMCODE4=!FT_MCODE4]^<212>Gear Range

;Token^<2986>^MAIN-SPINSTOP^[#DIRECTION1=!FT_MCODE1]^<49>Spindle Stop
;Token^<2987>^SUB-SPINSTOP^[#DIRECTION2=!FT_MCODE2]^<49>Spindle Stop
;Token^<2988>^CY-SPINSTOP^[#DIRECTION3=!FT_MCODE3]^<49>Spindle Stop
;Token^<2989>^CY-SPINSTOP-LWR^[#DIRECTION4=!FT_MCODE4]^<49>Spindle Stop

;Token^<2990>^SPIN_SELECT^[$SPINSELECT]^<2991>Machine Spindle Mode
;Token^<2992>^FGROUP^^<2993>FGROUP Block

;Token^<2994>^R_PLANE^[#RPLANE=!FT_RETRACT]^<247>R Plane
;Token^<2995>^THRDPITCH^[PITCH=!FT_PITCHTHREAD]^<433>Thread Pitch
;Token^<2996>^XCYCLEND^[#XMOVE=!FT_XSTART]^<1213>Cycle End X Co-ordinate
;Token^<4502>^YCYCLEND^[#YMOVE=!FT_YSTART]^<4503>Cycle End Y Co-ordinate
;Token^<2997>^ZCYCLEND^[#ZMOVE=!FT_ZSTART]^<1211>Cycle End Z Co-ordinate
;Token^<2998>^THRDTYPE^[#THRDTYPE=!FT_TYPTHREAD]^<2999>Internal/External

;Token^<3000>^TLCOS^[$TLCOS]^<3001>Tool Coordinate Mode
;Token^<3002>^DIAMETER^[$DIASTRING]^<3003>Diameter Mode

;Token^<3004>^MAIN-CHUCK-OPEN^[#MCODE=!FT_MCODE]^<57>Chuck Open
;Token^<3005>^MAIN-CHUCK-CLOSE^[#MCODE=!FT_MCODE]^<1831>Chuck Close
;Token^<3006>^SUB-CHUCK-OPEN^[#MCODE=!FT_MCODE2]^<1833>Sub Spin Chuck Open
;Token^<3007>^SUB-CHUCK-CLOSE^[#MCODE=!FT_MCODE2]^<1835>Sub Spin Chuck Close

;Token^<3008>^COOLTHROTOOL3^[#THROUGHTOOL=!FT_MCOOL3]^<1824>Through Tool Coolant
;Token^<3009>^COOLTHRTLOFF3^[#THROUGHTOOL=!FT_MCOOL3]^<2125>Through Tool Coolant Off
;Token^<3010>^COOLANT3^[#COOL=!FT_MCOOL3]^<2971>COOLANT On/Off
;Token^<3011>^COOLANTOFF3^[#COOL=!FT_MCOOL3]^<125>Coolant Off 

* Added to Siemens for Gildemeister style
;Token^<3012>^STD_SUB_PROGS^^<3013>Call Standard Sub Programs
;Token^<3014>^TOOL_SEQ^[SUBFUNCT=!FT_TOOLSEQ]^<3015>Tool Sequential Number
;Token^<3016>^TOOL_LIST_SEQ^[#HEADER=!FT_TOOLSEQ2]^<3015>Tool Sequential Number
;Token^<3017>^TOOL_LIST+100^[#HEADERPLUS=!FT_TOOLSEQ3]^<3018>Sequential Number +100
;Token^<3019>^TOOL_LIST_PREV^[#PREVHEADER=!FT_TOOLSEQ4]^<3020>Previous Sequential Number
;Token^<3021>^TOOL_LIST_LAST^[NUMTOOLS=!FT_TOOLSEQ4]^<3022>Last Sequential Number
;Token^<3023>^TOOL_LIST_LAST_LWR^[NUMTOOLS1=!FT_TOOLSEQ4]^<3022>Last Sequential Number
;Token^<3024>^CALL_TOOLING_2^^<3025>Second Tooling Loop
;Token^<3026>^PATHNAME^[$PATHNAME]^<3027>Path Description String
;Token^<3028>^B5MOVE^[#BMOVE=!FT_ADV-B5]^<1907>B Axis Move
;Token^<3029>^BANGLE^[#BMOVE2=!FT_TOOL-B]^<3030>Tool B Angle
;Token^<3031>^TOOL-ORIENT^[#TOOLORI=!FT_TOOL-A]^<3032>Tool Orientation Angle
;Token^<3033>^MAIN-SPEED-DOCK^[#SPEED=!FT_SPEED]^<177>Spindle Speed
;Token^<3034>^SUB-SPEED-DOCK^[#SPEED=!FT_SPEED2]^<177>Spindle Speed
;Token^<3035>^MAIN-SPINDIR-DOCK^[#DIRECTION1=!FT_MCODE1]^<127>Spindle Direction
;Token^<3036>^SUB-SPINDIR-DOCK^[#DIRECTION2=!FT_MCODE2]^<127>Spindle Direction
;Token^<3037>^CALL_+_DWELL^^<3038>Call Dwell if not Zero
;Token^<3039>^BARDIAM^[#BARDIAM=!FT_REALSETUP]^<3753>Enter Initial Bar Diameter

* Contour start for Siemens
;Token^<3965>^XSTART^[#XMOVE=!FT_XMOVE]^<3966>Cycle Contour Start X
;Token^<3967>^ZSTART^[#ZMOVE=!FT_ZMOVE]^<3968>Cycle Contour Start Z

*Synchronous speed for Daewoo
;Token^<3042>^SYNCH_DIR^[#SYNCHDIR=!FT_MCODE]^<3043>Spindle Direction Synchronised
;Token^<3044>^SYNCH_STOP^[#SYNCHDIR=!FT_MCODE]^<3045>Spindle Stop Synchronised

*Tokens in Bar Pull

* Tokens for Mazak Matrix Control
;Token^<4300>^5AX-CMOVE-SUB^[#5AXCMOVE2=!FT_5AXCMOVE2]^<4301>5 Axis C Move Sub Spindle
;Token^<3413>^MAINSPINSHIFT^^<3414>Main Spindle Z Shift
;Token^<3190>^SUBSPINSHIFT^^<3191>Sub Spindle Z Shift
;Token^<3192>^SUBSPINDATUM^[#SSDAT=!FT_REALSETUP]^<3191>Sub Spindle Z Shift
;Token^<3193>^TOOL_CRC^[#COMPDCODE=!FT_CRCNO2]^<218>TNR Compensation Register
;Token^<3194>^CURRENTX^[#XHOLD=!FT_XMOVE]^<3195>Current X Position
;Token^<3196>^CURRENT-C-MAIN^[#C1HOLD=!FT_CMOVE1]^<3197>Current C Main
;Token^<3198>^CURRENT-C-SUB^[#C2HOLD=!FT_CMOVE2]^<3199>Current C Sub
;Token^<3200>^5AXOFFSET^[#HCODE5AX=!FT_TLONO5]^<190>Tool Length Offset
;Token^<2783>^LENGTHOFFSET2^[#HCODE=!FT_TLONO2]^<190>Tool Length Offset
;Token^<4137>^CHANGEOFFSET2^[#HCODE=!FT_TLONO4]^<4130>Change Length Offset
;Token^<2490>^TOOLDIR^[#TDIR=!FT_DIRSET]^<2491>Tool Application Direction
;Token^<3201>^TOOLDIR2^[#TDIR=!FT_DIRSET2]^<2491>Tool Application Direction
;Token^<3415>^TLENGTH^[TOOLEN=!FT_TLENGTH]^<3416>Tool Length

* Force brake tokens for Integrex
;Token^<3202>^SPINCLAMP-OFF^[#BRAKE=!FT_MCODE]^<3203>Override Spindle Clamp
;Token^<3204>^SPINCLAMP-LOW^[#BRAKE=!FT_MCODE]^<3203>Override Spindle Clamp
;Token^<3205>^SPINCLAMP-HIGH^[#BRAKE=!FT_MCODE]^<3203>Override Spindle Clamp

;Token^<3274>^MACVAR1^[$MACVAR1]^<3275>Machine Controller Variable
;Token^<3276>^MACVAR2^[$MACVAR2]^<3275>Machine Controller Variable
;Token^<3277>^MACVAR3^[$MACVAR3]^<3275>Machine Controller Variable
;Token^<3278>^MACVAR4^[$MACVAR4]^<3275>Machine Controller Variable
;Token^<3279>^MACVAR5^[$MACVAR5]^<3275>Machine Controller Variable
;Token^<3280>^MACVAR6^[$MACVAR6]^<3275>Machine Controller Variable
;Token^<3281>^MACVAR7^[$MACVAR7]^<3275>Machine Controller Variable
;Token^<3282>^MACVAR8^[$MACVAR8]^<3275>Machine Controller Variable

;Token^<3283>^DIA-MODE^[#DIAMODE=!FT_GCODE]^<3003>Diameter Mode

* New tokens for back bore cycles
;Token^<3527>^CY_BOTTOMZCLEAR^[BOTTOMZCLEAR=!FT_BACKCLEAR]^<3528>Back Bore Z Clear
;Token^<3529>^CY_BOTTOMZLEVEL^[BOTTOMZLEVEL=!FT_BACKLEVEL]^<3530>Back Bore Z Level
;Token^<3531>^CY_BOTTOMZDEPTH^[BOTTOMZDEPTH=!FT_BACKDEPTH]^<3532>Back Bore Z Depth
;Token^<3533>^CY_ZRELIEF^[ZRELIEF=!FT_BACKRELEIF]^<3534>Back Bore Z Back Off
;Token^<3535>^CY_RELIEFDIR^[RELIEFDIR=!FT_BRDIRN]^<3536>Back Bore Relief Direction
;Token^<3537>^CY_RELIEFDIST^[RELIEFDIST=!FT_BSREL]^<3538>Back Bore Side Relief

* New tokens for Helical cycles
;Token^<3539>^CY_HOLEDIAM^[HOLEDIAM=!FT_HELDIAM]^<3540>Helical Hole Diameter
;Token^<3541>^CY_TOOLDIAM^[#HOLE2DIAM=!FT_HEL2DIAM]^<3540>Helical Hole Diameter
;Token^<3542>^CY_CHAMFERWIDTH^[CHAMFERWIDTH=!FT_HELCHFR]^<3543>Helical Chamfer Width
;Token^<3544>^CY_CHAMFERANGLE^[CHAMFERANGLE=!FT_HELANG]^<3545>Helical Chamfer Angle
;Token^<3546>^CY_PITCH1^[PITCH1=!FT_HELPITCH1]^<3547>Helical Chamfer Pitch
;Token^<3548>^CY_PITCH2^[PITCH2=!FT_HELPITCH2]^<3549>Helical Hole Pitch
;Token^<3550>^CY_BOTTOMFINISH^[BOTTOMFINISH=!FT_HELFIN]^<3551>Helical Finish Pass
;Token^<3552>^CY_MACHDIR^[MACHDIR=!FT_HELDIRN]^<3553>Helical Mc Direction
;Token^<3697>^CY_AXIS^[#HELAX=!FT_HELAXIS]^<3698>Helical Axis
;Token^<3699>^CY_H_LEVEL^[#CYCLEVEL=!FT_CYCLEV]^<3700>Helical Cycle Level

* Tokens for mini turret etc, moved from Daewoo
* G400/490
;Token^<2793>^TURN_B^[#TURNTOOLBANG=!FT_TURNB]^<2794>Turn Tool B Angle
;Token^<2795>^J_VALUE^[#JVAL=!FT_JVAL]^<2796>Offset Conversion J Value
;Token^<2797>^OFFSET_CONV^^<2798>Offset Conversion Blocks
;Token^<2799>^CONVERSION_GCODE^[#GCODE=!FT_GCODE]^<2800>Offset Conversion G Code
;Token^<2801>^ORIENTATION_GCODE^[#GCODE=!FT_GCODE]^<2802>Mini Turret Orientation G Code
;Token^<2803>^ORIENT_ANGLE^[#SWORD=!FT_ORIENT_ANGLE]^<2804>Mini Turret Orientation Angle

* Turret Park tokens
;Token^<3754>^XPARK^[#XPARK=!FT_XMOVE]^<3755>X Park Position MC Coordinates
;Token^<3756>^YPARK^[#YPARK=!FT_YMOVE]^<3757>Y Park Position MC Coordinates
;Token^<3758>^ZPARK^[#ZPARK=!FT_ZMOVE]^<3759>Z Park Position MC Coordinates

;Token^<3760>^XTURRETPK^[#XTPARK=!FT_XMOVE]^<3761>X Park Turret Datum
;Token^<3762>^YTURRETPK^[#YTPARK=!FT_YMOVE]^<3763>Y Park Turret Datum
;Token^<3764>^ZTURRETPK^[#ZTPARK=!FT_ZMOVE]^<3765>Z Park Turret Datum

;Token^<4138>^XPARKINC^[#XPARKINC=!FT_XMOVE]^<4139>Incremental - Toolchange to Park
;Token^<4140>^YPARKINC^[#YPARKINC=!FT_YMOVE]^<4139>Incremental - Toolchange to Park
;Token^<4141>^ZPARKINC^[#ZPARKINC=!FT_ZMOVE]^<4139>Incremental - Toolchange to Park

;Token^<3766>^PARK_POSITION^[$PARKPOS]^<3767>Parking Position Identifier
*
*********************************
*
*  Code Wizard Templates
*  File Turn-ISO-Mach.cgi
*
*********************************
*
* Created December 2003
* Placed under change control
* Richard Halton
*
* File contains Machine configuration lines
*
*Change Control
* 23/12/03 RHA DEV00009701 Move MM MS MT etc to this file
* 22/01/04 RHA DEV00009966 Correct sub spindle type setting to 3
* 04/02/04 RHA DEV00009826 Correct MM defaults, SW17-19
* 06/02/04 RHA DEV00009826 Change TC and Home defaults
* 25/02/04 RHA DEV00010375 Set lower turret default to main spindle
* 11/03/04 RHA DEV00010541 Correct MM line and comments for helical
* 22/03/04 RHA DEV00010590 MM line settings for 2AX & 4AX
* 21/05/04 RHA DEV00010995 Set switch 14 on 2axis sub spindle MS line to zero
* 10/06/04 RHA DEV00011069 CRC/TLO Q var fixes
* Version 9.75
* 24/02/05 RHA DEV00000610 Make Q var Strings translateable
* Version 10
* 13/07/05 RHA DEV00014426 Set MM and MT lines for machine configuration etc
* 29/07/05 RHA DEV00014427 Added KT data lines for machine configuration
* 03/08/05 RHA DEV00014427 Change default ATC graphic parameters
* 04/08/05 RHA DEV00014645 Add file name extension (NC) string to MM lines
* 04/08/05 RHA DEV00014427 Add bevel angle, KTTURRET line
* 05/08/05 RHA DEV00014427 Chuck parameters and Base Front Height
* 12/08/05 RHA DEV00014721 Modify chuck parameters
* 16/08/05 RHA DEV00014427 Move KT lines to include file
* 19/09/05 RHA DEV00014993 & 15001 Changes to machine setup parameters
* Version 10.75
* 25/04/06 RHA DEV00016963 Set MM lines for 5 Axis
* Version 11.0
* 28/07/06 RHA DEV00017797 New MM and MT switches
* Version 11.5
* 08/11/06 RHA DEV00016814 Stop options on synch instruction
* 05/02/07 RHA DEV00019146 Chamfer thread mode
* Version 12.0
* 02/08/07 RHA DEV00020280 Add spindle synch to docking
* 05/09/07 RHA DEV00020280 Correct language reference
* Version 12.5
* 06/02/08 RHA DEV00022190 Set default CRC in helical interpolation
* 27/02/08 RHA DEV00022540 Add MT switch 36 turret type
* Version 2009.1
* 13/08/08 RHA DEV00023795 Implement Back Bore & Face and Helical hole cycles
* Version 2009.2
* 19/12/08 RHA DEV00025797 Comment new MT fields
* 06/01/09 RHA DEV00020613 Add default file name suffices to MT lines
* 01/04/09 RHA DEV00025920 Add Turret Park data
* Version 2011.1
* 04/06/10 RHA W39410 Document MM line switches 42 43
* 06/07/10 RHA W39894 Document and set MM line sw44
* 27/08/10 RHA W40175 Set MM sw42 to 1
* Version 2011.2
* 16/11/10 RHA W41684 Document MM line switches
* Version 2012.2
* 16/08/11 RHA W36919  Add Programable Tailstock processing
* 31/08/11 RHA W45992 Make Max Rapid and High Feed the same value
* 16/02/12 RHA W48810 Modify MB= line in line with KT
* 04/04/12 JME Add Datum2CentreY for MB= line
* 20/04/12 RHA W49996 Correct use of Q206
* Version 2013.1
* 26/09/12 RHA W52918 MT line documentation
* Version 2014.2
* 14/11/13 RHA W61589 Implement additional turrets
* 15/01/14 RHA W62669 Correct turret mount ID for driven spindles
* 29/01/14 RHA W61589 Correct default file extension in MT lines
* Version 2015.2
* 08/01/15 RHA W35019 Add prog stop and comment to Rapid Home and TC
* 08/01/15 RHA W66683 Add prog Stop to Bar Pull, Docking and S/Spin Move
* 24/02/15 RHA W81419 Add 268 to Q var definitions
* 02/04/15 RHA W82748 Update comment lines for MM switches
*
;
;___________________________________________________________ Macro = Machine_____

%MACHINE=LATHE=2 Axis Generic ISO G-code
**********************************************
* Setting up machine defaults (MM section)
**********************************************
; sw 1  0=Inch / 1=Met
; sw 2  max RAPID
; sw 3  max RPM
; sw 4  max ANG FEED (deg/min)
; sw 5  Twotapes
; sw 6  Rapid 3D
; sw 7  Unresolved RAPID movement
; sw 8  Index / Non-indexable post / Misc settings (Bitwise additional)
;       Bit 0  Simple index disabled (Milling only)
;           1  Simple Index enabled  (Milling only)
;           2  Visit reset macro once after mirror (Milling only)
;           4  Enable reverse offset (Milling only)
;           8  Reverse tool side - 45degree line (Turning only)
;          16  Enable NEXTMOVE "look ahead" in toolchange
;          32  Enable version 4 controller compensation enhancements (Milling only)
;		Examples - 3=index support + visit mirror reset
;    			   7=index support, visit mirror reset + reverse offset
; sw  9	Axes of Rotation	(Mill only)
; sw 10	Plane Switching		(Mill only)
; sw 11 Initial Plane Height
; sw 12 Tool gauge point Centre (0 = disable : 1 = enable)
; sw 13	Profile or Guide Height	0 = Profile, 1 = Guide	     (UV Wire only)
; sw 14	Z Top Guide	Value		     (UV Wire only)
; sw 15	Z Bottom Guide	Value		 (UV Wire only)
; sw 16 Cutter Radius Compensation factor
; sw 17 Output wrapped co-ordinates		Rotary milling (including Caxis Turn-mill)
; sw 18 Maximum programmable radius
; sw 19 Support radial Arcs - circular interpolation   0=No, 1=Yes
; sw 20 Support XC interpolation (Axial)
; sw 21 Spline support (Mill only)
; sw 22 Z Feedrate control (not used)
; sw 23 CRC
; sw 24 CRC
; sw 25 CRC
; sw 26 Helical arc milling
; sw 27 File extension string
; sw 28 Machine coordinate output (Non-Orthogonal planes) 0=no, 1=yes (Not yet in use)
; sw 29 Machine coordinate output (Orthogonal planes) 0=no, 1=yes (Not yet in use)
; sw 30 Pivot Point
; sw 31 5 axis cycle, 0=Abs Tooltip, 1=Abs Pivot Point, 2=Part Coords, 3=Baxis ToolTip, 4=Baxis Pivot Point
; sw 32 Set to 1 for EC10.5 style (mill only)
; sw 33 Inverse Time Feedrates
; sw 34 use IJK in 5 Axis 0=no, 1=yes (Sw 31 must be set "2" for IJK)
; sw 35 CRC Corner Display 0=round 1=sharp
; sw 36 Multi-plane nutated 0=Orthogonally aligned  1=Machine axis aligned
; sw 37 Multiplane coordinate output 0=CPL Coordinates  1=Machine Coordinates
; sw 38 Pivot about Tool Tip 0=no 1=yes
; sw 39 Always Reset Rotary Datum after 5 axis milling cycle
; sw 40 CRC support in helical milling 0=no 1=yes
; sw 41 Ignore Coincident CPLs 0=no, 1=yes
; sw 42 Leave CPL in Initial (5axis cycles presented to Moduleworks in initial cpl)
; sw 43 Remove 5 Axis Collinear Moves 0=no, 1=yes
; sw 44 Consistent lower turret angles,  Affects axial angles on lower turret subspindle (2011R1)
; sw 45 Setting for blank input fields. 0 (or unset) for set to 0, 1 for set to #FUNNY
; sw 46 Cartesian Ouput in Rotary Axial 0=no, 1=yes  (Milling Only)
; sw 47 Cartesian Ouput in Rotary Axial Holes 0=no, 1=yes  (Milling Only)
; In Code Wizard source !_MM_48 reads position MM_49.
; sw 48 Dynamic Offset support  (Milling Only)
; sw 49 Allow G40 On Retract Move (Milling Only)
; sw 50 Display Five Axis Moves As Linear  (Milling Only)
; sw 51 Output Angle Directions (System Variables ROT1DIR, ROT2DIR)
; sw 52 Support Simultaneous Indexing  (Milling Only)
; sw 53 Polar Switch CY force move to Y0 C0 (Turning CY only)
;
MM=1,24000,7500,400,0,1,0,56,0,0,0,1,0,0,0,1.5,0,9999.999,1,1,0,0,0,0,0,0,nc,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0
**********************************************
* Setting up turret defaults
**********************************************
; sw  1  Turret name
; sw  2  Number of stations
; sw  3  Tool change X
; sw  4  Tool change Y
; sw  5  Tool change Z
; sw  6  Home X
; sw  7  Home Y
; sw  8  Home Z
; sw  9  Max Extents X
; sw 10  Max Extents Y
; sw 11  Max Extents Z
; sw 12  Min Extents x
; sw 13  Min Extents y
; sw 14  Min Extents z
; sw 15  Max Primary feed
; sw 16  Max Secondary feed
; sw 17  TC Dwell
; sw 18  Number of load points
; sw 19	Z Separation for Multiple Load Points
; sw 20	X Separation 	-""-
; sw 21	B-axis Swing Configuration [1]
; sw 22	Default SpindleId (0,1)
; sw 23  Min B axis extent
; sw 24  Max B axis extent
; sw 25  Angular Increment of B Axis
; sw 26  B axis angle at Tool Change
; sw 27  Tool Set X
; sw 28  Tool Set Y
; sw 29  Tool Set Z
; sw 30  Turret type 0=Indexing, 1=ATC
; sw 31  Index time per station
; sw 32  Move to ToolChange & Home Pivot  (0=about tip, 1=about pivot point)
; sw 33  Move Index
; sw 34  Move Angular, Feed, Rapid
; sw 35  B axis 0= interpolates, 1=indexing only
; sw 36  Turret rotates to face sub spindle 0= no, 1= yes
; sw 37  Turret Park X Main end (turn only)
; sw 38  Turret Park Y Main end (turn only)
; sw 39  Turret Park Z Main end (turn only)
; sw 40  Turret Park B Main end (turn only)
; sw 41  Turret Park X Sub end (turn only)
; sw 42  Turret Park Y Sub end (turn only)
; sw 43  Turret Park Z Sub end (turn only)
; sw 44  Turret Park B Sub end (turn only)
; sw 45  Turret Holder type for tool selection
; sw 46  NC File name suffix for 2 file output
; sw 47  Allow rotated Tool Mounting (Turn)
* Note that turret movement extents have been replaced by KT line
;                                       10                                      20                        30
MT=turret,8,110,0,180.75,110,0,180.75,110,0,175,0,0,0,24000,4800,4,1,0,0,0,0,-30,210,0,0,70,0,0,0,1,1,1,0,0,0,900,0,190,0,900,0,1600,0,,-1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
MP=0,0,70,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
**********************************************
* Setting up spindle defaults
**********************************************
; sw  1 Name  Main/Sub
; sw  2 ID
; sw  3 TurretId on which spindle is mounted [0,1,2,3 (-1 = n/a)]
; sw  4 Type (Driven 0, Main 1, Mounted 2 (not used yet), Sub 3)
; sw  5 MaxRpm
; sw  6 MaxAngFeed
; sw  7 Direction [0 CCLW,1 CLW]
; sw  8 MirrorOutput [0,1] 	(Not used yet)
; sw  9 CSS Capable [0,1] 	(Not used yet)
; sw 10 Rotation [None=0,A=1,B=2,C=3]  	(Not used yet)
; sw 11-13 Default Location [X,Y,Z] (X and Y should always be zero at present)
; sw 14 DefaultTurretId for control of speeds
; sw 15 HorsePower
; sw 16 DatumToChuckFace
; sw 17 RapidRate M/Min
; sw 18 Angular Increment C axis  	(Not used yet)
; sw 19 Spindle stop time         	(Not used yet)
; sw 20 Spindle acceleration time  	(Not used yet)
; MG Line
; No. Gears,Min1,Max1,UserMax1,Code,...........
; Main spindle always set
;  1    2 3  4 5    6   7     10
MS=main,0,-1,1,7500,280,0,0,1,3,0,0,0,0,20,62,0,0
MG=2,28,5000,4800,0,4801,7500,7300,0
*
*
; Sub Spindle
; User defined macro modifiers
*Tool Change
* Work Datum^Datum 1^Datum 2^Datum 3^Datum 4^Datum 5^Datum 6
Q202=_list=_lang804 [15]
* Q201=_real=CRC Register[12,15,165]
Q201=_real=_lang805 [12,15,165]
* For Nakamura Tool Change
* Mount Side Right
Q206=_check=_lang806 [15,165]
* Mount Angle
Q203=_real=_lang807 [15,165]
*	Simple Turn cycle
* Chipbreak amount
Q202=_real=_lang808 [3]
*	Threading cycle
* Thread Chamfer
Q206=_check=_lang910 [8]
* Output Type^Longhand^Single Block Cycle^Canned Cycle
Q207=_list=_lang809 [8]
* Pull Out Amount
Q208=_real=_lang810 [8]
* Hole Cycles
* Tap Cycle Type^Floating^Rigid
Q203=_list=_lang811 [9,10,159,160,161,162,163,671,672]
* Coolant
* Chuck Face
Q201=_check=_lang812 [104]
* Turret Face
Q202=_check=_lang813 [104]
* Through Tool
Q203=_check=_lang814 [104]
* Through Spindle
Q204=_check=_lang815 [104]
* All
Q205=_check=_lang816 [104]
Q206=_separator=...  [104]
*
* 209 is prog stop options
Q209=_list=_lang908 [23,173,261,264,255,263,40,41,190,191]
*
* 208 is prog stop options, 209 used for spindle synch
Q208=_list=_lang908 [254,262,268]
Q209=_list=_lang915 [254,262,268]
*
%ENDMACH
*********************************
*
*  Code Wizard Templates
*  File Turn default kt mm.cgi
*
*********************************

* 24/08/05 RHA DEV00014783 Correct chuck parameters
* 31/08/05 RHA DEV00014428 Set turrets horizontal, add turret note
* 15/09/05 RHA DEV00014721 Modify base width and height
* 30/09/05 RHA DEV00015186 Mounting block and Spindle protrusion dimensions
* Version 2012.1
* 16/08/11 RHA W36919 Add Programable Tailstock processing
* Version 2012.2
* 03/11/11 RHA W47190 Add data and controls for Steadies


; KT graphics definitions MM
; Note that this data is not passed through to the Code Generator source file.

; Base for all machines
; KTBASE=Length, Width, Depth, Angle, Front Height

; Turret for single turret machines
* KTTURRET=Name,Stations,width,radius,bevel,orientationxyz,limitsxyzabc

; Upper turrets for CYB and 4 axis machines

; Lower turret for 4 axis machines



; Main spindle
; KTSPINDLE=SpindleName,Length,Width,Depth,Height,Protrude,Diameter,Reverse

; KT Chuck SpindleName,Type,Length,Diameter,Bore,JawLength,JawHeight,JawWidth,Protrusion,NoJaws,NoSteps

; Sub Spindle

; KT Chuck SpindleName,Type,Length,Diameter,Bore,JawLength,JawHeight,JawWidth,Protrusion,NoJaws,NoSteps


; End of KT graphics definitions



*
*********************************
*
*  Code Wizard Templates
*  File Turn-ISO.cgi
*
*********************************
*
* Created from old templates 10 June 2003
* Placed under change control
* Richard Halton
*
* File contains settings, code constructors for
* turning templates based on generic ISO codes.
*
*  General fixes also implemented here
* 05/08/03 RHA DEV00008306 Separate vars for rapid and feed polar/cartesian mode
* 07/08/03 RHA DEV00007890 Make R word calculation in cycles switchable
* 26/08/03 RHA DEV00008539 Add warnings counter

*Change Control
* 14/11/03 RHA DEV00009364 Correct coolant settings
* 20/11/03 RHA DEV00009231 Combined spindle and coolant codes added
* 28/11/03 RHA DEV00009456 AVN Feedback - Safe block numbering & Tool Change options
* 01/12/03 RHA DEV00009456 Block number on/off setting
* 01/12/03 RHA DEV00009047 Complete spindle synch
* 05/12/03 RHA DEV00007048 Add Rigid Tapping Option
* 10/12/03 RHA DEV00009413 Implement Template type selection and update configuration switch comments
* 15/12/03 RHA DEV00009612 Add new date tokens
* 15/12/03 RHA DEV00009616 Remove all Q67 series uservars
* 16/12/03 RHA DEV00009384 Pull Out token for threading
* 18/12/03 RHA DEV00005023 Modify MG= lines for updated Wizard
* 19/12/03 RHA DEV00009572 Set B Axis defaults in MT lines
* 23/12/03 RHA DEV00009704 Reposition tokens that call code constructors
* 23/12/03 RHA DEV00009700 Replace ;CODE: comments with TEXT instructions
* 23/12/03 RHA DEV00009701 Move MM MS MT etc to new file
* 06/01/04 RHA DEV00009700 Shorten long strings
* 07/01/04 RHA DEV00009700 Shorten long strings
* 12/01/04 RHA DEV00009798 Correct sub spindle option switches (NC Style)
* 15/01/04 RHA DEV00008184 Give GEARMCODE its own format address, add new setup tokens
* 15/01/04 RHA DEV00009858 High Feed Option for Rotary Rapid
* 15/01/04 RHA DEV00009858 New address for pseudo-polar Y coordinates
* 19/01/04 RHA DEV00008669 Additional token requirements, found while developing Okuma
* 26/01/04 RHA DEV00009967 Polar setting for Radila/Diametral #POLARDIAM
* 26/01/04 RHA DEV00009902 Correct Z reversal initialisation
* 26/01/04 RHA DEV00009953 Use token for second leg rapid to Home/ToolChange
* 27/01/04 RHA DEV00009963 Add [ ] tokens to start, toolchange and B index
* 02/02/04 RHA DEV00010088 add diametral switches for axial/radial machining
* 03/02/04 RHA DEV00009953 IF filtering in code constructors
* 05/02/04 RHA DEV00010058 Call WARNCOUNT in both END sequences
* 05/02/04 RHA DEV00010113 Tidy Coolant Dialog
* 05/02/04 RHA DEV00009977 Tokens for user defined toolstore variables
* 06/02/04 RHA DEV00010166 Force coordinate output in Rapid after Tool Change
* 10/02/04 RHA DEV00010088 Correct #DIAM switching
* 10/02/04 RHA DEV00009858 Correct setting description
* 10/02/04 RHA DEV00010200 Add blank target to format table for output initialisation
* 12/02/04 RHA DEV00004642 Additional use of through tool coolant token*
* 13/02/04 RHA DEV00010219 Separate Z reverse switch for sub spindle driven tools
* 16/02/04 RHA DEV00010264 Remove old gear code settings
* 11/03/04 RHA DEV00010521 CSS speed check optional
* 12/03/04 RHA DEV00010538 Set HOMETYPE to 1, Make #JVALUE modal
* 22/03/04 RHA DEV00010537 Correct Retract G Codes
* 06/04/04 RHA DEV00010544 Set reverse sub spindle driven to "no".
* Version 900
* 07/05/04 RHA DEV00010784 Next tool tokens have own format addresses
*                          Add Retract Ejector Token
*                          Driven codes for sub spindle
*                          Spindle select codes for driven tools
* 07/05/04 RHA DEV00010872 Chuck open/close correction
* 10/05/04 RHA DEV00010872 Add separate control for polar in hole cycles
* 13/05/04 RHA DEV00010924 Tool Change corrections, alternative code constructors etc
* 17/05/04 RHA DEV00010788 Remove hard coded spindle default in START macro
* 17/05/04 RHA DEV00010961 Make tool and datum list available at END
* 20/05/04 RHA DEV00010990 Correct spindle brake default sequence
* 08/06/04 RHA DEV00010175 Make token lists more context sensitive for 2 axis configurations
* 09/06/04 RHA DEV00011069 Additional TLO calculation option
* 12/07/04 RHA DEV00011376 Corrections to token availablity - 2 axis lathes.
* 13/07/04 RHA DEV00010745 Correct modality switching of synch codes and SS Clamp
* 15/07/04 RHA DEV00008178 Add multi level/depth to hole cycles
* 19/07/04 RHA DEV00011202 Implement arc bulge control
* 19/07/04 RHA DEV00010739 B Axis formatting corrections
* 20/07/04 RHA DEV00010907 Put MAXRPM tokens in all start macros
* 20/07/04 RHA DEV00009388 Datum choice for sub spindle movements
* 22/07/04 RHA DEV00010924 Correct mode-change tool change calls
* 29/07/04 RHA DEV00011469 Add X Reversal options
* 03/08/04 RHA             Truncate over long text string
* 17/08/04 RHA DEV00009388 Correct sub spindle datum choice
* 17/08/04 RHA DEV00011828 Correct start default sequence for non-sub-spindle
* Version 9.5
* 02/11/04 RHA DEV00012081 Face Angle Option #REVERSEFACE
* 18/11/04 RHA DEV00010894 Set format entries for debug and null formats
* 18/11/04 RHA DEV00012011 Remove feed tokens from default rapid output
* 30/11/04 RHA DEV00012029 Allow negative radius on large arcs
* 30/11/04 RHA DEV00012242 List LT tools on merged tape
* 01/12/04 RHA DEV00011681 Additional mill tool tokens
* 07/12/04 RHA DEV00012698 Manual option for Polar control
* 08/12/04 RHA DEV00012640 Make max block number subserviant to Use Block Numbers
* 09/12/04 RHA DEV00012305 Setmodal for #BRAKE
*                          Rigid Tapping G Codes,  #RIGIDRIGHT,#RIGIDLEFT
* 14/12/04 RHA DEV00012768 Add CRC token to toolchange code constructors
* 14/12/04 RHA DEV00012765 Make hole cycle approach context sensitive #PREPOSITION
* 21/12/04 RHA DEV00012864 Correct helix ZEND, Make KVALUE=PITCH switchable
* 23/12/04 RHA DEV00012874/6 Token availablity
* 14/01/05 RHA DEV00013074 G55 datum Token and format entry for Turret_side
* Version 9.75
* 16/02/05 RHA DEV00013392 Lower turret arc call
* 16/02/05 RHA DEV00013396 SUBROUTINE token in turn cycles
* 23/02/05 RHA DEV00009955 Add Stub for CODECON_START_TURN_CYCLE
* 09/03/05 RHA DEV00012875 Add User Numeric Tokens 11-20
* 09/04/05 RHA DEV00012720 Make cyclsub end extension generally available
* Version 10
* 20/05/05 RHA DEV00014066 Reverse driven tools G2/3 on sub spindle
* 23/05/05 RHA DEV00014071 Correct spindle direction setting
* 31/05/05 RHA DEV00014115 Correct sub spindle Joint/Release codes
* 31/05/05 RHA DEV00013885 Add FEEDMODEGCODE to Bar Feed
* 31/05/05 RHA DEV00013877 Remove Force Now in rapid after ToolChange
* 01/06/05 RHA DEV00013972 Allow use of user selected datums
* 02/06/05 RHA DEV00013852 Additional tokens requested for ROMI
* 06/06/05 RHA DEV00009954 Hole Cycle Points code constructor
* 08/06/05 RHA DEV00014175 Radial unwrapped data
* 09/06/05 RHA DEV00013857 Set data6 coolant values
* 15/06/05 RHA DEV00013866 Change metric default for user tokens to 4.3
* 07/07/05 RHA DEV00013851 Spindle initialisation control tokens
* 14/07/05 RHA DEV00013853 #ZMOVE in SS coords for R to TC & Home
* 22/07/05 RHA DEV00013858 Correct thread approach checks
* 28/07/05 RHA DEV00014532 Add PLANEGCODE token to turret code cons
* 01/08/05 RHA DEV00014365 Add separtae C axis reversals for sub spindle
* 02/08/05 RHA DEV00014365 Add Sub Spindle C offset
* 05/08/05 RHA DEV00014305 Add ABSINC token to Sub End code constructor
* 18/08/05 RHA DEV00014772 Correct hole cycle points option list
* 18/08/05 RHA DEV00014693 Initialise KEEP values at start
* 30/08/05 RHA DEV00014693 Initialise CHOLD values as #FUNNY
* 13/09/05 RHA DEV00014496 Remove conflicting flag for rapid to feed in polar mode
* 22/09/05 RHA DEV00015104 Allow RPLANE to be diametral for radial hole cycles
* 30/09/05 RHA DEV00015213 AutoCoolant implemented
* 05/10/05 RHA DEV00015229 Reset autocoolant default to ON
* Version 10.5
* 16/12/05 RHA DEV00015819 Correct status warning message (Start Macro)
* 13/01/06 RHA DEV00013965 Add ABSINC token to Rapid-After-ToolChange
* 26/01/06 RHA DEV00016091 Make Y suppression optional
* 10/03/06 RHA DEV00015691 Fix G2/3 reversal of subspindle driven tools
* Version 10.75
* 11/04/06 RHA DEV00016478 Correct format table filter for !FT_VZERO
* 12/04/06 RHA DEV00010822 Designate logical tokens by colour
* 12/04/06 RHA DEV00016781 Document use of UARRAY1 in template
* 12/04/06 RHA DEV00016809 Colour code tokens
* 20/04/06 RHA DEV00016926 SUBROUTINES and WARNCOUNT designated as Logical tokens
* 24/04/06 RHA DEV00014455 Implement spindle brake controls
* 28/04/06 RHA DEV00016963 5 Axis additions
* 09/05/06 RHA DEV00016963 5 Axis, B axis modality
* 10/05/06 RHA DEV00016963 5 Axis, Independent #DIAM setting
* 24/05/06 RHA DEV00015514 Allow Rapid after toolchange following lathe index
* Version 11.0
* 28/07/06 RHA DEV00017797 New MM and MT switches
* 07/08/06 RHA DEV00017776 Add Spindle not started warning option
* 14/08/06 RHA DEV00017927 Add ThroughTool token to TC code cons
* Version 11.5
* 20/09/06 RHA DEV00017909 Expand trace options
* 06/11/06 RHA DEV00016817 Cancel TLO, control improvements using #TLOMODAL
* 08/11/06 RHA DEV00016814 Add Safe start code constructors, called by token from Program Stop
* 14/11/06 RHA DEV00012251 Implement cylindrical mode for radial tools
* 22/11/06 RHA DEV00018299 Correct part catcher codes
* 22/11/06 RHA DEV00017578 Option to suppress B Index if unchanged
* 18/12/06 RHA DEV00018841 Add Cylindrical code to Format Table
* 22/12/06 RHA DEV00018881 Add hole cycle depth token to turn cycles
* 08/01/07 RHA DEV00018930 Add Peck Safe Distance token
* 05/02/07 RHA DEV00019146 Chamfer thread mode
* 05/02/07 RHA DEV00016782 Add Format Table reference for CYL_HEIGHT
* Version 11.75
* 10/04/07 RHA DEV00019598 Change tapping to use corrected DWELL G Code
* 10/04/07 RHA DEV00019392 More drill tokens
* 11/04/07 RHA             Make GEARMCODE token available with SPEED token
* 12/04/07 RHA DEV00019713 Implement output options for multi-turret - #SUPPSPEED
* 24/04/07 RHA DEV00019798 Bar Pull Datum Shift
* Version 12.00
* 13/07/07 RHA DEV00020473 Spindle brake additions
* 19/07/07 RHA DEV various Setmodal for #DRGCODE
* 24/07/07 RHA             Set modality for #ITEMP,#KTEMP thread taper variables
* 01/08/07 RHA DEV00018692 Initialise #BRAKEHOLD
* 02/08/07 RHA DEV00020531 Fix Incremental from Clearance option for hole cycles
* 23/08/07 RHA DEV00020782 Force TLO after 5 axis ON option
* 18/09/07 RHA DEV00021048 Spindle clamping improvements
* 21/09/07 RHA DEV00021090 Lower turret hole array reversals
* 24/09/07 RHA DEV00021100 Add spindle brake over ride controls
* Version 12.25
* 07/11/07 RHA DEV00011484 Token availabilty and maxtools initialisation
* 08/11/07 RHA DEV00019011 Switchable ability to suppress unwanted LT start/end calls
* 12/11/07 RHA DEV00017344 Set #SPINDLECODE=#FUNNY for lower turret start
* 14/11/07 RHA DEV00020978 Allocate SS warnings to Turret
* 16/11/07 RHA DEV00019501 CancelTLO initialisation and modality
* 19/11/07 RHA DEV00021600 Add new tokens for Tool ID and Group
* 30/11/07 RHA DEV00021496 Make rotary B-axial fix switchable
* 03/12/07 RHA DEV00021534 Enable longhand tapping
* 10/12/07 RHA DEV00022572 Change Tool ID and GROUP tokens, now 6 in total
* Version 2009.1
* 14/04/08 RHA DEV00018979 Correct BNUM reset
* 22/04/08 RHA DEV00023110 Constant offset token etc for turn cycles
* 22/05/08 RHA DEV00023233 Check for Y0C0 at polar switch
* 06/06/08 RHA DEV00023555 Stub procedure for G200 hole cycle approaches
* 09/06/08 RHA DEV00023795/7 Add stubs for codecons
* 16/07/08 RHA DEV00023008 Add chuck name tokens for start and set up code constructors
* 07/08/08 RHA DEV000022514 Allow polar switching at B0 and B180
* 13/08/08 RHA DEV00023795 Implement Back Bore & Face and Helical hole cycles
* 28/08/08 RHA DEV00023797 ToolDiameter token - helical hole
* Version 2009.2
* 24/10/08 RHA DEV00014875 remove duplicate rapid feedrate setting
* 24/10/08 RHA DEV00025000 Allow Rapid after tool change with null move
* Version 2009.2
* 07/11/08 RHA DEV00025098 Make tool angle available in setup & core tool change
* 07/01/09 RHA DEV00025831 Add token for holdertype
* 08/01/09 RHA DEV00022131 Allow Y reversals on driven tools
* 16/01/09 RHA DEV00025921 Turret park - codecon stubs
* 04/02/09 RHA DEV00026063 Add force feedtype options
* 04/02/09 RHA DEV00024564 Tool hand, mode  and reversal passed to NC
* 05/03/09 RHA DEV00026198 Use Job data instead of ASK questions
* 18/03/09 RHA DEV00026542 Set turn cycle end extension on
* 19/03/09 RHA DEV00026542 End Style Switching added
* 20/03/09 RHA DEV00026542 Ignore option added for cycle move to start
* 20/03/09 RHA DEV00026063 Add FEEDMODEGCODE to Arc Output
* 26/03/09 RHA DEV00026063 Feed mode settings for hole cycles
* 31/03/09 RHA DEV00025920 Add code constructors for turret parking
* 01/04/09 RHA DEV00025920 Add G30 note to park code constructors
* 02/04/09 RHA DEV00026929 Position token for turret park
* 08/04/09 RHA DEV00027001 Remove BLOCKNUM from FEEDMODEBLOCK calls
* 17/04/09 RHA DEV00027099 Add BMOVE and WORKGCODE to Unpark
* Version 2010.1
* 21/04/09 RHA DEV00027004 Feedrate note for tapping cycles
* 21/04/09 RHA DEV00027171 Correct Y Token availability in turret park
* 21/04/09 RHA DEV00027417 Fix CKEEP initialisation
* 02/06/09 RHA DEV00026691 Correct tooling list for lower turret - merged files
* 09/06/09 RHA WI33885 Templates turn - Add speed value diagnostics
* 15/07/09 RHA WI33455 Add Feed token and TEXT line to threading cycles
* 29/07/09 RHA WI35149 Make LENGTHOFFSET2 token common and use for offset change
* 01/01/09 RHA W36232 2CY fails to process due to corruption of PASS count
* Version 2010.1 SP1
* 14/10/09 RHA W33350 Correct Cycletime tokens in lower turret set up
* 02/11/09 RHA W36663 Remove spindle clamp from non-CY rapid after TC
* 04/11/09 RHA W36693 Rapid feedrate for lower turret
* Version 2010.2
* 11/11/09 RHA W36658 Add new Thread Mill and canned cycle
* 16/11/09 RHA W36658 Thread Mill format table entries
* 18/11/09 RHA W36479 Improve CANCELTLO token availability
* 20/11/09 RHA W36755 Make #MOVE diagnostic available in all CGDs
* 24/11/09 RHA W33740 Improve Exact Stop Handling
* 11/12/09 RHA W34862 Add Finish Turn canned cycle control
* 11/12/09 RHA W36903 Add "Ask Once" to the NC Stlyes > Interactive Startup options
* 18/12/09 RHA W33828 Default thread turn cycles to FEED instead of PITCH
* 04/01/10 RHA W33326 Default XZ Offsets to Constant Offset
* 28/01/10 RHA W35391 Allow control of PITCH sign
* 23/02/10 RHA W37859 Add Use Index switch
* 17/03/10 RHA W36738 Support for mini turrets
* Version 2010.2 SP1
* 25/05/10 RHA W39168 Add After ToolChange option for CY hole pre-position
* Version 2011.1
* 27/05/10 RHA W38292 Add G code Spindle Select token, Okuma and Gneeric ISO
* 28/05/10 RHA W38151 Use specific Format Table refs to allow for Siemens
* 10/06/10 RHA W39535 Move initialisation instructions to common procedure
* 30/06/10 RHA W39830 Cyclsub array, trace option added
* 15/07/10 RHA W39785 Implement tap type setting at toolchange
* 03/08/10 RHA W40229 Add codeconstructor for stop in rough turn cycle
* 10/08/10 RHA W34977 CY milling, more spindle brake control options
* 19/08/10 RHA W32695 Control allowable chamfer for helical hole cycle
* 20/08/10 RHA W40114 Enable force feed at start of turning cycles
* 25/08/10 RHA W36639 Add lengthoffset to tooling data and set up sheet
* 03/09/10 RHA W30985 Divert cyclsub moves for G200
* 06/09/10 RHA W39748 Allow sub spin moves relative to G55 Datum
* 08/09/10 RHA W40572 Ream, Bore, Chipbreak in fixed hole cycles
* 14/09/10 RHA W40572 Tidy token use within each template
* 15/09/10 RHA W40572 Fix Depth/Retract options for non CY machines
* Version 2011.2
* 26/10/10 RHA W41396 Use MAXFEED for Rapid conversion
* 24/11/10 RHA W33253 Add ability to swap CRC codes on lower turret
* 26/11/10 RHA W41396 Commented out pending system implementation
* 30/11/10 RHA W36982 Polar Auto over-ride and new NCStyle tab
* 08/12/10 RHA W41935 Option for cycle approach inside/outside cycle definition
* 09/12/10 RHA W41998 Add peck token to tapping cycle
* 20/12/10 RHA W31031 Add CY_SPEED token to Generic ISO template
* 05/01/11 RHA W30504 Add incremental angles variables
* 05/01/11 RHA W35876 Fix sub spindle offset, split C/Y dialog
* 07/01/11 RHA W35876 Add lower turret main spindle offset
* 10/01/11 RHA W40121 Fix CRC Register in Rapid After Toolchange
* 24/01/11 RHA W35876 Add Lower Turret Main options
* 01/02/11 RHA W41464 Add warning if no Rapid To Toolchange
* 07/02/11 RHA W39505 Allow multi-start canned threads
* 23/02/11 RHA W42941 Re-organise Notes section & add macro number details
* 04/05/11 RHA W44295 Remove incremental angle option from C Axis Functions
* Version 2012.1
* 23/05/11 RHA W43411 Add PECKSAFE token to fixed hole cycles
* 23/05/11 RHA W44087 Allow gear code output for single gear spindles
* 24/05/11 RHA W42981 Find gear when spindle stopped (option)
* 09/06/11 RHA W30605 Implement Rough Profile canned cycle
* 16/06/11 RHA W43720 Clarify helical pitch option text
* 20/06/11 RHA W44888 Correct ;ENDIF use
* 22/06/11 RHA W42241 Selective threadmill canned cycles
* 10/08/11 RHA W43411 Add PECKSAFE token to fixed hole cycles
* 16/08/11 RHA W36919 Add Programmable Tailstock processing
* 17/08/11 RHA W30605 Rough Profile canned cycle incomplete - removed
* 23/08/11 RHA W45835 Implement Tool Offset modifier in linear feed and arc blocks
* 24/08/11 RHA W35149 Modify Tool Offset output for datum change in finish groove cycle
* 30/08/11 RHA W45902 Turret Park variables and tokens
* 06/09/11 RHA W44677 Correct IF TEMPLATE filtering in Format Table
* 06/09/11 RHA W46095 Add option to reverse X, rotary, B axis, B180
* 06/09/11 RHA W45835 Fix offset change format
* 07/09/11 RHA W45412 Force X on Single Block Thread Cycle (Spring cuts)
* 13/09/11 RHA W44677 Correct availability of CMOVE addresses
* 14/09/11 RHA W36919 Programmable Tailstock fixes
* 05/10/11 RHA W36919 Programmable Tailstock token availablity
* Version 2012.2
* 31/10/11 RHA W43616 Implement Swarf Conveyor on/off control
* 01/11/11 RHA W46653 Tailstock movement options
* 01/11/11 RHA W47189 options for G68 datum
* 03/11/11 RHA W47190 Add data and controls for Steadies
* 09/11/11 RHA W46019 Make diametral rounding optional
* 06/12/11 RHA W47635 Stub for G200_SET_REVERSE
* 06/12/11 RHA W47190 Modify code constructor for Steadies
* 21/12/11 RHA W47111 Force GCode after Dwell
* 10/01/12 RHA W44024 Additional Lower Turret code swaps
* 12/01/12 RHA W46019 Remove diametral rounding option
* 14/02/12 RHA W47190 Additional tokens and m/c datum option
* 22/02/12 RHA W49055 Correct Setmodal^#ACLAMP
* 22/02/12 RHA W49022 Remove duplicate token RAPIDGCODE
* 28/02/12 RHA W47190 Use LIST for datum option
* 15/03/12 RHA W39775 Implement Combined Coolant options in CY coolant control
* 22/03/12 RHA W39775 Change defaults to avoid regressions
* 29/03/12 RHA W49819 Expand steady movement options
* Version 2013.1
* 29/05/12 RHA W50179 Phantom warnings
* 29/05/12 RHA W50794 Add SPEED token to thread cycle
* 14/06/12 RHA W47992 & W50538 Separate format address for POLAR_Y on sub spindle
* 11/07/12 RHA W42904 Add Specified Range to Tool Offset options
* 08/08/12 RHA W30772 Add CY_ZSAFE and CY_ZLEVEL tokens to CY hole cycles
* 21/08/12 RHA W30772 Add ZSAFE and ZLEVEL tokens to fixed tool hole cycles
* 28/08/12 RHA W52552 Fix TLO extra options
* 30/08/12 RHA W43286 Support peck tapping via cycle point calls
* 11/09/12 RHA W52351 Correct use of BARPULL_DATUM token
* 25/09/12 RHA W51030 TURRET variable is now correct, discontinue use of PASS which has changed
* 02/10/12 RHA W53107 Correct turret selection in END code constructor
* 03/10/12 RHA W31018 Correct CPL tool tip option for Rapid to Tool Change
* 23/10/12 RHA W53630 Fix to ZMOVE on Sub Spindle, Rapid Home & TC
* Version 2013.2
* 22/03/13 GST W54195 Create NEXT tokens for toolchange parameters
* 25/03/13 GST W54191 Force feed type - implement independet floating x rigid tapping
* 16/05/13 RHA W57969 Add QUADRANT token to Select Offset
* Version 2014.1
* 08/10/13 RHA W56677 Implement new coolant controls
* Version 2014.2
* 14/11/13 RHA W61589 Implement additional turrets
* 19/12/13 RHA W62161 Fix Synch numbering for 2 upper turrets
* 28/01/14 RHA W61589 Correct cycle time and idle tokens for lower turrets
* 05/02/14 RHA W58922 Implement CRC check in rapid moves
* 13/03/14 RHA W55288 Add breakout call to Start and End
* 19/03/14 RHA W64000 Remove duplicate code
* 16/04/14 RHA W55407 Remove FEED token from default Finish turn cycle line
* 27/05/14 RHA W65095 Implement datum Shift in turning
* Version 2015.1
* 17/06/14 RHA W63941 Add XMOVE token to fixed drill cycles and default output
* 17/06/14 RHA W64039 Add CYCLEDWELLTIME token to fixed hole cycles
* 17/06/14 RHA W59059 Add option for Radius on axial helical arcs
* 19/06/14 RHA W65355 Move FEEDGCODE setting to utility procedure
* 17/07/14 RHA W66005 Multiple Turrets - Synchronisation of specific turrets (Templates)
* 17/07/14 RHA W66369 Remove "preview" note from turn datum shift
* 30/07/14 RHA W59462 Add angular precision setting
* 30/07/14 RHA W44710 Implement Caxis Helical Code Constructors
* 05/08/14 RHA W66591 Set output angle formats to 4.3 as default
* 13/08/14 RHA W59059 Improve dialogue layout and Setvar compatibility
* Version 2015.2
* 16/12/14 RHA W80346 Separate set-up sheet for each turret
* 07/01/15 RHA W80786 Correct start end call switch for inactive turrets
* 08/01/15 RHA W35019 Add prog stop and comment to Rapid Home and TC
* 13/01/15 RHA W80937 Temporary removal of %IF #NUMTOOLS lines in START and END - Generator compiler problem.
* 15/01/15 RHA W64264 Improve arc centre descriptions compatibility
* 22/01/15 RHA W80786 Correct start end call switch for inactive turrets
* 12/02/15 RHA W79953 Option to force XZ at canned start/end blocks
* 24/02/15 RHA W35019 Include prog stop in default output
* 18/02/15 RHA W81842 Correct W80786 for merged tape
* 25/02/15 RHA W49417 Correct C_AUTO_STAT token availability
* 04/03/15 RHA W78997 Activate "Use Sequence Max High Feed"
* Version 2016.1
* 28/07/15 RHA ECAM-2341 Implement angle at Tool Change
*
*******************************

* Main Spindle
*	Gcodes
*      1                 10                           20                            30                            40                             50                  60
%DATA1=0.0,1,2,3,4,0,0,0,9,-1,10,11,17,18,19,20,21,33,92,76,40,41,42,50,53,54,55,56,57,58,59,87,-1,-1,83,80,74,74,74,33,85,85,87,97,96,94,95,90,91,98,99,50,-1,-1,0,0,0,0,0,0,1,2,3,73,80,81,82,83,84,85,86,84.1,83,98,99,112,113,-1,-1,-1,-1,-1,0,0,40,41,42,42
*   Mcodes
%DATA2=0,1,2,3,4,5,6,8,8,9,10,11,12,-1,-1,11,10,15,16,17,18,31,32,-1,73,33,34,-1,-1,-1,-1,23,24,98,99,41,42,43,44,0,0,0,0,0,0,0,0,0,0,13,14,15,,,,,,,,51,59,,,,,46,45,74,-1
*
*********************************
*	Gears and Spindle speeds
* numgears,min_rpm1,maxrpm1,usermax1,min_rpm2,max_rpm2,usermax2,....
%DATA3=4,28,140,140,84,420,420,252,1260,1260,756,3780,3780
* Scodes - steps,smin1,smax1,smin2,smax2,.....
%DATA4=0,0,0
*
*********************************
*  Sub Spindle
*	Gcodes
*      1                 10                           20                            30                            40                             50                  60
%DATA5=0,1,2,3,4,0,0,0,9,9,10,11,17,18,19,20,21,32,92,76,40,41,42,50,53,54,55,56,57,58,59,70,71,72,73,80,83,83,83,32,85,86,87,97,96,99,98,90,91,98,99,50,75,74,0,0,0,0,0,0,1,2,3,73,80,81,82,83,84,85,86,84.1,83,98,99,112,113,0,0,0,0,0,0,0,0,40,41,42
*   Mcodes
%DATA6=0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,83,84,17,18,19,30,31,32,33,34,35,36,37,38,80,81,23,24,98,99,41,42,43,44,0,0,0,0,0,0,0,0,0,0,13,14,15
*
%PROCEDURE=NC_STYLE
*
*
*	*************************************************************
*	*	Template Dependant Language extensions for Code Wizard	*
*	*************************************************************
*
****************************************************************
*   Tab Name    :      Debug
****************************************************************
;Setvar^MACRONAMEOP^0^<3052>NC Debug^YESNO^<1255>Generate Macro Calls Trace^-1
MACRONAMEOP=0
;Setvar^$CONDEBUG^0^<3052>NC Debug^YESNO^<395>Generate Code Constructor Trace^-1
$CONDEBUG=0
%IF $CONDEBUG=0 %THEN $CONDEBUG=N

;Setvar^#PROCTRACE^0^<3052>NC Debug^YESNO^<1330>Generate Procedures Trace^-1
#PROCTRACE=0
;Setvar^#PROCTRACE2^1^<3052>NC Debug^YESNO^<3053>Procedure Trace Output^-1
#PROCTRACE2=1
;Setvar^#TRENDS^0^<3052>NC Debug^YESNO^<3054>Procedure Trace - Input Coordinates^-1
#TRENDS=0
;Setvar^#TRSTARTS^0^<3052>NC Debug^YESNO^<3055>Procedure Trace - CPL Initialisation^-1
#TRSTARTS=0
;Setvar^#TRMACHINE^0^<3052>NC Debug^YESNO^<3056>Procedure Trace - Machine Coordinates^-1
#TRMACHINE=0
;Setvar^#TRSPEED^0^<3052>NC Debug^YESNO^<3807>Procedure Trace - Speed Checking^-1
#TRSPEED=0

;Setvar^#TRMODE^0^<3052>NC Debug^YESNO^<3925>Procedure Trace - #MOVE values^-1
#TRMODE=0

;Setvar^#TRCYCLSUB^0^<3052>NC Debug^YESNO^<3969>Procedure Trace - Turning Cycle Array^-1
#TRCYCLSUB=0
;Setvar^#LISTCODE^0^<3052>NC Debug^YESNO^<1391>List NC Code^-1
#LISTCODE=0
%IF #LISTCODE=0 %THEN SILENT=1

*************************************************
*	Tab Name 	:	General G-Codes
*************************************************
;Setvar^DATA1(!RAPIDGCODE)^0.0^<1>G-Codes^REAL^<2>Rapid Traverse^-1
;Setvar^DATA1(!FEEDGCODE)^1^<1>G-Codes^REAL^<3>Linear Interpolation^-1

;Setvar^DATA1(!CIRCGCODE)^2^<1>G-Codes^REAL^<4>Circular Interpolation (CLW)^-1
;Setvar^DATA1(!CIRCGCODE+1)^3^<1>G-Codes^REAL^<5>Circular Interpolation (CCLW)^-1

;Setvar^DATA1(!EXACTGCODE)^9^<1>G-Codes^REAL^<7>Exact Stop^-1
;Setvar^DATA1(!EXACTGCODE+1)^#FUNNY^<1>G-Codes^REAL^<1774>Exact Stop Cancel^-1

;Setvar^DATA1(!UNITSGCODE)^20^<1>G-Codes^REAL^<1621>Inch^-1
;Setvar^DATA1(!UNITSGCODE+1)^21^<1>G-Codes^REAL^<9>Metric^-1

;Setvar^DATA1(!DWELLGCODE)^4^<1>G-Codes^REAL^<6>Dwell^-1
;Setvar^DATA1(!COMPGCODE)^40^<1>G-Codes^REAL^<10>Cutter Compensation Off^-1

;Setvar^DATA1(!COMPGCODE+1)^41^<1>G-Codes^REAL^<11>Cutter Compensation Left^-1
;Setvar^DATA1(!COMPGCODE+2)^42^<1>G-Codes^REAL^<12>Cutter Compensation Right^-1

;Setvar^DATA1(!ABSINCRGCODE)^90^<1>G-Codes^REAL^<13>Absolute Coordinates^-1
;Setvar^DATA1(!ABSINCRGCODE+1)^91^<1>G-Codes^REAL^<14>Incremental Coordinates^-1

;Setvar^DATA1(!FEEDMODEGCODE)^94^<1>G-Codes^REAL^<15>Feed / Minute^-1
;Setvar^DATA1(!FEEDMODEGCODE+1)^95^<1>G-Codes^REAL^<16>Feed / Revolution^-1

;Setvar^DATA1(!CSSGCODE)^97^<1>G-Codes^REAL^<17>Constant Surface Speed Off^-1
;Setvar^DATA1(!CSSGCODE+1)^96^<1>G-Codes^REAL^<18>Constant Surface Speed On^-1

;Setvar^#FORCEAFTERDWELL^0^<1>G-Codes^YESNO^<4193>Force G Code After Dwell^-1
#FORCEAFTERDWELL=0

*************************************************
*	Tab Name 	:	Turning Cycles G-Codes
*************************************************
*	Order produces better panel layout.
;Setvar^DATA1(!SIMPLETURNGCODE)^#FUNNY^<19>Turning Cycles G-Codes^REAL^<21>Simple Turn Cycle^3
;Setvar^DATA1(!RGHTURNGCODE)^#FUNNY^<19>Turning Cycles G-Codes^REAL^<20>Rough Turn Cycle^4
;Setvar^DATA1(!FINTURNGCODE)^87^<19>Turning Cycles G-Codes^REAL^<119>Finish Turn Cycle^-1
;Setvar^DATA1(!SIMPLETURNGCODE+1)^#FUNNY^<19>Turning Cycles G-Codes^REAL^<23>Simple Face Cycle^3
;Setvar^DATA1(!RGHTURNGCODE+1)^#FUNNY^<19>Turning Cycles G-Codes^REAL^<22>Rough Face Cycle^4
* Setvar^#ROUGHPROF1^73^Turning Cycles G-Codes^REAL^Rough Profile Turn Cycle
* Setvar^#ROUGHPROF2^73^Turning Cycles G-Codes^REAL^Rough Profile Face Cycle

;SetController^3^0^<19>Turning Cycles G-Codes^<25>Simple turn canned cycle support ?
;Setvar^#FORCEFEED3^0^<19>Turning Cycles G-Codes^YESNO^<3970>Force Feed at Start (Simple Turn)^-1
#FORCEFEED3=0
;SetController^4^0^<19>Turning Cycles G-Codes^<24>Rough turn canned cycle support ?
* SetController^11^1^Turning Cycles G-Codes^Rough Profile canned cycle support ?
;Setvar^#FORCEFEED4^0^<19>Turning Cycles G-Codes^YESNO^<3971>Force Feed at Start (Rough Turn)^-1
#FORCEFEED4=0
;SetController^5^0^<19>Turning Cycles G-Codes^<3905>Finish turn canned cycle support ?
;Setvar^#FORCEFEED5^0^<19>Turning Cycles G-Codes^YESNO^<3972>Force Feed at Start (Finish Turn)^-1
#FORCEFEED5=0

;Setvar^#STURNTYPE^1^<19>Turning Cycles G-Codes^LIST^<988>Simple Turn Cycle Type^1^<989>^Full Canned Cycle^Single Pass Cycle^^-1
#STURNTYPE=1
;Setvar^#CYCENDMOVE^0^<19>Turning Cycles G-Codes^YESNO^<2502>Cycles Clearance Move at End^-1
#CYCENDMOVE=0
;Setvar^#ENDSTYLE^0^<19>Turning Cycles G-Codes^LIST^<3768>Return to Start^0^<3769>^Ignore^Within Cycle^After Cycle^^-1
#ENDSTYLE=0
;Setvar^#APPROACHIN^2^<19>Turning Cycles G-Codes^LIST^<4037>Approach Contour Start^0^<4038>^Before Cycle Definition^Inside Cycle Definition^None^^-1
#APPROACHIN=2
;Setvar^#OFFSETPAR^0^<19>Turning Cycles G-Codes^YESNO^<3906>Default Offsets to Parallel Value^-1
#OFFSETPAR=0

;Setvar^#FORCESTART^0^<19>Turning Cycles G-Codes^YESNO^<4504>Force Coords in Start block^-1
#FORCESTART=0
;Setvar^#FORCEEND^0^<19>Turning Cycles G-Codes^YESNO^<4505>Force Coords in End block^-1
#FORCEEND=0

*************************************************
*	Tab Name 	:	Turn Hole Cycles
*************************************************
* SetController^9^1^Hole Cycle G-Codes^Drill Canned Cycle ?
;Setvar^#FDRCANNED^0^<3973>Turn Hole Cycles^YESNO^<3974>Support Drill Canned Cycle?^-1
#FDRCANNED=0
;Setvar^#FCHCANNED^0^<3973>Turn Hole Cycles^YESNO^<3975>Support Chipbreak Canned Cycle?^-1
#FCHCANNED=0
;Setvar^#FRMCANNED^0^<3973>Turn Hole Cycles^YESNO^<3976>Support Ream Canned Cycle?^-1
#FRMCANNED=0
;Setvar^#FBRCANNED^0^<3973>Turn Hole Cycles^YESNO^<3977>Support Bore Canned Cycle?^-1
#FBRCANNED=0
;Setvar^#FTPCANNED^0^<3973>Turn Hole Cycles^YESNO^<3978>Support Tap Canned Cycle?^-1
#FTPCANNED=0
;Setvar^#LHFPECKTAP^1^<3973>Turn Hole Cycles^YESNO^<4039>Longhand for Peck Tapping^-1
#LHFPECKTAP=1
;Setvar^DATA1(!DRILLGCODE+1)^74^<3973>Turn Hole Cycles^REAL^<27>Drill Cycle^-1
;Setvar^DATA1(!DRILLGCODE+2)^74^<3973>Turn Hole Cycles^REAL^<520>Counterbore Cycle^-1
;Setvar^DATA1(!DRILLGCODE+3)^74^<3973>Turn Hole Cycles^REAL^<3979>Peck Cycle^-1
;Setvar^DATA1(!DRILLGCODE+4)^33^<3973>Turn Hole Cycles^REAL^<28>Tapping Cycle^-1
;Setvar^DATA1(!DRILLGCODE+5)^85^<3973>Turn Hole Cycles^REAL^<102>Ream / Bore Cycle^-1
;Setvar^DATA1(!DRILLGCODE+6)^85^<3973>Turn Hole Cycles^REAL^<104>Bore Cycle^-1
;Setvar^DATA1(!CHIPBREAKGCODE)^83^<3973>Turn Hole Cycles^REAL^<590>Chipbreak Cycle^-1
;Setvar^#RIGIDTAP^329^<3973>Turn Hole Cycles^REAL^<2147>Rigid Tapping M Code^-1
#RIGIDTAP=329

* Set in C/Y Hole Cycles for CY machines
;Setvar^#ZRABSINCR^1^<3973>Turn Hole Cycles^LIST^<416>Cycle Z depth^1^<787>^Absolute^Incremental signed^Incremental unsigned^^-1
#ZRABSINCR=1
;Setvar^#RETRACTINC^1^<3973>Turn Hole Cycles^LIST^<1799>Hole Cycle Retract Height^1^<3092>^Absolute^Incremental signed^Incremental unsigned^Inc from Level^^-1
#RETRACTINC=1

*************************************************
*	Tab Name 	:	Threading Cycle G-Codes
*************************************************
;Setvar^DATA1(!THREADGCODE)^33^<30>Threading Cycle G-Codes^REAL^<31>Longhand^-1
;Setvar^DATA1(!THREADGCODE+1)^92^<30>Threading Cycle G-Codes^REAL^<32>Single Block Cycle^-1
;Setvar^DATA1(!THREADGCODE+2)^76^<30>Threading Cycle G-Codes^REAL^<33>Canned Cycle^-1
;Setvar^#G76CHECK^0^<30>Threading Cycle G-Codes^LIST^<2772>Check Thread Angle^0^<2773>^No Check^Tool Angle^Approach Angle^Both Angles^^-1
#G76CHECK=0
;Setvar^#ALLOWG76STARTS^0^<30>Threading Cycle G-Codes^YESNO^<4040>Allow Multi-Start Canned Cycles^-1
#ALLOWG76STARTS=0

*************************************************
*	Tab Name 	:	Rapid to Home/Toolchange
*************************************************
;Setvar^#HOMETYPE^1^<990>Rapid to Home/Toolchange G-Codes^YESNO^<991>Output XZ moves on separate blocks^-1
#HOMETYPE=1
;Setvar^DATA1(!HOMEGCODE)^#FUNNY^<990>Rapid to Home/Toolchange G-Codes^REAL^<992>Z Only (X Fixed)^-1
;Setvar^DATA1(!HOMEGCODE+1)^#FUNNY^<990>Rapid to Home/Toolchange G-Codes^REAL^<993>X Only (Z Fixed)^-1
;Setvar^DATA1(!HOMEGCODE+2)^#FUNNY^<990>Rapid to Home/Toolchange G-Codes^REAL^<994>X followed by Z^-1
;Setvar^DATA1(!HOMEGCODE+3)^#FUNNY^<990>Rapid to Home/Toolchange G-Codes^REAL^<995>Z followed by X^-1
;Setvar^DATA1(!HOMEGCODE+4)^#FUNNY^<990>Rapid to Home/Toolchange G-Codes^REAL^<996>XZ Simultaneously^-1

*************************************************
*	Tab Name 	:	Datum G-Codes
*************************************************
;Setvar^DATA1(!PRESETGCODE)^50^<34>Datum G-Codes^REAL^<35>MAX RPM / Preset Registers^-1
;Setvar^DATA1(!WORKGCODE)^53^<34>Datum G-Codes^REAL^<36>Machine Coord System^-1


;Setvar^DATA1(!WORKGCODE+1)^54^<34>Datum G-Codes^REAL^<37>Work Coord System 1^-1


;Setvar^DATA1(!WORKGCODE+2)^55^<34>Datum G-Codes^REAL^<38>Work Coord System 2^-1

;Setvar^DATA1(!WORKGCODE+3)^56^<34>Datum G-Codes^REAL^<39>Work Coord System 3^-1
;Setvar^DATA1(!WORKGCODE+4)^57^<34>Datum G-Codes^REAL^<40>Work Coord System 4^-1
;Setvar^DATA1(!WORKGCODE+5)^58^<34>Datum G-Codes^REAL^<41>Work Coord System 5^-1
;Setvar^DATA1(!WORKGCODE+6)^59^<34>Datum G-Codes^REAL^<42>Work Coord System 6^-1


;Setvar^DATA1(!SETTOOLGCODE)^10^<34>Datum G-Codes^REAL^<43>Set Tool Data^-1

;Setvar^#BASETYPE^0^<34>Datum G-Codes^LIST^<1770>Incremental Datum Shift^0^<4076>^From Current Datum^From Initial Datum^^-1
#BASETYPE=0
;Setvar^#OUTPUTSHIFTS^0^<34>Datum G-Codes^YESNO^<4456>List datum shifts in CALL_DATUMS^-1
#OUTPUTSHIFTS=0


********************************************
*	Tab Name 	:		M-Codes
********************************************
;Setvar^DATA2(!STOPMCODE)^0^<44>M-Codes^REAL^<45>Program Stop^-1
;Setvar^DATA2(!STOPMCODE+1)^1^<44>M-Codes^REAL^<46>Optional Stop^-1

;Setvar^DATA2(!SPINMCODE)^3^<44>M-Codes^REAL^<47>Spindle CLW^-1
;Setvar^DATA2(!SPINMCODE+1)^4^<44>M-Codes^REAL^<48>Spindle CCLW^-1
;Setvar^DATA2(!SPINCOOLMCODE)^#FUNNY^<44>M-Codes^REAL^<50>Spindle CLW with coolant^-1
;Setvar^DATA2(!SPINCOOLMCODE+1)^#FUNNY^<44>M-Codes^REAL^<51>Spindle CCLW with coolant^-1
;Setvar^DATA2(!SPINMCODE+2)^5^<44>M-Codes^REAL^<49>Spindle Stop^-1

;Setvar^#PROGEND^30^<44>M-Codes^REAL^<1972>End of Program^-1
#PROGEND=30

;Setvar^DATA2(!INDEXTURRETMCODE)^17^<44>M-Codes^REAL^<55>Index Turret CLW^-1
;Setvar^DATA2(!INDEXTURRETMCODE+1)^18^<44>M-Codes^REAL^<56>Index Turret CCLW^-1

;Setvar^DATA2(!CHUCKOPENMCODE)^11^<44>M-Codes^REAL^<57>Chuck Open^-1
;Setvar^DATA2(!CHUCKOPENMCODE+1)^10^<44>M-Codes^REAL^<58>Chuck Closed^-1
;Setvar^DATA2(!CHUCKPSIMCODE)^15^<44>M-Codes^REAL^<59>Chuck Pressure High^-1
;Setvar^DATA2(!CHUCKPSIMCODE+1)^16^<44>M-Codes^REAL^<60>Chuck Pressure Low^-1

;Setvar^DATA2(!CONVEYORMCODE)^33^<44>M-Codes^REAL^<63>Swarf Conveyor Off^-1
;Setvar^DATA2(!CONVEYORMCODE+1)^34^<44>M-Codes^REAL^<64>Swarf Conveyor On^-1

;Setvar^DATA2(!THREADCHAMFMCODE)^23^<44>M-Codes^REAL^<1558>Thread Chamfer On^-1
;Setvar^DATA2(!THREADCHAMFMCODE+1)^24^<44>M-Codes^REAL^<1559>Thread Chamfer Off^-1

;Setvar^DATA2(!SUBPROGMCODE)^98^<44>M-Codes^REAL^<69>Subprogram Call^-1
;Setvar^DATA2(!SUBPROGMCODE+1)^99^<44>M-Codes^REAL^<70>Subprogram End^-1

;Setvar^DATA2(!CRELEASE+1)^45^<44>M-Codes^REAL^<1962>Spindle C Axis Joint^-1
;Setvar^DATA2(!CRELEASE)^46^<44>M-Codes^REAL^<1963>Spindle C Axis Release^-1

;Setvar^DATA2(!AIRBLOW)^51^<44>M-Codes^REAL^<1920>Air Blow On, Spindle1^-1
;Setvar^DATA2(!AIRBLOW+1)^59^<44>M-Codes^REAL^<1922>Air Blow Off, Spindle1^-1

;Setvar^DATA2(!PARTCATCHMCODE)^#FUNNY^<44>M-Codes^REAL^<1722>Part Catcher Advance^-1
;Setvar^DATA2(!PARTCATCHMCODE+1)^73^<44>M-Codes^REAL^<1721>Part Catcher Retract^-1

* main spindle clamping
;Setvar^#BRAKELOW^68^<44>M-Codes^REAL^<2835>Spindle Brake Low^-1
#BRAKELOW=68
;Setvar^#BRAKEHIGH^68^<44>M-Codes^REAL^<2836>Spindle Brake High^-1
#BRAKEHIGH=68
;Setvar^#BRAKEOFF^69^<44>M-Codes^REAL^<2087>Spindle Brake Off^-1
#BRAKEOFF=69

;Setvar^#TURRETLEFT^#FUNNY^<44>M-Codes^REAL^<2148>Turret Side Left^-1
#TURRETLEFT=#FUNNY
;Setvar^#TURRETRIGHT^#FUNNY^<44>M-Codes^REAL^<2149>Turret Side Right^-1
#TURRETRIGHT=#FUNNY

;Setvar^DATA2(!EJECTMCODE)^74^<44>M-Codes^REAL^<1964>Eject Part Code^-1
;Setvar^DATA2(!EJECTMCODE+1)^#FUNNY^<44>M-Codes^REAL^<2205>Ejector Retract Code^-1





********************************************
*	Tab Name 	:	Tailstock
********************************************

;Setvar^DATA2(!TAILSTOCKMCODE)^#FUNNY^<457>Tailstock^REAL^<1723>Tailstock Retract^-1
;Setvar^DATA2(!TAILSTOCKMCODE+1)^#FUNNY^<457>Tailstock^REAL^<1724>Tailstock Advance^-1
;Setvar^DATA2(!TAILQUILLMCODE)^#FUNNY^<457>Tailstock^REAL^<67>Tailstock Quill Out^-1
;Setvar^DATA2(!TAILQUILLMCODE+1)^#FUNNY^<457>Tailstock^REAL^<68>Tailstock Quill In^-1


********************************************
*	Tab Name 	:		Coolant
********************************************

;Setvar^#AUTOCOOL^1^<531>Coolant Control^YESNO^<2774>Switch Coolant Automatically^-1
#AUTOCOOL=1
;Setvar^#AUTOTAPOFF^0^<531>Coolant Control^YESNO^<4381>Close Taps at Rapid to TC^-1
#AUTOTAPOFF=0
;Setvar^#AUTOCHUCKFACE^0^<531>Coolant Control^YESNO^<4382>Chuck face Coolant^-1
#AUTOCHUCKFACE=0
;Setvar^#AUTOTURRET^0^<531>Coolant Control^YESNO^<1822>Turret Face Coolant^-1
#AUTOTURRET=0
;Setvar^#AUTOSPINDLE^0^<531>Coolant Control^YESNO^<1820>Through Spindle Coolant^-1
#AUTOSPINDLE=0

********************************************
*	Tab Name 	:		Coolant Flow
********************************************
;Setvar^DATA2(!COOLMCODE+1)^8^<4383>Coolant Flow^REAL^<53>Coolant Mist^-1

;Setvar^DATA2(!COOLMCODE)^8^<4383>Coolant Flow^REAL^<52>Coolant Flood^-1

;Setvar^#AIRCOOL1^10^<4383>Coolant Flow^REAL^<4386>Air Coolant On^-1
#AIRCOOL1=10

;Setvar^DATA2(!COOLMCODE+2)^9^<4383>Coolant Flow^REAL^<54>Coolant Off^-1

********************************************
*	Tab Name 	:		Coolant Through Tool
********************************************
;Setvar^#THROUGHTOOL1ON^278^<4389>Coolant Through Tool^REAL^<4390>Upper Through Tool Coolant      On^-1
#THROUGHTOOL1ON=278
;Setvar^#THROUGHTOOL1HIGH^28^<4389>Coolant Through Tool^REAL^<4391>Upper Through Tool High^-1
#THROUGHTOOL1HIGH=28

;Setvar^#THROUGHTOOL1OFF^279^<4389>Coolant Through Tool^REAL^<4394>Upper Off^-1
#THROUGHTOOL1OFF=279

********************************************
*	Tab Name 	:		Coolant Tap M Codes
********************************************

;Setvar^#CHUCKFACE1ON^#FUNNY^<1974>Coolant Tap M Codes^REAL^<2153>Main Chuck Face Coolant          On^-1
#CHUCKFACE1ON=#FUNNY
;Setvar^#CHUCKFACE1OFF^#FUNNY^<1974>Coolant Tap M Codes^REAL^<2154>   Off^-1
#CHUCKFACE1OFF=#FUNNY
;Setvar^#THROUGHSPIN1ON^278^<1974>Coolant Tap M Codes^REAL^<2155>Main Through Spindle Coolant   On^-1
#THROUGHSPIN1ON=278
;Setvar^#THROUGHSPIN1OFF^279^<1974>Coolant Tap M Codes^REAL^<2154>   Off^-1
#THROUGHSPIN1OFF=279


;Setvar^#TURRETFACE1ON^382^<1974>Coolant Tap M Codes^REAL^<4402>Upper Turret Face Coolant          On^-1
#TURRETFACE1ON=382
;Setvar^#TURRETFACE1OFF^383^<1974>Coolant Tap M Codes^REAL^<2154>   Off^-1
#TURRETFACE1OFF=383


;Setvar^#CHUCKFACE1AIR^616^<1974>Coolant Tap M Codes^REAL^<4398>Main Chuck Face Air^-1
#CHUCKFACE1AIR=616

;Setvar^#TURRETFACE1AIR^618^<1974>Coolant Tap M Codes^REAL^<4400>Upper Turret Face Air^-1
#TURRETFACE1AIR=618

********************************************
*	Tab Name 	:		Miscellaneous controls
********************************************



%ENDM

*
*********************************
*
*  Code Constructors
*
*********************************
*

;
;___________________________________________________________ Macro = 51_____
;
%MACRO=START
#MACRO=51
#EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%CALL=NC_STYLE
#FUNNY=9989999000000::#PI=3.141592
#TRUE=1:#FALSE=0
*
*
************************************************
*	Tab Name 	:		NC File General
*************************************************
;Setvar^NUMBLOCKS^#FUNNY^<383>NC File General^INT^<384>Maximum Program Size (Blocks)^-1
NUMBLOCKS=#FUNNY
;Setvar^NUMCHARS^#FUNNY^<383>NC File General^INT^<385>Maximum Program Size (Characters)^-1
NUMCHARS=#FUNNY
;Setvar^#LEADER^#FUNNY^<383>NC File General^INT^<386>Punch Tape Leader (Nulls)^-1
#LEADER=#FUNNY
;Setvar^#INCHINCR^0.0001^<383>NC File General^REAL^<387>Minimum movement Inches^-1
#INCHINCR=0.0001
;Setvar^#MMINCR^0.001^<383>NC File General^REAL^<388>Minimum movement millimetres^-1
#MMINCR=0.001
;Setvar^#INCRXYZ^0^<383>NC File General^LIST^<389>Coordinate Mode^0^<1552>^Absolute^Incremental^Run Time Switch^^-1
#INCRXYZ=0
;Setvar^#DIAM^2^<383>NC File General^LIST^<390>X Coordinates^1^<782>^Radius^Diameter^^-1
#DIAM=2
;Setvar^#IKDIAM^2^<383>NC File General^LIST^<1557>X Taper Thread Parameters^1^<782>^Radius^Diameter^^-1
#IKDIAM=2
;Setvar^#XMAINREVERSE^0^<383>NC File General^YESNO^<391>Reverse X Axis^-1
#XMAINREVERSE=0
;Setvar^#ZMAINREVERSE^0^<383>NC File General^YESNO^<561>Reverse Z Axis^-1
#ZMAINREVERSE=0
;Setvar^#TLOCOMP^0^<383>NC File General^YESNO^<392>Compensate for Tool Gauge Lengths^-1
#TLOCOMP=0
;Setvar^TEXTCASE^0^<383>NC File General^LIST^<1797>Text Case Output^0^<1798>^Leave as Input^Force UPPER case^Force lower case^^-1
TEXTCASE=0
;Setvar^#QUESTION^2^<383>NC File General^LIST^<3773>Interactive Startup^1^<3907>^Always Ask^Ask if Not Set^Never Ask^Ask Once^^-1
#QUESTION=2
;Setvar^#ONEGEARFLG^0^<383>NC File General^YESNO^<4142>Allow Gear Code Output for Single Gear^-1
#ONEGEARFLG=0
;Setvar^#GEARWHENSTOP^0^<383>NC File General^YESNO^<4143>Find Gear When Spindle Stopped^-1
#GEARWHENSTOP=0

****************************************************************
*   Tab Name    :      Setup Sheet
****************************************************************
;Setvar^#TOOLSHEET^3^<1714>Set Up Sheet^LIST^<393>Output Set-up Sheet^1^<784>^With NC program^Separate File^None^^-1
#TOOLSHEET=3
;Setvar^$NAME^Setup^<1714>Set Up Sheet^STRING^<394>Set-Up / Tooling Sheet Append Name^-1
$NAME=Setup
;Setvar^#SETUPHEAD^0^<1714>Set Up Sheet^YESNO^<1715>Output Setup Header / Trailer^-1
#SETUPHEAD=0
;Setvar^#REMOVEDUPLICATES^0^<1714>Set Up Sheet^YESNO^<783>Suppress Duplicate Tools (Tooling Sheet / List)^-1
#REMOVEDUPLICATES=0



*************************************************
*	Tab Name 	:		Block Numbers
*************************************************
;Setvar^#BNUM^10^<397>Block Numbers^INT^<325>Block Number Start^-1
#BNUM=10
#BNUMSTART=#BNUM
;Setvar^#BNUMINC^10^<397>Block Numbers^INT^<398>Block Number Increment^-1
#BNUMINC=10
;Setvar^#USEBNUM^1^<397>Block Numbers^YESNO^<399>Output Block Numbers^-1
#USEBNUM=1
;Setvar^#BLOCKTMP^0^<397>Block Numbers^INT^<1392>Max Block Number (If reset required)^-1
#BLOCKTMP=0
%IF #USEBNUM=0 @NOMAX
%IF #BLOCKTMP>0 %THEN #USEBNUM=#BLOCKTMP ; Reset level for numbering
@NOMAX
;Setvar^#RESTARTSUBSBNUM^0^<397>Block Numbers^YESNO^<402>Restart Block Numbering in Sub Programs^-1
#RESTARTSUBSBNUM=0
;Setvar^#FORCEBNUM^1^<397>Block Numbers^YESNO^<2093>Force Out For Cycle Subroutines^-1
#FORCEBNUM=1

*************************************************
*	Tab Name 	:		Safe Block Numbers
*************************************************
;Setvar^#USESBNUM^0^<2094>Safe Block Numbers^YESNO^<2095>Output Safe/Toolchange Block Numbers^-1
#USESBNUM=0
;Setvar^#SBNUMCOUNT^1^<2094>Safe Block Numbers^LIST^<2096>Safe Block Number Count^1^<2163>^Independent Increment^Tool Position^With Block Numbers^Increment+Position^^-1
#SBNUMCOUNT=1
;Setvar^#SBNUM^10^<2094>Safe Block Numbers^INT^<325>Block Number Start^-1
#SBNUM=10
;Setvar^#SBNUMINC^10^<2094>Safe Block Numbers^INT^<398>Block Number Increment^-1
#SBNUMINC=10

*************************************************
*	Tab Name 	:		Feed Moves
*************************************************
;Setvar^#FTYPETURN^0^<3775>Feed Moves^LIST^<3776>Feed Type - Static Tools^0^<3777>^Unchanged^Force Feed per Rev^Force Feed per Min^^-1
#FTYPETURN=0
;Setvar^#FTYPETHRD^1^<3775>Feed Moves^LIST^<3778>Feed Type - Static Thread^0^<3777>^Unchanged^Force Feed per Rev^Force Feed per Min^^-1
#FTYPETHRD=1
;Setvar^#EXACTMODE^0^<3775>Feed Moves^LIST^<3908>Exact Stop Mode^0^<3909>^Single Shot^Modal^^-1
#EXACTMODE=0
*************************************************
*	Tab Name 	:		Rapid Traverse
*************************************************
;Setvar^#FEEDRAPIDS^0^<2>Rapid Traverse^YESNO^<403>Convert All Rapids to Feedmoves at Highfeed^-1
#FEEDRAPIDS=0
;Setvar^#USEMAXFEED^0^<2>Rapid Traverse^YESNO^<4082>Use Sequence Max High Feed^-1
#USEMAXFEED=0
;Setvar^#RAPDIST^0^<2>Rapid Traverse^REAL^<405>Convert to Feedmoves if less than ..^-1
#RAPDIST=0

*************************************************
*	Tab Name 	:		Circular Interpolation
*************************************************
;Setvar^#ARCTYPE^1^<406>Circular Interpolation^LIST^<407>Arc Centre type when IJK^1^<785>^Signed Start-Centre^Signed Centre-start^Unsigned Start-Centre^Centre^^-1
#ARCTYPE=1
;Setvar^#USERADS^0^<406>Circular Interpolation^YESNO^<408>Use Radius when possible^-1
#USERADS=0
;Setvar^CIRCLE^1^<406>Circular Interpolation^YESNO^<567>Single Quadrant Interpolation^-1
CIRCLE=1

*************************************************
*	Tab Name 	:		Spindle Brake Control
*************************************************
;Setvar^#BRAKEFORCE1^1^<2837>Spindle Brake Control^YESNO^<3206>Force After ToolChange^-1
#BRAKEFORCE1=1
;Setvar^#BRAKEFORCE2^0^<2837>Spindle Brake Control^YESNO^<3207>Force For Move To ToolChange^-1
#BRAKEFORCE2=0
*
;Setvar^#BRAKESTRAT2^0^<2837>Spindle Brake Control^LIST^<3981>Mill Feed Axial Planar^0^<2839>^Off^Low^High^^-1
#BRAKESTRAT2=0
;Setvar^#BRAKESTRAT2A^3^<2837>Spindle Brake Control^LIST^<3982>Mill Feed Axial Rotary^0^<3983>^Off^Low^High^As Axial Planar^^-1
#BRAKESTRAT2A=3
;Setvar^#BRAKESTRAT2B^3^<2837>Spindle Brake Control^LIST^<3984>Mill Feed Radial Planar^0^<3983>^Off^Low^High^As Axial Planar^^-1
#BRAKESTRAT2B=3
;Setvar^#BRAKESTRAT2C^3^<2837>Spindle Brake Control^LIST^<3985>Mill Feed Radial Rotary^0^<3983>^Off^Low^High^As Axial Planar^^-1
#BRAKESTRAT2C=3
*
;Setvar^#BRAKESTRAT4^0^<2837>Spindle Brake Control^LIST^<2842>Drilling^0^<2839>^Off^Low^High^^-1
#BRAKESTRAT4=0
;Setvar^#BRAKESTRAT6^4^<2837>Spindle Brake Control^LIST^<3209>Rotary Drilling^0^<3210>^Off^Low^High^On Cycle^As Planar^^-1
#BRAKESTRAT6=4
;Setvar^#BRAKESTRAT3^0^<2837>Spindle Brake Control^LIST^<2841>Milling Rapid C^0^<3208>^Off^Low^High^Unchanged^^-1
#BRAKESTRAT3=0
;Setvar^#BRAKESTRAT5^0^<2837>Spindle Brake Control^LIST^<2843>ToolChange^0^<3208>^Off^Low^High^Unchanged^^-1
#BRAKESTRAT5=0
;Setvar^#BRAKESTRAT1^0^<2837>Spindle Brake Control^LIST^<2838>Turning^0^<2839>^Off^Low^High^^-1
#BRAKESTRAT1=0

*************************************************
*	Tab Name 	:		Cutter Compensation
*************************************************
;Setvar^#AUTOREG^2^<411>Cutter Compensation^LIST^<412>Register Number^1^<786>^Maximum Tools + Turret Position^Turret Position^^-1
#AUTOREG=2
;Setvar^#WARNCRC^0^<411>Cutter Compensation^YESNO^<413>Warn if Cutter Compensation used^-1
#WARNCRC=0
;Setvar^#CHECKRAPID^0^<411>Cutter Compensation^YESNO^<4425>Warn if CRC Active on Rapid^-1
#CHECKRAPID=0
;Setvar^#WARNCRC90^0^<411>Cutter Compensation^YESNO^<414>Warn if Lead In not at 90 degrees^-1
#WARNCRC90=0
;Setvar^#WARNCRCARC^1^<411>Cutter Compensation^YESNO^<1653>Warn if CRC changes on arc move^-1
#WARNCRCARC=1


*************************************************
*	Tab Name 	:		CSS Control
*************************************************
;Setvar^#SETCSSNEXT^1^<1725>CSS Control^LIST^<1623>Set CSS conditions^1^<1624>^Next Feed Mode^Current Mode^^-1
#SETCSSNEXT=1
;Setvar^#NOCSSRAD^1^<1725>CSS Control^YESNO^<1726>Suppress Radius in CSS Off block^-1
#NOCSSRAD=1
;Setvar^#NOCSSSPIN^1^<1725>CSS Control^YESNO^<1727>Suppress Speed in CSS Off block^-1
#NOCSSSPIN=1
;Setvar^#CSSRPMCHECK^1^<1725>CSS Control^YESNO^<2192>Check for RPM limit in CSS^-1
#CSSRPMCHECK=1

*************************************************
*	Tab Name 	:		Turret Parking
*************************************************
;Setvar^$UPPERMAIN^P1^<3781>Turret Parking^STRING^<3782>Turret Park Position, Main Upper^-1
$UPPERMAIN=P1
;Setvar^$UPPERSUB^P2^<3781>Turret Parking^STRING^<3783>Turret Park Position, Sub Upper^-1
$UPPERSUB=P2

*************************************************
*	Tab Name 	:		Tool Descriptions
*************************************************
;Setvar^$TOOLLEFT^Left-Hand^<3786>Tool Descriptions^STRING^<3787>Description for Left Hand Tool^-1
$TOOLLEFT=Left-Hand
;Setvar^$TOOLNEUTRAL^Neutral^<3786>Tool Descriptions^STRING^<3788>Description for Neutral Tool^-1
$TOOLNEUTRAL=Neutral
;Setvar^$TOOLRIGHT^Right-Hand^<3786>Tool Descriptions^STRING^<3789>Description for Right Hand Tool^-1
$TOOLRIGHT=Right-Hand
;Setvar^$TOOLSTATIC^Static^<3786>Tool Descriptions^STRING^<3790>Description for Static Tool^-1
$TOOLSTATIC=Static
;Setvar^$TOOLDRIVEN^Driven^<3786>Tool Descriptions^STRING^<3791>Description for Driven Tool^-1
$TOOLDRIVEN=Driven
;Setvar^$TOOLREVYES^Reversed^<3786>Tool Descriptions^STRING^<3792>Description for Reversed Tool^-1
$TOOLREVYES=Reversed
;Setvar^$TOOLREVNO^ ^<3786>Tool Descriptions^STRING^<3793>Description for Non-Reversed Tool^-1
$TOOLREVNO= 

*************************************************
*	Tab Name 	:		Multipoint Tooling
*************************************************
;Setvar^#MPTCHECK^1^<3910>Tool Multipoint^YESNO^<3911>Check Multipoint Angles^-1
#MPTCHECK=1
;Setvar^#MPTCODE^0^<3910>Tool Multipoint^YESNO^<3912>Convert Angle to Code^-1
#MPTCODE=0
;Setvar^#MPTANGINC^6^<3910>Tool Multipoint^INT^<3913>Number of Codes^-1
#MPTANGINC=6
;Setvar^#MPTSTART^1^<3910>Tool Multipoint^REAL^<3914>Code for angle 0^-1
#MPTSTART=1
;Setvar^#MPTCODEINC^3^<3910>Tool Multipoint^REAL^<3915>Code Increment^-1
#MPTCODEINC=3

*************************************************
*	Tab Name 	:		Tool Change
*************************************************

;Setvar^#TOOLRAPWARN^1^<1622>Tool Change^YESNO^<1631>Warn if no Rapid to Tool Change^-1
#TOOLRAPWARN=1

;Setvar^#TCHANGE^6^<1622>Tool Change^INT^<1985>Tool Change Code (M or G)^-1
#TCHANGE=6
;Setvar^#CANCELTLO^49^<1622>Tool Change^INT^<1988>Cancel Tool Length Offset Code^-1
#CANCELTLO=49
;Setvar^#TLOMODAL^0^<1622>Tool Change^YESNO^<3060>Cancel TLO Only if Active^-1
#TLOMODAL=0




#UPPERTYPE=1



;Setvar^#SPINWARN^0^<1622>Tool Change^LIST^<2928>Spindle Stopped Warning^0^<2929>^Never^Feed Moves^All Moves^^-1
#SPINWARN=0
;Setvar^#REFSHIFT^0^<1622>Tool Change^LIST^<1813>Values of ToolChange Home^0^<4309>^Gauge Adjusted Datum^Machine Datum Coords^Current CPL Coords^^-1
#REFSHIFT=0

*************************************************
*	Tab Name 	:		Tool Length Offset
*************************************************
;Setvar^#AUTOTLO^3^<190>Tool Length Offset^LIST^<1986>Length Offset Register^1^<2212>^Max Tools + Turret Position^Turret Position^Last 2 digits^Adjusted Position^^-1
#AUTOTLO=3
;Setvar^#AUTOTLO2^0^<190>Tool Length Offset^LIST^<4302>Length Offset Override^0^<4303>^None^Zero^Specified Range^^-1
#AUTOTLO2=0
* Additional options provided by second list
%IF #AUTOTLO2=1 %THEN #AUTOTLO=5
%IF #AUTOTLO2=2 %THEN #AUTOTLO=6
;Setvar^#MAXREG^0^<190>Tool Length Offset^INT^<4269>Range Maximum Register Number^-1
#MAXREG=0
;Setvar^#DEFAULTREG^0^<190>Tool Length Offset^INT^<4270>Range Default Register Number^-1
#DEFAULTREG=0

;Setvar^#TLOSHIFT^0^<190>Tool Length Offset^REAL^<2213>TLO Register Adjustment^-1
#TLOSHIFT=0


*************************************************
*	Tab Name 	:		Subroutines
*************************************************
;Setvar^#SUBNOSTART^#FUNNY^<417>Subroutines^REAL^<418>Start Subroutine Program Numbers (blank = Progid+1)^-1
#SUBNOSTART=#FUNNY
;Setvar^#INCRSUBNUMBER^10^<417>Subroutines^INT^<580>Increment Subroutine Program Numbers by ...^-1
#INCRSUBNUMBER=10
;Setvar^#INCRSUBS^0^<417>Subroutines^YESNO^<419>Incremental Subroutines coordinates^-1
#INCRSUBS=0
;SetController^32^0^<417>Subroutines^<581>Output Subroutines for Translate ?

*******************************************************************************************
*	Modal Variables
;Setmodal^#GCODE^1^Modal^G-Codes
%OUTPUT-IF-CHANGED=#GCODE
;Setmodal^#PLANEGCODE^1^Modal^Plane G-Codes
%OUTPUT-IF-CHANGED=#PLANEGCODE
;Setmodal^#DRGCODE^1^Modal^Drill G-Codes
%OUTPUT-IF-CHANGED=#DRGCODE
;Setmodal^#MCODE^1^Modal^M-Codes
%OUTPUT-IF-CHANGED=#MCODE
;Setmodal^#GEARMCODE^1^Modal^Gear M-Codes
%OUTPUT-IF-CHANGED=#GEARMCODE
;Setmodal^#XMOVE^1^Modal^X Axis Coordinates
%OUTPUT-IF-CHANGED=#XMOVE
;Setmodal^#ZMOVE^1^Modal^Z Axis Coordinates
%OUTPUT-IF-CHANGED=#ZMOVE
;Setmodal^#IVALUE^1^Modal^Arc I Coordinates
%OUTPUT-IF-CHANGED=#IVALUE
;Setmodal^#JVALUE^1^Modal^Arc J Coordinates
%OUTPUT-IF-CHANGED=#JVALUE
;Setmodal^#KVALUE^1^Modal^Arc K Coordinates
%OUTPUT-IF-CHANGED=#KVALUE
;Setmodal^#RADIUS^0^Modal^Arc Radius
;Setmodal^#SPEED^1^Modal^Spindle Speed
%OUTPUT-IF-CHANGED=#SPEED
*
*
;Setmodal^#DIRECTION^1^Modal^Spindle Direction
%OUTPUT-IF-CHANGED=#DIRECTION
* Setmodal^#COOL^1^Modal^Coolant
;Setvar^#COOLSET^1^<420>Modal^YESNO^<1974>Coolant Tap M Codes^-1
#COOLSET=1
%IF #COOLSET=0 @SKIPCOOL
%OUTPUT-IF-CHANGED=#CHUCKFACE
%OUTPUT-IF-CHANGED=#THROUGHSPIN
%OUTPUT-IF-CHANGED=#TURRETFACE
%OUTPUT-IF-CHANGED=#THROUGHTOOL
@SKIPCOOL
;Setmodal^#COOL^1^Modal^Coolant On/Off
%OUTPUT-IF-CHANGED=#COOL
;Setmodal^#FEED^1^Modal^Feedrates
%OUTPUT-IF-CHANGED=#FEED
;Setmodal^#HCODE^1^Modal^Tool Length Offset
%OUTPUT-IF-CHANGED=#HCODE
* Setmodal^#CANCELCODE^1^Modal^TLO Cancel Code
%IF #TLOMODAL=0 %THEN %ALWAYS-OUTPUT=#CANCELCODE
%IF #TLOMODAL=1 %THEN %OUTPUT-IF-CHANGED=#CANCELCODE
;Setmodal^#COMPGCODE^1^Modal^Cutter Compensation G-Code
%OUTPUT-IF-CHANGED=#COMPGCODE
;Setmodal^#COMPDCODE^1^Modal^Cutter Compensation Register
%OUTPUT-IF-CHANGED=#COMPDCODE
;Setmodal^#RETRACTGCODE^1^Modal^Hole Cycle Return to Rplane
%OUTPUT-IF-CHANGED=#RETRACTGCODE
;Setmodal^DWELL^1^Modal^Dwell Time
%OUTPUT-IF-CHANGED=DWELL
;Setmodal^#RPLANE^1^Modal^Hole Cycle - Rplane
%OUTPUT-IF-CHANGED=#RPLANE
;Setmodal^#DEPTH^1^Modal^Hole Cycle Peck Depth
%OUTPUT-IF-CHANGED=#DEPTH
;Setmodal^#FEEDMODEGCODE^1^Modal^FPR/FPM G-Code
%OUTPUT-IF-CHANGED=#FEEDMODEGCODE
;Setmodal^PITCH^1^Modal^Thread Pitch
%OUTPUT-IF-CHANGED=PITCH
;Setmodal^#CSSGCODE^1^Modal^CSS G Code
%OUTPUT-IF-CHANGED=#CSSGCODE
;Setmodal^#CSSRAD^1^Modal^CSS Radius
%OUTPUT-IF-CHANGED=#CSSRAD

%OUTPUT-IF-CHANGED=#ITAPER,#KTAPER,#DEGR
%OUTPUT-IF-CHANGED=#ITEMP,#KTEMP



******************************************************************
******************************************************************
******************************************************************






%CALL=PT_SET_DEFAULTS ; Initialise variables

*
*
*
*	*****************************************
*	*	Tab Name	:	Program Start		*
*	*****************************************
*
*	Note ! Cannot be a procedure because %SUBROUTINE must be defined in the START or END macros
*
%IF #LTSTART=1 %THEN %CALL=PT_CHECK_CONTENT


;Sequence Definition^<434>Program Start^-1^<899>NC Program General^MT1
;Use Tokens^CALL_TOOLING^CALL_DATUMS^SUBROUTINES^DELETE^BLKNUM^ABS-INC^RAPIDGCODE^XHOME^ZHOME^XTOOL^ZTOOL^COOLANT OFF^COMP OFF^CANCELTLO^UNITSGCODE^FEEDMODEGCODE^PROGID^PROGDESCR^DATE^UKDATE^DAY^MONTH^YEAR^TIME^PROGRAMMER^PROGVERSION^MANREADABLE^LEADER^MACHINENAME^PARTNAME^SEQUENCENAME^CYCLETIME^IDLE1^TURRETNAME^G54ZOFFSET^G54XOFFSET^JM-DESC^JM-COM^JM-FAM^JM-MACH^JM-CUST^JM-PROG^JM-MATL^JM-REV^LBRKT^RBRKT^MAINDATUMTOCHUCKFACE^MAXRPM-MAIN^MAIN_CHUCK_NAME^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^(^[PARTNAME]^)
;Default Sequence^[DELETE]^[BLKNUM]^ G54
;Default Sequence^[DELETE]^[BLKNUM]^ G95 G96 S0
;Default Sequence^[DELETE]^[BLKNUM]^ G58 X0. Z0.
;TEXT^Use CALL_DATUMS token to output the Work Datum Loop
;TEXT^Use CALL_TOOLING token to output the Tooling Set Up Loop
<([PARTNAME])>
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39] G54>
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39] G95 G96 S0>
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39] G58 X0. Z0.>






* Default Sequence^ (^[PROGDESCR]^)

*




@END_PROG_START
%IF #SUBNOSTART=#FUNNY %THEN #SUBNOSTART=#PROGID	; If user has not specified subroutine start number, use Progid+1 etc.



%ENDM
;
;___________________________________________________________ Macro = 58_____
;
%MACRO=END
#MACRO=58
#EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT

*
*	*****************************************
*	*	Tab Name	:	Program End			*
*	*****************************************
*
*	Note ! Cannot be a procedure because %SUBROUTINE must be defined in the START or END macros

%IF #LTSTART=1 %THEN %CALL=PT_CHECK_CONTENT



%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Program End	*****>
@NO_CON-DEBUG

;Sequence Definition^<435>Program End^-1^<899>NC Program General^MT1
;Use Tokens^CALL_TOOLING^CALL_DATUMS^SUBROUTINES^WARNCOUNT^DELETE^BLKNUM^PROGEND^RAPIDGCODE^XHOME^ZHOME^XTOOL^ZTOOL^G92X_RETURN^G92Z_RETURN^COOLANT OFF^TURRETNO^FIRSTTOOL^PROGDESCR^TIME^DATE^UKDATE^DAY^MONTH^YEAR^PROGRAMMER^PROGVERSION^PROGID^MACHINENAME^PARTNAME^SEQUENCENAME^CYCLETIME^IDLE1^JM-DESC^JM-COM^JM-FAM^JM-MACH^JM-CUST^JM-PROG^JM-MATL^JM-REV^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[PROGEND]
;Default Sequence^%
;Default Sequence
;TEXT^WARNCOUNT ouputs a message if the NC has warnings or errors
;TEXT^Use CALL_DATUMS token to output the Work Datum Loop
;TEXT^Use CALL_TOOLING token to output the Tooling Set Up Loop
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#PROGEND=36]>
<%>






%GOTO @END
@END
%ENDM

*
*********************************
*
*  Format Table
*
; Note the order of the first 15 lines should not be changed to
; preserve the integrity of hard coded entries on items 10-14
*********************************
*

%FORMAT
 X,3,4,640,4,3,640, ; 0   (!FT_XMOVE)        X Move
 Y,3,4,640,4,3,640, ; 1   (!FT_YMOVE)        Y Move
 Z,3,4,640,4,3,640, ; 2   (!FT_ZMOVE)        Z Move
 I,3,4,640,4,3,640, ; 3   (!FT_IMOVE)        I Arc
 J,3,4,640,4,3,640, ; 4   (!FT_JMOVE)        J Arc
 K,3,4,640,4,3,640, ; 5   (!FT_KMOVE)        K Arc
 R,3,4,640,4,3,640, ; 6   (!FT_ARCRAD)       Arc Radius
 F,4,4,640,4,3,640, ; 7   (!FT_FEED)         Feed Code
 S,4,0,0,4,0,0,     ; 8   (!FT_SPEED)        Speed Code
 S,4,0,0,4,0,0,     ; 9   (!FT_SPEED1)       Max Speed Code
,0,0,0,0,0,0,       ; 10  (!FT_NULL)         Null output format
,4,3,10,4,3,10,     ; 11  (!FT_INTSETUP)     Set-up Sheet (Integers)
,4,3,2052,4,3,2052, ; 12  (!FT_REALSETUP)    Set-up Sheet (Reals)
,3,4,0,4,3,0,       ; 13  (!FT_DEBUGREAL)    Variable trace Real
,3,4,0,4,3,0,       ; 14  (!FT_DEBUGINT)     Variable trace Integer
 R,3,4,640,4,3,640, ; 15  (!FT_RMOVE)        Radius for CSS setting
 X,1,3,20,1,3,20,   ; 16  (!FT_DWELL)        Dwell Time
 T,2,0,0,2,0,0,     ; 17  (!FT_TPOSN)        Turret Position
 T,2,0,1,2,0,1,     ; 18  (!FT_TPOSNREP)     Repeat Turret Position
 T,4,0,1,4,0,1,     ; 19  (!FT_ATCPOSN)      ATC Position
 T,2,0,1,2,0,1,     ; 20  (!FT_NEXTPOSN)     Next Turret Position
 T,4,0,1,4,0,1,     ; 21  (!FT_NEXTATCPOSN)  Next ATC Position
 S,3,0,0,3,0,0,     ; 22  (!FT_MPOINT)       Multipoint Tool Index
 M,3,0,0,3,0,0,     ; 23  (!FT_TSCODE)       Turret Side Codes
 G43 H,2,0,1,2,0,1, ; 24  (!FT_TLONO)        Tool Length Offset
,2,0,1,2,0,1,       ; 25  (!FT_TLONO3)       Change Length Offset
,2,0,1,2,0,1,       ; 26  (!FT_TLONO2)       Tool Length Offset 2nd Format
,2,0,1,2,0,1,       ; 27  (!FT_TLONO4)       Change Length Offset 2nd Format
 M,3,0,0,3,0,0,     ; 28  (!FT_TCHANGE)      Tool Change Code
 G,2,0,0,2,0,0,     ; 29  (!FT_CANCELTLO)    Cancel Tool Length Offset
 D,2,0,0,2,0,0,     ; 30  (!FT_CRCNO)        Cutter Compensation Register
O,4,0,21,4,0,21,    ; 31  (!FT_PROGID)       Main NC Program Number
:,4,0,21,4,0,21,    ; 32  (!FT_SUBID)        Subprogram Number
 P,4,0,21,4,0,21,   ; 33  (!FT_SUBCALL)      Subprogram Call
 P,4,0,0,4,0,0,     ; 34  (!FT_SSNUM)        Subroutine Block No. Start
 Q,4,0,0,4,0,0,     ; 35  (!FT_SENUM)        Subroutine Block No. End
 M,3,0,0,3,0,0,     ; 36  (!FT_MCODE)        Miscellaneous "M" Codes
 M,3,0,0,3,0,0,     ; 37  (!FT_GMCODE)       Gear "M" Codes
 G,2,0,1,2,0,1,     ; 38  (!FT_GCODE)        Preparatory "G" Codes
N,4,0,0,4,0,0,      ; 39  (!FT_BLKNUM)       Block Number
O,4,0,0,4,0,0,      ; 40  (!FT_SAFEBLKNUM)   Safe / Tool Block No.
 G,2,0,0,2,0,0,     ; 41  (!FT_WORKGCOORD)   Work Coord System / Fixture offset
 T,4,0,1,4,0,1,     ; 42  (!FT_LIST_TUR)     Tool List Turret Number
/,0,0,0,0,0,0,      ; 43  (!FT_DELETE)       Block Delete / Skip
 G,2,0,1,2,0,1,     ; 44  (!FT_GCYCLE)       Turn Hole Cycles - G Code
 Z,3,4,640,4,3,640, ; 45  (!FT_ZCYCLE)       Turn Hole Cycles - Z Depth
 F,4,2,640,4,2,640, ; 46  (!FT_FCYCLE)       Turn Hole Cycles - Feedrate
 S,4,0,0,4,0,0,     ; 47  (!FT_SCYCLE)       Turn Hole Cycles - Speed Code
 P,4,0,0,4,0,0,     ; 48  (!FT_DWCYCLE)      Turn Hole Cycles - Dwell Time
 Q,3,4,640,4,3,640, ; 49  (!FT_OFFCYCLE)     Turn Hole Cycles - Bore Stand-off
 Q,3,4,640,4,3,640, ; 50  (!FT_PECKCYCLE)    Turn Hole Cycles - Peck Depth
 Q,3,4,20,4,3,20,   ; 51  (!FT_PECKCYCLE2)   Turn Hole Cycles - Peck Safe Distance
 D,3,4,640,4,3,640, ; 52  (!FT_DEGCYCLE)     Turn Hole Cycles - Degression
 Z,3,4,640,4,3,640, ; 53  (!FT_CLEARCYCLE)   Turn Hole Cycles - Z Clear
 Z,3,4,128,4,3,128, ; 54  (!FT_ZSAFE)        Z Safe Distance
 ,3,4,576,4,3,576,  ; 55  (!FT_ZLEVEL)       Turn Hole Cycles - Z Level
 R,3,4,640,4,3,640, ; 56  (!FT_RETRACTCYCLE) Turn Hole Cycles - Retract plane
 F,2,4,128,2,4,128, ; 57  (!FT_PITCHCYCLE)   Turn Hole Cycles - Thread Pitch
 G,2,0,1,2,0,1,     ; 58  (!FT_GCODETSET)    Tooling Data - G Code
 P,4,0,0,4,0,0,     ; 59  (!FT_LOOPTSET)     Tooling Data - Loop Number
 R,3,4,640,4,3,640, ; 60  (!FT_RADTSET)      Tooling Data - Tool Radius
 U,3,4,640,4,3,640, ; 61  (!FT_DIATSET)      Tooling Data - Tool Diameter
 Z,3,4,640,4,3,640, ; 62  (!FT_ZGAUGETSET)   Tooling Data - Zgauge Length
 X,3,4,640,4,3,640, ; 63  (!FT_XGAUGETSET)   Tooling Data - Xgauge Length
 I,3,4,640,4,3,640, ; 64  (!FT_TNRXTSET)     Tooling Data - Nose Rad X
 K,3,4,640,4,3,640, ; 65  (!FT_TNRZTSET)     Tooling Data - Nose Rad Z
 A,1,0,0,1,0,0,     ; 66  (!FT_QUAD)         Tooling Data - Tool Quadrant
 R,3,4,640,4,3,640, ; 67  (!FT_CSSRAD)       Tooling Data - CSS Start Radius
 ,3,4,0,4,3,0,      ; 68  (!FT_OFFC)         Constant Parallel Offset
 U,3,4,0,4,3,0,     ; 69  (!FT_OFFX)         Stock Offset X
 W,3,4,0,4,3,0,     ; 70  (!FT_OFFZ)         Stock Offset Z
 U,3,4,0,4,3,0,     ; 71  (!FT_OFFXDIA)      Stock Offset X(Diam)
 U,3,4,640,4,3,640, ; 72  (!FT_DOCTFCYC)     Turn/Face Cycles Depth of Cut
 I,3,4,20,4,3,20,   ; 73  (!FT_DOCTCYC)      Turn Cycles Depth of Cut
 K,3,4,20,4,3,20,   ; 74  (!FT_DOCFCYC)      Face Cycles Depth of Cut
 X,3,4,640,4,3,640, ; 75  (!FT_XSTART)       X Cycle Start point
 Z,3,4,640,4,3,640, ; 76  (!FT_ZSTART)       Z Cycle Start point
 R,3,4,128,4,3,128, ; 77  (!FT_CHPTCYC)      Simple Turn - Chip Break
 Q,3,4,128,4,3,128, ; 78  (!FT_CHPFCYC)      Simple Turn - Chip Break (Face)
 R,3,4,128,4,3,128, ; 79  (!FT_XSAFE)        X Safe Distance
 Z,3,4,128,4,3,128, ; 80  (!FT_ZSAFE)        Z Safe Distance
 I,2,4,128,2,4,128, ; 81  (!FT_ITAPER)       Thread X Taper
 K,2,4,128,2,4,128, ; 82  (!FT_KTAPER)       Thread Z Taper
 P,3,4,640,4,3,640, ; 83  (!FT_TOTDOCTHRD)   Thread Total Depth of Cut
 Q,3,4,640,4,3,640, ; 84  (!FT_STARTDEPTH)   Thread Start Depth of Cut
 Q,3,4,640,4,3,640, ; 85  (!FT_FINALDEPTH)   Thread Final Depth of Cut
 R,3,4,640,4,3,640, ; 86  (!FT_SPRINGDEPTH)  Thread Spring Depth of Cut
,2,4,0,2,4,0,       ; 87  (!FT_ANGTHRD)      Thread  Angle
 P,2,0,1,2,0,1,     ; 88  (!FT_SPRINGTHRD)   Thread No. of Spring Cuts
 N,2,0,1,2,0,1,     ; 89  (!FT_STARTSTHRD)   Thread No. of Starts
 N,2,0,1,2,0,1,     ; 90  (!FT_NPASSTHRD)    Thread No. of Passes
 Q,3,4,640,4,3,640, ; 91  (!FT_MINDOCTHRD)   Thread Min. Depth of Cut
 ,3,4,640,4,3,640,  ; 92  (!FT_CHASEANGTHRD) Thread Chase Angle
,2,0,1,2,0,1,       ; 93  (!FT_PSTYLE)       Thread Pull Out Distance
 U,4,3,640,3,4,640, ; 94  (!FT_UZERO)        Rapid Home - U0
 W,4,3,640,3,4,640, ; 95  (!FT_WZERO)        Rapid Home - W0
,3,4,0,4,3,0,       ; 96  (!FT_USER-1)       User Numeric Token 1
,3,4,0,4,3,0,       ; 97  (!FT_USER-2)       User Numeric Token 2
,3,4,0,4,3,0,       ; 98  (!FT_USER-3)       User Numeric Token 3
,3,4,0,4,3,0,       ; 99  (!FT_USER-4)       User Numeric Token 4
,3,4,0,4,3,0,       ; 100 (!FT_USER-5)       User Numeric Token 5
,3,4,0,4,3,0,       ; 101 (!FT_USER-6)       User Numeric Token 6
,3,4,0,4,3,0,       ; 102 (!FT_USER-7)       User Numeric Token 7
,3,4,0,4,3,0,       ; 103 (!FT_USER-8)       User Numeric Token 8
,3,4,0,4,3,0,       ; 104 (!FT_USER-9)       User Numeric Token 9
,3,4,0,4,3,0,       ; 105 (!FT_USER-10)      User Numeric Token 10
,3,4,0,4,3,0,       ; 106 (!FT_USER-11)      User Numeric Token 11
,3,4,0,4,3,0,       ; 107 (!FT_USER-12)      User Numeric Token 12
,3,4,0,4,3,0,       ; 108 (!FT_USER-13)      User Numeric Token 13
,3,4,0,4,3,0,       ; 109 (!FT_USER-14)      User Numeric Token 14
,3,4,0,4,3,0,       ; 110 (!FT_USER-15)      User Numeric Token 15
,3,4,0,4,3,0,       ; 111 (!FT_USER-16)      User Numeric Token 16
,3,4,0,4,3,0,       ; 112 (!FT_USER-17)      User Numeric Token 17
,3,4,0,4,3,0,       ; 113 (!FT_USER-18)      User Numeric Token 18
,3,4,0,4,3,0,       ; 114 (!FT_USER-19)      User Numeric Token 19
,3,4,0,4,3,0,       ; 115 (!FT_USER-20)      User Numeric Token 20
,3,4,0,3,4,0,       ; 116 (!FT_TSTORE1)      User ToolStore Token 1
,3,4,0,3,4,0,       ; 117 (!FT_TSTORE2)      User ToolStore Token 2
,8,0,0,8,0,0,       ; 118 (!FT_TSTORE3)      Tool Group Number
,8,0,0,8,0,0,       ; 119 (!FT_TSTORE4)      Tool ID Number
%ENDF
*
*********************************
*
*  Code Constructors
*
*********************************
*

%PROCEDURE=SETUP_HEADER


;Sequence Definition^<1716>Set-Up Header^-1^<2038>Set Up sheet^
;Use Tokens^PROGID^PROGDESCR^DATE^UKDATE^DAY^MONTH^YEAR^TIME^PROGRAMMER^PROGVERSION^MACHINENAME^PARTNAME^SEQUENCENAME^CYCLETIME^IDLE1^TURRETNAME^JM-DESC^JM-COM^JM-FAM^JM-MACH^JM-CUST^JM-PROG^JM-MATL^JM-REV^MAINDATUMTOCHUCKFACE^MAIN_CHUCK_NAME^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20^MAIN_CHUCK_NAME
;Default Sequence^_____________________________________________________________________________
;Default Sequence
;Default Sequence^                     Machine Tool Set Up Details
;Default Sequence^_____________________________________________________________________________
;Default Sequence
;Default Sequence^                    Job Description     ^[JM-DESC]
;Default Sequence^                                        ^[JM-COM]
;Default Sequence
;Default Sequence^                    Machine             ^[JM-MACH]
;Default Sequence
;Default Sequence^     Total Machining Time (including Toolchange) : ^[CYCLETIME]^ Minutes
;Default Sequence^     Idle Time            (including Toolchange) : ^[IDLE1]^ Minutes
;Default Sequence
;Default Sequence
;Default Sequence^Tools used in this program
;Default Sequence^.
;TEXT^This Code Constructor is only called if selected in SET UP SHEET (NC Style) tab
<_____________________________________________________________________________>
< >
<                     Machine Tool Set Up Details>
<_____________________________________________________________________________>
< >
<                    Job Description     [JOBDESC]>
<                                        [JOBCOM]>
< >
<                    Machine             [JOBMACH]>
< >
<     Total Machining Time (including Toolchange) : [MACHTIME1=12] Minutes>
<     Idle Time            (including Toolchange) : [IDLE1=12] Minutes>
< >
< >
<Tools used in this program>
<.>









%ENDM
*
*
%PROCEDURE=SETUP_TRAILER


;Sequence Definition^<1717>Set-Up Trailer^-1^<2038>Set Up sheet^
;Use Tokens^PROGID^PROGDESCR^DATE^UKDATE^DAY^MONTH^YEAR^TIME^PROGRAMMER^PROGVERSION^MACHINENAME^PARTNAME^SEQUENCENAME^CYCLETIME^IDLE1^TURRETNAME^JM-DESC^JM-COM^JM-FAM^JM-MACH^JM-CUST^JM-PROG^JM-MATL^JM-REV^MAINDATUMTOCHUCKFACE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^_____________________________________________________________________________
;Default Sequence^.
;Default Sequence^                    Programmed By       ^[JM-PROG]^              Date           : ^[DATE]
;Default Sequence^ End of setup Sheet
;Default Sequence^
<_____________________________________________________________________________>
<.>
<                    Programmed By       [JOBPROG]              Date           : [DATE]>
< End of setup Sheet>





*IF TEMPLATE=2AXLATHE^2CXLATHE^2CYLATHE
*ENDIF



%ENDM
*
*	*************************************************
*	*	Tab Name	:	Set-Up / Tooling Sheet		*
*	*************************************************
*
%PROCEDURE=CODECON_SET-UP-SHEET
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Set-Up / Tooling Sheet	*****>
@NO_CON-DEBUG

*
* Setup sheet header if requested (not in loop)
%IF #SETUPHEAD=1 %THEN %CALL=SETUP_HEADER
*
*	Loop must be embedded since set up sheet is "topped & tailed"
*
#HEADER=1
%IF #TAPEOUTPUT<>0 @HEADER

%IF TURRET=0 %THEN #NUMTOOLS=NUMTOOLS %ELSE #NUMTOOLS=NUMTOOLS1
*
@HEADER              ;output header at top of cnc file
%LOAD=#HEADER
*<Turret = [TURRET=23]>
*	Remove duplicate tools from Tool Sheet
%IF #REMOVEDUPLICATES=#FALSE @MISS_REMOVE_DUPLICATES
#TMP1=#FALSE:%CALL=PT_REMOVE_DUPLICATE_TOOLS:%IF #TMP1=#TRUE @SKIP
%LOAD=#HEADER
@MISS_REMOVE_DUPLICATES
*
%IF TOOLUNIT=0 %THEN $UNIT=IN %ELSE $UNIT=MM
#TOOLDIA=2*TOOLRAD
%IF TOOLNUM=0 %THEN $TOOLDESCRIPTION=USERDEFINEDSTRING %ELSE $TOOLDESCRIPTION=TOOLDESCRIPTION
%IF TOOLZSET=#FUNNY %THEN TOOLZSET=0				;	If Gauge Length unset then force zero
%IF TOOLXSET=#FUNNY %THEN TOOLXSET=0
%CALL=GET_QUADRANT
*
*
;Sequence Definition^<2041>Set-Up Tooling List^-1^<2038>Set Up sheet^
;Use Tokens^HDR-TURRETNO^TOOLDESCR^COMMENT^HDR-TOOLZGAUGE^HDR-TOOLXGAUGE^HDR-LENGTHOFFSET^HDR-NOSERAD^TOOLUNITS^CORNER^REACH^TSTORE_USER1^TSTORE_USER2^TSTORE_STRING1^TSTORE_STRING2^TOOL_GROUP^TOOL_GROUP_NUMBER^TOOL_GROUP_TEXT^TOOL_ID^TOOL_ID_NUMBER^TOOL_ID_TEXT^MPOINT_INDEX^MPOINT_NAME^HOLDER_TYPE^TOOL_HAND^TOOL_REVERSE^TOOL_MODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^Turret No. :^[HDR-TURRETNO]^ ZSet : ^[HDR-TOOLZGAUGE]^XSet : ^[HDR-TOOLXGAUGE]^Description : ^[TOOLDESCR]
<Turret No. :[POSITION=11] ZSet : [TOOLZSET=12]XSet : [TOOLXSET=12]Description : [$TOOLDESCRIPTION]>




@SKIP
#HEADER=#HEADER+1:%IF #HEADER<=#NUMTOOLS @HEADER  ;check number of tools used
*
* Setup sheet trailer if selected (not in loop)
%IF #SETUPHEAD=1 %THEN %CALL=SETUP_TRAILER

%ENDM
*
*	*************************************************
*	*	Tab Name	:	Set Tooling Data			*
*	*************************************************
*
%PROCEDURE=CODECON_SET-TOOLING-DATA
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Set Tooling Data	*****>
@NO_CON-DEBUG

;Sequence Definition^<437>Set Tooling Data List^-1^<899>NC Program General^
;Use Tokens^DELETE^BLKNUM^SETTOOLGCODE^LIST-TURRETNO^TOOLDESCR^COMMENT^CORNER^REACH^XGAUGELENGTH^ZGAUGELENGTH^HDR-LENGTHOFFSET^NOSERAD-X^NOSERAD-Z^LOOPNUMBER^QUADRANT^TOOLUNITS^TSTORE_USER1^TSTORE_USER2^TSTORE_STRING1^TSTORE_STRING2^TOOL-ANGLE^TOOL_GROUP^TOOL_GROUP_NUMBER^TOOL_GROUP_TEXT^TOOL_ID^TOOL_ID_NUMBER^TOOL_ID_TEXT^MPOINT_INDEX^MPOINT_NAME^HOLDER_TYPE^TOOL_HAND^TOOL_REVERSE^TOOL_MODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[SETTOOLGCODE]^[LIST-TURRETNO]^[XGAUGELENGTH]^[ZGAUGELENGTH]^[NOSERAD-X]^[NOSERAD-Z]
%CALL=PT_BINC
#SETTOOLGCODE=DATA1(11)
#XGAUGE=TOOLXSET
#ZGAUGE=TOOLZSET
<[#DELETE=43][#BNUM=39][#SETTOOLGCODE=58][POSITION=42][#XGAUGE=63][#ZGAUGE=62][#TNRX=64][#TNRZ=65]>



@END
%ENDM

*	*************************************************
*	*	Tab Name	:	SET WORK DATUMS					*
*	*************************************************
*
%PROCEDURE=CODECON_SET-WORK-DATUMS

%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Set Work Datums	*****>
@NO_CON-DEBUG

;Sequence Definition^<2054>Set Work Datum List^-1^<899>NC Program General^
;Use Tokens^DELETE^BLKNUM^WORKGCODE^WORKREGISTER^CPLNAME^XABSORIGIN^YABSORIGIN^ZABSORIGIN^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^ G10^ L2^[WORKREGISTER]^[XABSORIGIN]^[YABSORIGIN]^[ZABSORIGIN]^ (^[CPLNAME]^)
%CALL=PT_BINC
#XSUB1=#XSUB*#BREFDIAM
<[#DELETE=43][#BNUM=39] G10 L2[#COORDNUM=59][#XSUB1=0][#YSUB=1][#ZSUB=2] ([GROUPDESCRIPTION])>




%ENDM
*
*	*****************************************
*	*	Tab Name	:	Rapid Move			*
*	*****************************************
*
%PROCEDURE=CODECON_RAPID-MOVE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rapid Move	*****>
@NO_CON-DEBUG

;Sequence Definition^<438>Rapid Move^-1^<902>General Motion^
;Use Tokens^DELETE^BLKNUM^RAPIDGCODE^XMOVE^ZMOVE^COOLANT^SPEED^GEARMCODE^CSSGCODE^CSSRAD^FEED^FEEDMODEGCODE^WORKGCODE^COMPGCODE^CRC REGISTER^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[RAPIDGCODE]^[XMOVE]^[ZMOVE]
%CALL=PT_BINC
#GCODE=DATA1(1)
<[#DELETE=43][#BNUM=39][#GCODE=38][#XMOVE=0][#ZMOVE=2]>





%CALL=HOLD
@END
%ENDM
*
*	*********************************************
*	*	Tab Name	:	Linear Interpolation	*
*	*********************************************
*
%PROCEDURE=CODECON_LINEAR-INTERPOLATION
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Linear Interpolation	*****>
@NO_CON-DEBUG

;Sequence Definition^<3>Linear Interpolation^-1^<902>General Motion^
;Use Tokens^DELETE^BLKNUM^FEEDGCODE^XMOVE^ZMOVE^COMPGCODE^CRC REGISTER^FEED^COOLANT^SPEED^CSSGCODE^CSSRAD^SPINDIR^GEARMCODE^FEEDMODEGCODE^REPEAT_TURRETNO^CHANGEOFFSET^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[FEEDGCODE]^[COMPGCODE]^[XMOVE]^[ZMOVE]
%CALL=PT_BINC
%CALL=SET_FEEDGCODE
<[#DELETE=43][#BNUM=39][#GCODE=38][#COMPGCODE=38][#XMOVE=0][#ZMOVE=2]>
%CALL=PT_SET_CRC_ACTIVE





%CALL=HOLD
@END
%ENDM
*
*	*************************************************
*	*	Tab Name	:	Circular Interpolation Clw	*
*	*************************************************
*
%PROCEDURE=CODECON_CIRCULAR-INT-CLW
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Circular Interpolation Clw	*****>
@NO_CON-DEBUG



;Sequence Definition^<439>Circular Interpolation CLW^-1^<902>General Motion^
;Use Tokens^DELETE^BLKNUM^CLWGCODE^XARCEND^ZARCEND^IVALUE^KVALUE^ARCRADIUS^XCENTRE^ZCENTRE^COMPGCODE^CRC REGISTER^SPEED^COOLANT^CSSGCODE^CSSRAD^SPINDIR^GEARMCODE^FEED^FEEDMODEGCODE^REPEAT_TURRETNO^CHANGEOFFSET^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[FEEDMODEGCODE]^[COMPGCODE]^[CLWGCODE]^[XARCEND]^[ZARCEND]^[<C>IVALUE]^[<C>KVALUE]^[ARCRADIUS]^[FEED]^[SPEED]^[COOLANT]
%CALL=PT_BINC
%CANCEL=#IVALUE
%CANCEL=#KVALUE
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#FEEDMODEGCODE=38][#COMPGCODE=38][#GCODE=38][#XMOVE=0][#ZMOVE=2][#IVALUE=3][#KVALUE=5][#RADIUS=6][#FEED=7][#SPEED=8][#COOL=36]>
#FEEDMODEHOLD=#FEEDMODEGCODE
%CALL=PT_SET_CRC_ACTIVE
#COOLHOLD=#COOL




%CALL=HOLD
@END
%ENDM
*
*	*************************************************
*	*	Tab Name	:	Circular Interpolation CClw	*
*	*************************************************
*
%PROCEDURE=CODECON_CIRCULAR-INT-CCLW
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Circular Interpolation CCLw	*****>
@NO_CON-DEBUG


;Sequence Definition^<440>Circular Interpolation CCLW^-1^<902>General Motion^
;Use Tokens^DELETE^BLKNUM^CCLWGCODE^XARCEND^ZARCEND^IVALUE^KVALUE^ARCRADIUS^XCENTRE^ZCENTRE^COMPGCODE^CRC REGISTER^SPEED^COOLANT^CSSGCODE^CSSRAD^SPINDIR^GEARMCODE^FEED^FEEDMODEGCODE^REPEAT_TURRETNO^CHANGEOFFSET^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[FEEDMODEGCODE]^[COMPGCODE]^[CCLWGCODE]^[XARCEND]^[ZARCEND]^[<C>IVALUE]^[<C>KVALUE]^[ARCRADIUS]^[FEED]^[SPEED]^[COOLANT]
%CALL=PT_BINC
%CANCEL=#IVALUE
%CANCEL=#KVALUE
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#FEEDMODEGCODE=38][#COMPGCODE=38][#GCODE=38][#XMOVE=0][#ZMOVE=2][#IVALUE=3][#KVALUE=5][#RADIUS=6][#FEED=7][#SPEED=8][#COOL=36]>
#FEEDMODEHOLD=#FEEDMODEGCODE
%CALL=PT_SET_CRC_ACTIVE
#COOLHOLD=#COOL





%CALL=HOLD
@END
%ENDM
*
*	*****************************************
*	*	Tab Name	:	Bar Feed				*
*	*****************************************
*

%PROCEDURE=CODECON_BAR_FEED
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Bar Feed	*****>
@NO_CON-DEBUG

;Sequence Definition^<1289>Bar Feed^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^SAFEBLKNUM^DWELLGCODE^DWELLTIME^RAPIDGCODE^FEEDGCODE^FEEDMODEGCODE^FEED^SPEED^GEARMCODE^SPINDIR^LENGTHOFFSET^BFSTARTX^BFSTARTZ^BFENDZ^CHUCK-OPEN^CHUCK-CLOSE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[FEEDGCODE]^[BFSTARTX]^[BFSTARTZ]^[FEED]
;Default Sequence^[DELETE]^[BLKNUM]^[CHUCK-OPEN]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>DWELLGCODE]^[<C>DWELLTIME]
;Default Sequence^[DELETE]^[BLKNUM]^[BFENDZ]^[FEED]
;Default Sequence^[DELETE]^[BLKNUM]^[CHUCK-CLOSE]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>DWELLGCODE]^[<C>DWELLTIME]
%CALL=PT_BINC
%CALL=SET_FEEDGCODE
#BARX=XSTART*#DIAM
#BARZSTART=ZSTART*#ZREVERSE
<[#DELETE=43][#BNUM=39][#GCODE=38][#BARX=0][#BARZSTART=2][#FEED=7]>
%CALL=PT_BINC
%IF #SPINDLE=SPINDLEID2 %THEN #MCODE=DATA6(16) %ELSE #MCODE=DATA2(16)
<[#DELETE=43][#BNUM=39][#MCODE=36]>
%CALL=PT_BINC
#DWELLGCODE=DATA1(5)
%CANCEL=#DWELLGCODE
%CANCEL=DWELL
<[#DELETE=43][#BNUM=39][#DWELLGCODE=38][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%CALL=PT_BINC
#BARZEND=ZEND*#ZREVERSE
<[#DELETE=43][#BNUM=39][#BARZEND=2][#FEED=7]>
%CALL=PT_BINC
%IF #SPINDLE=SPINDLEID2 %THEN #MCODE=DATA6(17) %ELSE #MCODE=DATA2(17)
<[#DELETE=43][#BNUM=39][#MCODE=36]>
%CALL=PT_BINC
#DWELLGCODE=DATA1(5)
%CANCEL=#DWELLGCODE
%CANCEL=DWELL
<[#DELETE=43][#BNUM=39][#DWELLGCODE=38][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE





%ENDM
*
*	*****************************************
*	*	Tab Name	:	Dwell				*
*	*****************************************
*
%PROCEDURE=CODECON_DWELL
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Dwell	*****>
@NO_CON-DEBUG

;Sequence Definition^<6>Dwell^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^DWELLGCODE^DWELLTIME^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[<C>DWELLGCODE]^[<C>DWELLTIME]
%CALL=PT_BINC
#DWELLGCODE=DATA1(5)
%CANCEL=#DWELLGCODE
%CANCEL=DWELL
<[#DELETE=43][#BNUM=39][#DWELLGCODE=38][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE




%ENDM



*	*********************************************
*	*	Tab Name	:	Datum Shift				*
*	*********************************************

%PROCEDURE=CODECON_DATUM_SHIFT_TURN
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Incremental Datum Shift	*****>
@NO_CON-DEBUG
;Sequence Definition^<1770>Incremental Datum Shift^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^WORKGCODE^XINC^YINC^ZINC^XABSORIGIN^ZABSORIGIN^RAPIDGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^* Turn Datum Shifting on Preview at 2014R2
;Default Sequence^[DELETE]^[BLKNUM]^ G52^[XINC]^[YINC]^[ZINC]
<* Turn Datum Shifting on Preview at 2014R2>
%CALL=PT_BINC
%CANCEL=#XMOVE
%CANCEL=#YMOVE
%CANCEL=#ZMOVE
<[#DELETE=43][#BNUM=39] G52[#XMOVE=0][#YMOVE=1][#ZMOVE=2]>


#ZMOVE=ZCPL
#ZKEEP=#ZMOVE
#HOLDZDATUM=ZSUB
@END
%ENDM


%PROCEDURE=CODECON_DATUM_SET_TURN
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Datum Shift	*****>
@NO_CON-DEBUG
;Sequence Definition^<2055>Datum Shift^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^WORKGCODE^XINC^YINC^ZINC^XABSORIGIN^ZABSORIGIN^RAPIDGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^* Turn Datum Shifting on Preview at 2014R2
;Default Sequence^[DELETE]^[BLKNUM]^[WORKGCODE]
<* Turn Datum Shifting on Preview at 2014R2>
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#WORKGCODE=41]>


#ZMOVE=ZCPL
#ZKEEP=#ZMOVE
#HOLDZDATUM=ZSUB
@END
%ENDM

*
*	*****************************************
*	*	Tab Name	:	Cutter Compensation	*
*	*****************************************
*
%PROCEDURE=CODECON_CUTTER-COMPENSATION

%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Cutter Compensation	*****>
@NO_CON-DEBUG


;Sequence Definition^<411>Cutter Compensation^-1^<902>General Motion^
;Use Tokens^DELETE^BLKNUM^COMPGCODE^CRC REGISTER^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence



@END
%ENDM



*
*	*****************************************
*	*	Tab Name	:	Simple Turn 		*
*	*****************************************
*
%PROCEDURE=CODECON_SIMPLE-TURN
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Simple Turn Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<21>Simple Turn Cycle^3^<904>2 Axis Turning Cycles^
;Use Tokens^DELETE^BLKNUM^SIMTURNGCODE^XMOVE^ZMOVE^DEPTH^DEPTH (TURN)^DEPTH (FACE)^CHIPBREAK^CHIPBREAK (TURN)^CHIPBREAK (FACE)^FEED^SPEED^GEARMCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[SIMTURNGCODE]^[XMOVE]^[ZMOVE]^[DEPTH]^[CHIPBREAK]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#GCODE=44][#XMOVE=0][#ZMOVE=2][#DEPTH=72][#CHIP=77]>




@END
%ENDM
*
*	*****************************************
*	*	Tab Name	:	Rough Turn 			*
*	*****************************************
*
%PROCEDURE=CODECON_ROUGH-TURN
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rough Turn Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<20>Rough Turn Cycle^4^<904>2 Axis Turning Cycles^
;Use Tokens^DELETE^BLKNUM^RGHTURNGCODE^SUBNO^N-SUBSTART^N-SUBEND^CONSTOFFSET^OFFSETX^OFFSETZ^OFFSETXDIAM^DEPTH^FEED^SPEED^GEARMCODE^XSAFE^ZSAFE^DEPTH (TURN)^DEPTH (FACE)^XCYCLESTART^ZCYCLESTART^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[RGHTURNGCODE]^[DEPTH]^R1.0
;Default Sequence^[DELETE]^[BLKNUM]^[RGHTURNGCODE]^[N-SUBSTART]^[N-SUBEND]^[OFFSETX]^[OFFSETZ]^[FEED]^[SPEED]
;TEXT^Note: CONSTOFFSET is only available with New Turn Cycles
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#GCODE=44][#DEPTH=72]R1.0>
%CALL=PT_BINC
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#GCODE=44][STARTSUB=34][ENDSUB=35][#OFFSETX=69][#OFFSETZ=70][#FEED=7][#SPEED=8]>




@END
%ENDM

%PROCEDURE=CODECON_ROUGH-PROFILE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rough Profile Cycle	*****>
@NO_CON-DEBUG

* Sequence Definition^Rough Profile Cycle^4^2 Axis Turning Cycles
* Use Tokens^DELETE^BLKNUM^RGHTURNGCODE^SUBNO^N-SUBSTART^N-SUBEND^CONSTOFFSET^OFFSETX^OFFSETZ^OFFSETXDIAM^DEPTH^FEED^SPEED^GEARMCODE^XSAFE^ZSAFE* ^DEPTH (TURN)^DEPTH (FACE)^PROFILECUTS^XCYCLESTART^ZCYCLESTART

* Use Tokens^&GREEN&^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5
* Use Tokens^&GREEN&^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10
* Use Tokens^&GREEN&^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20

* Default Sequence^[DELETE]^[BLKNUM]^[RGHTURNGCODE]^[DEPTH]^R1.0
* Default Sequence^[DELETE]^[BLKNUM]^[RGHTURNGCODE]^[N-SUBSTART]^[N-SUBEND]^[OFFSETX]^[OFFSETZ]^[PROFILECUTS]^[FEED]^[SPEED]

* TEXT^Note: CONSTOFFSET is only available with New Turn Cycles

@END
%ENDM
*
*	*****************************************
*	*	Tab Name	:	Turn Cycle Stop 	*
*	*****************************************
*

%PROCEDURE=CODECON_CYCLE_STOP
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Turn Cycle Stop	*****>
@NO_CON-DEBUG

;Sequence Definition^<3992>Turn Cycle Stop^-1^<904>2 Axis Turning Cycles^
;Use Tokens^SAFESTART^PROG_STOP^DELETE^BLKNUM^CSSGCODE^CSSRAD^SPEED^GEARMCODE^SPINSTOP^SPINDIR^COOLANT OFF^COOLANT^TURRETNO^LENGTHOFFSET^GEARMCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[SPINSTOP]
;Default Sequence^[DELETE]^[BLKNUM]^[COOLANT OFF]
;Default Sequence^(Program Stop - Remove Swarf)
;Default Sequence^(Program Restart)
;Default Sequence^ M00
;Default Sequence^
;Default Sequence^
;Default Sequence^[DELETE]^[BLKNUM]^[<C>SPEED]^[<C>SPINDIR]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>COOLANT]
;Default Sequence^
;TEXT^Called by Longhand Rough Turn cycle for Program Stop output
;TEXT^Program Stop and Safe Restart calls may be made if preferred
%CALL=PT_BINC
%CALL=PT_SPIN_STOP
<[#DELETE=43][#BNUM=39][#DIRECTION=36]>
#DIRECTION=#DIRHOLD
%CALL=PT_BINC
%CALL=PT_COOL_CANCEL
<[#DELETE=43][#BNUM=39][#COOL=36]>
#COOL=#COOLHOLD
<(Program Stop - Remove Swarf)>
<(Program Restart)>
< M00>
%CALL=PT_BINC
%CALL=PT_SPINDLE
%CANCEL=#SPEED
%CANCEL=#DIRECTION
<[#DELETE=43][#BNUM=39][#SPEED=8][#DIRECTION=36]>
%CALL=PT_BINC
%CANCEL=#COOL
<[#DELETE=43][#BNUM=39][#COOL=36]>
#COOLHOLD=#COOL




@END
%ENDM


*
*	*****************************************
*	*	Tab Name	:	Finish Turn 		*
*	*****************************************
*
%PROCEDURE=CODECON_FINISH-TURN
*

%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Finish Turn Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<119>Finish Turn Cycle^4^<904>2 Axis Turning Cycles^
;Use Tokens^DELETE^BLKNUM^FINTURNGCODE^SUBNO^N-SUBSTART^N-SUBEND^CONSTOFFSET^OFFSETX^OFFSETZ^OFFSETXDIAM^FEED^SPEED^GEARMCODE^XSAFE^ZSAFE^XCYCLESTART^ZCYCLESTART^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[FINTURNGCODE]^R1.0
;Default Sequence^[DELETE]^[BLKNUM]^[FINTURNGCODE]^[N-SUBSTART]^[N-SUBEND]^[OFFSETX]^[OFFSETZ]
;TEXT^Note: CONSTOFFSET is only available with New Turn Cycles
%CALL=PT_BINC
#GCODE=DATA1(32)
<[#DELETE=43][#BNUM=39][#GCODE=44]R1.0>
%CALL=PT_BINC
#GCODE=DATA1(32)
<[#DELETE=43][#BNUM=39][#GCODE=44][STARTSUB=34][ENDSUB=35][#OFFSETX=69][#OFFSETZ=70]>





@END
%ENDM
*
*
*	*****************************************************
*	*	Tab Name	:	Threading Canned Cycle "G76" 	*
*	*****************************************************
*
%PROCEDURE=CODECON_THREAD-CANNED-CYCLE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Thread Canned Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<441>Thread Canned Cycle^-1^<904>2 Axis Turning Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^THREADGCODE^THREADCHAMFMCODE^XMOVE^ZMOVE^PITCH^FEED^THRDTOTDEPTH^THRDDEPTH^THRDANGLE^STARTS^SPRINGCUTS^THRDNUMCUTS^IPITCH^KPITCH^MINDEPTH^CHASEINANG^ITAPER^PULLOUT^START_DEPTH^FINAL_DEPTH^SPRING_DEPTH^XCYCLESTART^ZCYCLESTART^SPEED^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>THREADGCODE]^[SPRINGCUTS]^[PULLOUT]^[THRDANGLE]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>THREADGCODE]^[XMOVE]^[ZMOVE]^[ITAPER]^[THRDTOTDEPTH]^[START_DEPTH]^[FEED]^[SPEED]
;TEXT^For Feed values responsive to feed type do not use PITCH token
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
%CANCEL=#GCODE
%CALL=THD_CALC_THDANGLE
<[#DELETE=43][#BNUM=39][#GCODE=38][FPASS=88][USERVAR8=93][#THRDANGLE=87]>
%CALL=PT_BINC
%CANCEL=#GCODE
#ITEMP=#ITAPER
#DEPTH2=FIELD2
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#GCODE=38][#XMOVE=0][#ZMOVE=2][#ITEMP=81][#TOTALDEPTH=83][#DEPTH2=84][#FEED=7][#SPEED=8]>




@END
%ENDM
*
*	*****************************************************
*	*	Tab Name	:	Threading Repeat Cycle "G92"	*
*	*****************************************************
*
%PROCEDURE=CODECON_THREAD-G92-CYCLE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Thread Single Block Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<442>Thread Single Block Cycle^-1^<904>2 Axis Turning Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^THREADGCODE^THREADCHAMFMCODE^XMOVE^ZMOVE^PITCH^FEED^ITAPER^KTAPER^SPEED^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[THREADGCODE]^[<C>XMOVE]^[ZMOVE]^[FEED]^[SPEED]
;TEXT^For Feed values responsive to feed type do not use PITCH token
;TEXT^Force X for spring cuts
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
%CANCEL=#XMOVE
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#GCODE=38][#XMOVE=0][#ZMOVE=2][#FEED=7][#SPEED=8]>




@END
%ENDM
*
*	*****************************************************
*	*	Tab Name	:	Threading Longhand "G32"		*
*	*****************************************************
*
%PROCEDURE=CODECON_THREAD-LONGHAND-CYCLE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Thread Longhand	*****>
@NO_CON-DEBUG

;Sequence Definition^<443>Thread Longhand^-1^<904>2 Axis Turning Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^THREADGCODE^THREADCHAMFMCODE^XMOVE^ZMOVE^PITCH^FEED^IPITCH^KPITCH^THRDANGLE^SPEED^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[THREADGCODE]^[XMOVE]^[ZMOVE]^[FEED]^[SPEED]
;TEXT^For Feed values responsive to feed type do not use PITCH token
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#GCODE=38][#XMOVE=0][#ZMOVE=2][#FEED=7][#SPEED=8]>




@END
%CALL=HOLD
%ENDM
*
*	*************************************************
*	*	Tab Name	:	Drill Cycle					*
*	*************************************************
*
*
%PROCEDURE=CODECON_DRILL-CYCLE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Drill Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<27>Drill Cycle^-1^<415>Hole Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^DRILLGCODE^XMOVE^ZMOVE^CYCLE_ZSAFE^CYCLE_ZLEVEL^CYCLE_DEPTH^RAPIDGCODE^ZCLEAR^RPLANE^CYCLEZFEED^RETRACTGCODE^LENGTHOFFSET^COOLANT^CYCLESPEED^CYCLEDWELLTIME^PECKDEPTH^PECKSAFE^DEGRESSION^DWELLGCODE^DWELLTIME^FEEDMODEGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[RETRACTGCODE]^[DRILLGCODE]^[ZMOVE]^[RPLANE]^[CYCLEZFEED]^[PECKDEPTH]^[DWELLTIME]
;TEXT^Called for Drill, Peck and Counterbore Cycles
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#RETRACTGCODE=38][#DRGCODE=44][#ZMOVE=2][#RPLANE=56][#FEED=46][#DEPTH=50][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE



@END
%ENDM
*
*	*************************************************
*	*	Tab Name	:	Chipbreak Cycle					*
*	*************************************************
*
*
%PROCEDURE=CODECON_CHIP-CYCLE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Chipbreak Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<590>Chipbreak Cycle^-1^<415>Hole Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^DRILLGCODE^XMOVE^ZMOVE^CYCLE_ZSAFE^CYCLE_ZLEVEL^CYCLE_DEPTH^RAPIDGCODE^ZCLEAR^RPLANE^CYCLEZFEED^RETRACTGCODE^LENGTHOFFSET^COOLANT^CYCLESPEED^CYCLEDWELLTIME^PECKDEPTH^PECKSAFE^DEGRESSION^DWELLGCODE^DWELLTIME^FEEDMODEGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[RETRACTGCODE]^[DRILLGCODE]^[ZMOVE]^[<C>RPLANE]^[PECKDEPTH]^[CYCLEZFEED]^[DWELLTIME]
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
%CANCEL=#RPLANE
<[#DELETE=43][#BNUM=39][#RETRACTGCODE=38][#DRGCODE=44][#ZMOVE=2][#RPLANE=56][#DEPTH=50][#FEED=46][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE


@END
%ENDM
*
*	*************************************************
*	*	Tab Name	:	Ream Cycle					*
*	*************************************************
*
*
%PROCEDURE=CODECON_REAM-CYCLE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Ream Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<1070>Ream Cycle^-1^<415>Hole Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^DRILLGCODE^XMOVE^ZMOVE^CYCLE_ZSAFE^CYCLE_ZLEVEL^CYCLE_DEPTH^RAPIDGCODE^ZCLEAR^RPLANE^CYCLEZFEED^RETRACTGCODE^LENGTHOFFSET^COOLANT^CYCLESPEED^CYCLEDWELLTIME^DWELLGCODE^DWELLTIME^FEEDMODEGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[RETRACTGCODE]^[DRILLGCODE]^[ZMOVE]^[<C>RPLANE]^[CYCLEZFEED]^[DWELLTIME]
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
%CANCEL=#RPLANE
<[#DELETE=43][#BNUM=39][#RETRACTGCODE=38][#DRGCODE=44][#ZMOVE=2][#RPLANE=56][#FEED=46][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE


@END
%ENDM
*
*	*************************************************
*	*	Tab Name	:	Bore Cycle					*
*	*************************************************
*
*
%PROCEDURE=CODECON_BORE-CYCLE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Bore Cycle	*****>
@NO_CON-DEBUG

;Sequence Definition^<104>Bore Cycle^-1^<415>Hole Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^DRILLGCODE^XMOVE^ZMOVE^CYCLE_ZSAFE^CYCLE_ZLEVEL^CYCLE_DEPTH^RAPIDGCODE^ZCLEAR^RPLANE^CYCLEZFEED^RETRACTGCODE^LENGTHOFFSET^COOLANT^CYCLESPEED^CYCLEDWELLTIME^DWELLGCODE^DWELLTIME^FEEDMODEGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[RETRACTGCODE]^[DRILLGCODE]^[ZMOVE]^[<C>RPLANE]^[CYCLEZFEED]^[DWELLTIME]
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
%CANCEL=#RPLANE
<[#DELETE=43][#BNUM=39][#RETRACTGCODE=38][#DRGCODE=44][#ZMOVE=2][#RPLANE=56][#FEED=46][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE


@END
%ENDM

*
*
*	*************************************************
*	*	Tab Name	:	Tapping Cycle				*
*	*************************************************
*
*
%PROCEDURE=CODECON_TAPPING-CYCLE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Tapping Cycle	*****>
@NO_CON-DEBUG

%CALL=PT_CHECK_TAPPING
%IF #TAPTYPE=2 %THEN %CALL=CODECON_RIGID_TAP:%GOTO @END

;Sequence Definition^<28>Tapping Cycle^-1^<415>Hole Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^TAPGCODE^XMOVE^ZMOVE^CYCLE_ZSAFE^CYCLE_ZLEVEL^CYCLE_DEPTH^PECKDEPTH^PECKSAFE^ZCLEAR^RPLANE^CYCLEZFEED^RETRACTGCODE^LENGTHOFFSET^COOLANT^PITCH^SPINDIR^RAPIDGCODE^CYCLESPEED^CYCLEDWELLTIME^SPINREVERSE^DWELLGCODE^DWELLTIME^FEEDMODEGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[TAPGCODE]^[ZMOVE]^[PITCH]
;Default Sequence^[DELETE]^[BLKNUM]^[DWELLGCODE]^[<C>DWELLTIME]
;Default Sequence^[DELETE]^[BLKNUM]^[SPINREVERSE]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>TAPGCODE]^[RPLANE]^[<C>PITCH]
;TEXT^For Feed values responsive to feed type do not use PITCH token
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#DRGCODE=44][#ZMOVE=2][PITCH=57]>
%CALL=PT_BINC
#DWELLGCODE=DATA1(5)
%CANCEL=DWELL
<[#DELETE=43][#BNUM=39][#DWELLGCODE=38][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%CALL=PT_BINC
%CALL=PT_SPINDLE_REVERSE
<[#DELETE=43][#BNUM=39][#DIRECTION=36]>
%CALL=PT_BINC
%CANCEL=#DRGCODE
%CANCEL=PITCH
<[#DELETE=43][#BNUM=39][#DRGCODE=44][#RPLANE=56][PITCH=57]>



@END
%ENDM

%PROCEDURE=CODECON_RIGID_TAP
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rigid Tapping	*****>
@NO_CON-DEBUG

;Sequence Definition^<1069>Rigid Tapping Cycle^-1^<415>Hole Cycles^
;Use Tokens^FEEDMODEBLOCK^DELETE^BLKNUM^TAPGCODE^RIGIDTAP^XMOVE^ZMOVE^CYCLE_ZSAFE^CYCLE_ZLEVEL^CYCLE_DEPTH^PECKDEPTH^PECKSAFE^ZCLEAR^RPLANE^CYCLEZFEED^RETRACTGCODE^LENGTHOFFSET^COOLANT^PITCH^SPINDIR^RAPIDGCODE^CYCLESPEED^CYCLEDWELLTIME^SPINREVERSE^DWELLGCODE^DWELLTIME^FEEDMODEGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[FEEDMODEBLOCK]
;Default Sequence^[DELETE]^[BLKNUM]^[RIGIDTAP]^[CYCLESPEED]
;Default Sequence^[DELETE]^[BLKNUM]^[TAPGCODE]^[ZMOVE]^[PITCH]
;Default Sequence^[DELETE]^[BLKNUM]^[DWELLGCODE]^[<C>DWELLTIME]
;Default Sequence^[DELETE]^[BLKNUM]^[SPINREVERSE]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>TAPGCODE]^[RPLANE]^[<C>PITCH]
;TEXT^For Feed values responsive to feed type do not use PITCH token
%CALL=CODECON_FEED_MODE
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#RIGIDTAP=36][#SPEED=8]>
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#DRGCODE=44][#ZMOVE=2][PITCH=57]>
%CALL=PT_BINC
#DWELLGCODE=DATA1(5)
%CANCEL=DWELL
<[#DELETE=43][#BNUM=39][#DWELLGCODE=38][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%CALL=PT_BINC
%CALL=PT_SPINDLE_REVERSE
<[#DELETE=43][#BNUM=39][#DIRECTION=36]>
%CALL=PT_BINC
%CANCEL=#DRGCODE
%CANCEL=PITCH
<[#DELETE=43][#BNUM=39][#DRGCODE=44][#RPLANE=56][PITCH=57]>



@END
%ENDM

*	****************************************
*	* Tab Name :  Tapping Spindle Reverse  *
*	****************************************
*

%PROCEDURE=CODECON_TAPREV_T
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Tapping Spindle Reverse (top) *****>
@NO_CON-DEBUG

;Sequence Definition^<3256>Tapping Spindle Reverse (Top)^-1^<415>Hole Cycles^
;Use Tokens^DELETE^BLKNUM^DWELLGCODE^DWELLTIME^CYCLEDWELLTIME^SPEED^REVS^SPINDIR^GEARMCODE^SPINREVERSE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[DWELLGCODE]^[<C>DWELLTIME]
;Default Sequence^[DELETE]^[BLKNUM]^[SPINREVERSE]
%CALL=PT_BINC
#DWELLGCODE=DATA1(5)
%CANCEL=DWELL
<[#DELETE=43][#BNUM=39][#DWELLGCODE=38][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%CALL=PT_BINC
%CALL=PT_SPINDLE_REVERSE
<[#DELETE=43][#BNUM=39][#DIRECTION=36]>



@END
%ENDM

%PROCEDURE=CODECON_TAPREV_B
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Tapping Spindle Reverse (Bottom) *****>
@NO_CON-DEBUG

;Sequence Definition^<3255>Tapping Spindle Reverse (Bottom)^-1^<415>Hole Cycles^
;Use Tokens^DELETE^BLKNUM^DWELLGCODE^DWELLTIME^CYCLEDWELLTIME^SPEED^REVS^SPINDIR^GEARMCODE^SPINREVERSE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[DWELLGCODE]^[<C>DWELLTIME]
;Default Sequence^[DELETE]^[BLKNUM]^[SPINREVERSE]
%CALL=PT_BINC
#DWELLGCODE=DATA1(5)
%CANCEL=DWELL
<[#DELETE=43][#BNUM=39][#DWELLGCODE=38][DWELL=16]>
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%IF #FORCEAFTERDWELL=1 %THEN %CANCEL=#GCODE
%CALL=PT_BINC
%CALL=PT_SPINDLE_REVERSE
<[#DELETE=43][#BNUM=39][#DIRECTION=36]>



@END
%ENDM


*	*****************************************
*	*	Tab Name	:	Core Toolchange	*
*	*****************************************
*
%PROCEDURE=CODECON_CORETC
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Core Toolchange	*****>
@NO_CON-DEBUG


;Sequence Definition^<2042>Core Toolchange^-1^<2043>Turret Toolchange^
;Use Tokens^IF_CSS^IF_RPM^COOLANT_TAPS^DELETE^BLKNUM^SAFEBLKNUM^ABS-INC^TCHANGE^TOOLDESCR^COMMENT^TURRETNO^TURRETNAME^MPOINT_INDEX^MPOINT_NAME^TURRET_SIDE^TOOLORIENT^NEXTTOOL^LENGTHOFFSET^CRC REGISTER^SPEED^MAXRPM^COOLANT^COOLANT OFF^COOLTHROTOOL^SPINDIR^TURNSTOP^WORKGCODE^XTOOL^ZTOOL^ZGAUGELENGTH^XGAUGELENGTH^NOSERAD-X^NOSERAD-Z^RCOORD^CANCELTLO^G92X_SET^G92Z_SET^INDEXTURRET^REVS^GEARMCODE^CSSGCODE^CSSRAD^RPM_MODE^PRESETGCODE^RAPIDGCODE^FEEDMODEGCODE^PLANEGCODE^QUADRANT^TOOLUNITS^LBRKT^RBRKT^TSTORE_USER1^TSTORE_USER2^TSTORE_STRING1^TSTORE_STRING2^TOOL-ANGLE^TOOL_GROUP^TOOL_GROUP_NUMBER^TOOL_GROUP_TEXT^TOOL_ID^TOOL_ID_NUMBER^TOOL_ID_TEXT^HOLDER_TYPE^NEXTDESCR^NEXTCOMMENT^NEXT_GROUP^NEXT_GROUP_NUMBER^NEXT_GROUP_TEXT^NEXT_ID^NEXT_ID_NUMBER^NEXT_ID_TEXT^TOOL_HAND^TOOL_REVERSE^TOOL_MODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence
;Default Sequence^[DELETE]^[BLKNUM]^[<C>TURRETNO]^[<C>CRC REGISTER]^(^[TOOLDESCR]^)
;TEXT^Note that toolchange now split between turret/ATC not by turret
;TEXT^This Code Constructor handles the common part of ToolChanges.
;TEXT^It must be called in the other toolchange code constructors
< >
%CALL=PT_BINC
%CANCEL=POSITION
%CANCEL=#COMPDCODE
<[#DELETE=43][#BNUM=39][POSITION=17][#COMPDCODE=30]([$TOOLDESCRIPTION])>





@END
%ENDM


*
*	*****************************************
*	*	Tab Name	:	First Toolchange	*
*	*****************************************
*
%PROCEDURE=CODECON_FIRST-TOOLCH
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	First Toolchange	*****>
@NO_CON-DEBUG

;Sequence Definition^<444>First Toolchange^-1^<2043>Turret Toolchange^
;Use Tokens^IF_CSS^IF_RPM^COOLANT_TAPS^TOOLCHANGE^DELETE^BLKNUM^SAFEBLKNUM^ABS-INC^TOOLDESCR^COMMENT^TURRETNO^TURRETNAME^MPOINT_INDEX^MPOINT_NAME^TURRET_SIDE^TOOLORIENT^NEXTTOOL^LENGTHOFFSET^CRC REGISTER^SPEED^MAXRPM^COOLANT^COOLANT OFF^COOLTHROTOOL^SPINDIR^WORKGCODE^XTOOL^ZTOOL^ZGAUGELENGTH^XGAUGELENGTH^NOSERAD-X^NOSERAD-Z^RCOORD^CANCELTLO^G92X_SET^G92Z_SET^INDEXTURRET^REVS^GEARMCODE^CSSGCODE^CSSRAD^RPM_MODE^PRESETGCODE^RAPIDGCODE^FEEDMODEGCODE^PLANEGCODE^QUADRANT^TOOLUNITS^LBRKT^RBRKT^TSTORE_USER1^TSTORE_USER2^TSTORE_STRING1^TSTORE_STRING2^TOOL_GROUP^TOOL_GROUP_NUMBER^TOOL_GROUP_TEXT^TOOL_ID^TOOL_ID_NUMBER^TOOL_ID_TEXT^HOLDER_TYPE^NEXTDESCR^NEXTCOMMENT^NEXT_GROUP^NEXT_GROUP_NUMBER^NEXT_GROUP_TEXT^NEXT_ID^NEXT_ID_NUMBER^NEXT_ID_TEXT^TOOL_HAND^TOOL_REVERSE^TOOL_MODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[TOOLCHANGE]
;TEXT^Use the TOOLCHANGE Token to call the Core Tool Change Blocks
%CALL=CODECON_CORETC



%CALL=HOLD
#CAXISHOLD=CAXIS
@END
%ENDM

;Use Tokens^<2131>TSTORE_USER1^<2133>TSTORE_USER2^<2134>TSTORE_STRING1^<2136>TSTORE_STRING2
;Use Tokens^<3397>TOOL_GROUP^<3401>TOOL_GROUP_NUMBER^<3399>TOOL_GROUP_TEXT^<3403>TOOL_ID^<3407>TOOL_ID_NUMBER^<3405>TOOL_ID_TEXT^<3733>HOLDER_TYPE
;Use Tokens^<2951>NEXTDESCR^<2953>NEXTCOMMENT^<4323>NEXT_GROUP^<4248>NEXT_GROUP_NUMBER^<4325>NEXT_GROUP_TEXT^<4327>NEXT_ID^<4329>NEXT_ID_NUMBER^<4331>NEXT_ID_TEXT
;Use Tokens^<3735>TOOL_HAND^<3737>TOOL_REVERSE^<3739>TOOL_MODE

;Use Tokens^&GREEN&^<1497>USER-STRING^<1597>USER-STRING-1^<1598>USER-STRING-2^<1599>USER-STRING-3^<1600>USER-STRING-4^<1601>USER-STRING-5
;Use Tokens^&GREEN&^<1499>USER-1^<1501>USER-2^<1503>USER-3^<1603>USER-4^<1604>USER-5^<1605>USER-6^<1606>USER-7^<1607>USER-8^<1608>USER-9^<1609>USER-10
;Use Tokens^&GREEN&^<2492>USER-11^<2493>USER-12^<2494>USER-13^<2495>USER-14^<2496>USER-15^<2497>USER-16^<2498>USER-17^<2499>USER-18^<2500>USER-19^<2501>USER-20

;TEXT^<45>Called when switching between tool static and driven modes
;TEXT^<44>Use the TOOLCHANGE Token to call the Core Tool Change Blocks
;Default Sequence^[TOOLCHANGE]


%CALL=HOLD
#CAXISHOLD=CAXIS
@END

*
*	*****************************************
*	*	Tab Name	:	General Toolchange	*
*	*****************************************
*
%PROCEDURE=CODECON_GEN-TOOLCH
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	General Toolchange	*****>
@NO_CON-DEBUG


;Sequence Definition^<445>General Toolchange^-1^<2043>Turret Toolchange^
;Use Tokens^IF_CSS^IF_RPM^COOLANT_TAPS^TOOLCHANGE^DELETE^BLKNUM^SAFEBLKNUM^ABS-INC^TOOLDESCR^COMMENT^TURRETNO^TURRETNAME^MPOINT_INDEX^MPOINT_NAME^TURRET_SIDE^TOOLORIENT^NEXTTOOL^LENGTHOFFSET^CRC REGISTER^SPEED^MAXRPM^COOLANT^COOLANT OFF^COOLTHROTOOL^SPINDIR^WORKGCODE^XTOOL^ZTOOL^ZGAUGELENGTH^XGAUGELENGTH^NOSERAD-X^NOSERAD-Z^RCOORD^CANCELTLO^G92X_SET^G92Z_SET^INDEXTURRET^REVS^GEARMCODE^CSSGCODE^CSSRAD^RPM_MODE^PRESETGCODE^RAPIDGCODE^FEEDMODEGCODE^PLANEGCODE^QUADRANT^TOOLUNITS^LBRKT^RBRKT^TSTORE_USER1^TSTORE_USER2^TSTORE_STRING1^TSTORE_STRING2^TOOL_GROUP^TOOL_GROUP_NUMBER^TOOL_GROUP_TEXT^TOOL_ID^TOOL_ID_NUMBER^TOOL_ID_TEXT^HOLDER_TYPE^NEXTDESCR^NEXTCOMMENT^NEXT_GROUP^NEXT_GROUP_NUMBER^NEXT_GROUP_TEXT^NEXT_ID^NEXT_ID_NUMBER^NEXT_ID_TEXT^TOOL_HAND^TOOL_REVERSE^TOOL_MODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[TOOLCHANGE]
;TEXT^Use the TOOLCHANGE Token to call the Core Tool Change Blocks
%CALL=CODECON_CORETC





%CALL=HOLD
#CAXISHOLD=CAXIS
@END
%ENDM




*
*	*****************************************
*	*	Tab Name	:	Spindle	Control  	*
*	*****************************************
*

%PROCEDURE=CODECON_SPINDLE_CONTROL
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Spindle Control	RPM *****>
@NO_CON-DEBUG

%IF #CSSGCODE=DATA1(45) %THEN %CALL=CODECON_SPINDLE_CSS:%GOTO @END

;Sequence Definition^<2173>Spindle Control RPM^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^STOPMCODE^SPEED^REVS^SPINDIR^CSSGCODE^CSSRAD^GEARMCODE^PRESETGCODE^MAXRPM^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[CSSGCODE]^[SPEED]^[SPINDIR]^[GEARMCODE]
%CALL=PT_BINC
%CALL=PT_SPINDLE
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#CSSGCODE=38][#SPEED=8][#DIRECTION=36][#GEARMCODE=37]>




@END
%ENDM

%PROCEDURE=CODECON_SPINDLE_CSS
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Spindle Control	CSS *****>
@NO_CON-DEBUG

;Sequence Definition^<2174>Spindle Control CSS^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^STOPMCODE^SPEED^REVS^SPINDIR^CSSGCODE^CSSRAD^GEARMCODE^PRESETGCODE^MAXRPM^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[CSSGCODE]^[SPEED]^[SPINDIR]^[GEARMCODE]
%CALL=PT_BINC
%CALL=PT_SPINDLE
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#CSSGCODE=38][#SPEED=8][#DIRECTION=36][#GEARMCODE=37]>



%ENDM
*	*********************************************
*	*	Tab Name	:	Spindle Brake				*
*	*********************************************

%PROCEDURE=CODECON_SPINDLE_BRAKE
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Spindle Brake	*****>
@NO_CON-DEBUG

;Sequence Definition^<1909>Spindle Brake^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^SPINBRAKE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[SPINBRAKE]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#BRAKE=36]>




@END
%ENDM


*
*	*****************************************
*	*	Tab Name	:	Program Stop		*
*	*****************************************
*
%PROCEDURE=CODECON_PROGRAM-STOP
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Program Stop	*****>
@NO_CON-DEBUG

;Sequence Definition^<45>Program Stop^-1^<903>Miscellaneous^
;Use Tokens^SAFESTART^DELETE^BLKNUM^STOPMCODE^CSSGCODE^CSSRAD^SPEED^GEARMCODE^SPINSTOP^SPINDIR^COOLANT^COOLANT OFF^TURRETNO^LENGTHOFFSET^GEARMCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[SPEED]^[SPINDIR]^[GEARMCODE]
;Default Sequence^[DELETE]^[BLKNUM]^[TURRETNO]^[LENGTHOFFSET]
;Default Sequence^[DELETE]^[BLKNUM]^[STOPMCODE]
;TEXT^SAFESTART calls Safe Restart Code Constructor
%CALL=PT_BINC
%CALL=PT_SPINDLE
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#SPEED=8][#DIRECTION=36][#GEARMCODE=37]>
%CALL=PT_BINC
#HCODEHOLD=#HCODE:%CALL=PT_ADJUST_TLO
<[#DELETE=43][#BNUM=39][POSITION=17][#HCODE=24]>
#CANCELCODE=+-2:<[#CANCELCODE=10]>
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#MCODE=36]>




%ENDM
*

*
*	*****************************************
*	*	Tab Name	:	Safe Re-Start		*
*	*****************************************
*
%PROCEDURE=CODECON_SAFE_START
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Safe Re-Start	*****>
@NO_CON-DEBUG

%IF #MACRO=15 @END
%IF #MACRO=165 @END
%IF NEXTMACRO=15 @END
%IF NEXTMACRO=165 @END



;Sequence Definition^<3067>Safe Re-Start^-1^<903>Miscellaneous^
;Use Tokens^IF_CSS^IF_RPM^DELETE^BLKNUM^SAFEBLKNUM^TURRETCODE^ABS-INC^TCHANGE^TOOLDESCR^COMMENT^TURRETNO_ATC^MPOINT_INDEX^MPOINT_NAME^TURRETNAME^TOOLORIENT^NEXTTOOL_ATC^LENGTHOFFSET^CRC REGISTER^SPEED^MAXRPM^COOLANT^COOLANT OFF^COOLTHROTOOL^CY_SPINDIR^TURNSTOP^MILL_MODE^WORKGCODE^XTOOL^ZTOOL^ZGAUGELENGTH^XGAUGELENGTH^NOSERAD-X^NOSERAD-Z^RCOORD^CANCELTLO^C_AUTO_STAT^DRIVEN^G92X_SET^G92Z_SET^INDEXTURRET^BMOVE^SPINDLEID^REVS^GEARMCODE^CSSGCODE^CSSRAD^RPM_MODE^PRESETGCODE^RAPIDGCODE^FEEDMODEGCODE^PLANEGCODE^QUADRANT^MILLBRAKE^LBRKT^RBRKT^TSTORE_USER1^TSTORE_USER2^TSTORE_STRING1^TSTORE_STRING2^TOOL_GROUP^TOOL_GROUP_NUMBER^TOOL_GROUP_TEXT^TOOL_ID^TOOL_ID_NUMBER^TOOL_ID_TEXT^HOLDER_TYPE^XMOVE^YMOVE^ZMOVE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^
;TEXT^Called by token from Program Stop code constructor
;TEXT^No output if macro or nextmacro is toolchange



@END
%ENDM



*


*	*****************************************
*	*	Tab Name	:	Coolant				*
*	*****************************************
*
%PROCEDURE=CODECON_COOLANT
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Coolant	*****>
@NO_CON-DEBUG

;Sequence Definition^<425>Coolant^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^COOLANT^COOLCHUCKFACE^COOLTHROSPIN^COOLTURRETFACE^COOLTHROTOOL^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[COOLCHUCKFACE]^[COOLTHROSPIN]^[COOLTURRETFACE]^[COOLTHROTOOL]
;TEXT^Taps set here. On/Off in movement code constructors
;TEXT^Only called if one or more taps change
%CALL=PT_BINC
%IF TURRET=0 %THEN #THROUGHTOOL=#THROUGHTOOL1 %ELSE #THROUGHTOOL=#THROUGHTOOL2
<[#DELETE=43][#BNUM=39][#CHUCKFACE=36][#THROUGHSPIN=36][#TURRETFACE=36][#THROUGHTOOL=36]>



%ENDM

*
*	*****************************************
*	*	Tab Name	:	Exact Stop			*
*	*****************************************
*
%PROCEDURE=CODECON_EXACT-STOP
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Exact Stop	*****>
@NO_CON-DEBUG

;Sequence Definition^<7>Exact Stop^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^EXACTSTOPGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^
;TEXT^Add output line for modal codes, leave blank for single shot




%ENDM
*
*	*****************************************
*	*	Tab Name	:	Feed / min / rev	*
*	*****************************************
*
%PROCEDURE=CODECON_FEED_MODE
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Feed / Min / Rev	*****>
@NO_CON-DEBUG

%IF #FEEDMODEGCODE=#FEEDMODEHOLD @END ; Modality

;Sequence Definition^<447>Feed / Min / Rev^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^FEEDMODEGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[FEEDMODEGCODE]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#FEEDMODEGCODE=38]>
#FEEDMODEHOLD=#FEEDMODEGCODE



@END
%ENDM

*
*	*****************************************
*	*	Tab Name	:	Comment				*
*	*****************************************
*
%PROCEDURE=CODECON_COMMENT
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Comment	*****>
@NO_CON-DEBUG

;Sequence Definition^<448>Comment^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^COMMENT^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^ (^[COMMENT]^)
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39] ([USERDEFINEDSTRING])>




%ENDM
*
*	*****************************************
*	*	Tab Name	:	Insert NC Code		*
*	*****************************************
*
%PROCEDURE=CODECON_INSERT-NC-CODE
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Insert Nc Code	*****>
@NO_CON-DEBUG

;Sequence Definition^<449>Insert Nc Code^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^COMMENT^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[COMMENT]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][USERDEFINEDSTRING]>




%ENDM
*
*	*****************************************************
*	*	Tab Name	:	Re-Select Tool Length Offset	*
*	*****************************************************
*
%PROCEDURE=CODECON_SELECT-LENGTH-OFFSET
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Select Length Offset	*****>
@NO_CON-DEBUG

%CALL=GET_QUADRANT

;Sequence Definition^<450>Select Length Offset^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^LENGTHOFFSET^LENGTHOFFSET2^TURRETNO^REPEAT_TURRETNO^CHANGEOFFSET^QUADRANT^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[REPEAT_TURRETNO]^[CHANGEOFFSET]
;TEXT^Sets offset register for length or XZ offsets
;TEXT^LENGTHOFFSET2 provides an alternative output format
%CALL=PT_BINC
%CALL=PT_CHANGE_OFFSET
<[#DELETE=43][#BNUM=39][#POSREP=18][#HCODE=25]>
#CANCELCODE=+-2:<[#CANCELCODE=10]>




%ENDM
*
*	*****************************************
*	*	Tab Name	:	Rapid To Toolchange	*
*	*****************************************
*
%PROCEDURE=CODECON_RAPID-TO-TOOLCHANGE
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rapid To Toolchange	*****>
@NO_CON-DEBUG

* %IF SPINDLE=SPINDLEID2 %THEN #ZMOVE=#ZMOVE-(MCSUBDATUMZ*#ZREVERSE)

*

;Sequence Definition^<451>Rapid To Toolchange^-1^<902>General Motion^
;Use Tokens^SECOND_LEG^PROG_STOP^DELETE^BLKNUM^SAFEBLKNUM^COMMENT^RAPIDGCODE^SPINSTOP^HOMEGCODE^XTOOL^ZTOOL^XMOVE^ZMOVE^ZINITIAL^TURRETNO^NEXTTOOL^CANCELTLO^G92X_RETURN^G92Z_RETURN^U0^V0^W0^X0^Y0^Z0^FEEDMODEGCODE^COOLANT^COOLANT OFF^COOLTHRTLOFF^ZGAUGELENGTH^XGAUGELENGTH^CSSGCODE^CSSRAD^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[RAPIDGCODE]^ X80.0 Z30.0
;Default Sequence
;TEXT^First leg of move, always called. Add M functions etc here
;TEXT^Second leg called by token, allows more M codes to follow it.
%CALL=PT_BINC
#GCODE=DATA1(1)
<[#DELETE=43][#BNUM=39][#GCODE=38] X80.0 Z30.0>






%CALL=HOLD
@END
%ENDM

%PROCEDURE=CODECON_RAPID-TO-TOOLCHANGE-2
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rapid To Toolchange 2	*****>
@NO_CON-DEBUG

* %IF SPINDLE=SPINDLEID2 %THEN #ZMOVE=#ZMOVE-(MCSUBDATUMZ*#ZREVERSE)

*

;Sequence Definition^<2047>Rapid To Toolchange 2^-1^<902>General Motion^
;Use Tokens^PROG_STOP^DELETE^BLKNUM^SAFEBLKNUM^COMMENT^RAPIDGCODE^SPINSTOP^HOMEGCODE^XTOOL^ZTOOL^XMOVE^ZMOVE^ZINITIAL^TURRETNO^NEXTTOOL^CANCELTLO^G92X_RETURN^G92Z_RETURN^U0^V0^W0^X0^Y0^Z0^FEEDMODEGCODE^COOLANT OFF^ZGAUGELENGTH^XGAUGELENGTH^CSSGCODE^CSSRAD^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[RAPIDGCODE]^[XTOOL]^[ZTOOL]
;TEXT^Second Leg called only if required
%CALL=PT_BINC
#GCODE=DATA1(1)
<[#DELETE=43][#BNUM=39][#GCODE=38][#XTOOL=0][#ZTOOL=2]>





%CALL=HOLD
@END
%ENDM
*
*	*********************************************
*	*	Tab Name	:	Rapid After Toolchange	*
*	*********************************************
*
%PROCEDURE=CODECON_RA-AFTER-TOOLCHANGE
*
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rapid After Toolchange	*****>
@NO_CON-DEBUG

;Sequence Definition^<452>Rapid After Toolchange^-1^<902>General Motion^
;Use Tokens^IF_CSS^IF_RPM^SPINDLE_CLAMP^DELETE^BLKNUM^SAFEBLKNUM^ABS-INC^RAPIDGCODE^XMOVE^ZMOVE^TURRETNO^NEXTTOOL^LENGTHOFFSET^SPEED^SPINDIR^GEARMCODE^PRESETGCODE^MAXRPM^WORKGCODE^FEEDMODEGCODE^FEED^RCOORD^COOLANT^COOLTHROTOOL^COMPGCODE^CRC REGISTER^CRC PRESET^CSSGCODE^CSSRAD^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[FEEDMODEGCODE]^[FEED]^[CSSGCODE]^[SPEED]^[SPINDIR]^[COOLANT]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>RAPIDGCODE]^[<C>XMOVE]^[<C>ZMOVE]
;TEXT^CRC REGISTER is only available with COMPGCODE
;TEXT^CRC PRESET will always output current value
%CALL=PT_BINC
%CALL=PT_SPINDLE
<[#DELETE=43][#BNUM=39][#FEEDMODEGCODE=38][#FEED=7][#CSSGCODE=38][#SPEED=8][#DIRECTION=36][#COOL=36]>
#FEEDMODEHOLD=#FEEDMODEGCODE
#COOLHOLD=#COOL
%CALL=PT_BINC
#GCODE=DATA1(1)
%CANCEL=#GCODE
%CANCEL=#XMOVE
%CANCEL=#ZMOVE
<[#DELETE=43][#BNUM=39][#GCODE=38][#XMOVE=0][#ZMOVE=2]>





%CALL=HOLD
@END
%ENDM
*
*	*****************************************
*	*	Tab Name	:	Rapid To Home		*
*	*****************************************
*
%PROCEDURE=CODECON_RAPID-TO-HOME
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rapid To Home	*****>
@NO_CON-DEBUG

* %IF SPINDLE=SPINDLEID2 %THEN #ZMOVE=#ZMOVE-(MCSUBDATUMZ*#ZREVERSE)

*

;Sequence Definition^<453>Rapid To Home^-1^<902>General Motion^
;Use Tokens^SECOND_LEG^PROG_STOP^DELETE^BLKNUM^COMMENT^RAPIDGCODE^SPINSTOP^HOMEGCODE^XHOME^ZHOME^XMOVE^ZMOVE^ZINITIAL^FIRSTTOOL^NEXTTOOL^TURRETNO^CANCELTLO^G92X_RETURN^G92Z_RETURN^U0^V0^W0^X0^Y0^Z0^COOLANT OFF^COOLTHRTLOFF^FEEDMODEGCODE^ZGAUGELENGTH^XGAUGELENGTH^CSSGCODE^CSSRAD^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^ G28^[U0]^[W0]^[SPINSTOP]
;Default Sequence^[SECOND_LEG]
;TEXT^First leg of move, always called. Add M functions etc here
;TEXT^Second leg called by token, allows more M codes to follow it.
%CALL=PT_BINC
%CALL=PT_SPIN_STOP
<[#DELETE=43][#BNUM=39] G28[#UZERO=94][#WZERO=95][#DIRECTION=36]>
#DIRECTION=#DIRHOLD
%CALL=PT_RAPID_TO_HOME_TOOLCHANGE_2





%CALL=HOLD
@END
%ENDM

%PROCEDURE=CODECON_RAPID-TO-HOME-2
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Rapid To Home 2	*****>
@NO_CON-DEBUG

* %IF SPINDLE=SPINDLEID2 %THEN #ZMOVE=#ZMOVE-(MCSUBDATUMZ*#ZREVERSE)

*

;Sequence Definition^<2048>Rapid To Home 2^-1^<902>General Motion^
;Use Tokens^PROG_STOP^DELETE^BLKNUM^COMMENT^RAPIDGCODE^SPINSTOP^HOMEGCODE^XHOME^ZHOME^XMOVE^ZMOVE^ZINITIAL^FIRSTTOOL^NEXTTOOL^TURRETNO^CANCELTLO^G92X_RETURN^G92Z_RETURN^U0^V0^W0^X0^Y0^Z0^COOLANT OFF^FEEDMODEGCODE^ZGAUGELENGTH^XGAUGELENGTH^CSSGCODE^CSSRAD^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^ G28^[U0]^[W0]
;TEXT^Second Leg called by token only if required
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39] G28[#UZERO=94][#WZERO=95]>






%CALL=HOLD
@END
%ENDM

*
*	*************************************************
*	*	Tab Name	:	Subroutine Start			*
*	*************************************************
*
%PROCEDURE=CODECON_SUBROUTINE-START
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Subroutine Start	*****>
@NO_CON-DEBUG

;Sequence Definition^<454>Subroutine Start^-1^<417>Subroutines^
;Use Tokens^DELETE^BLKNUM^SUBNO^ABS-INC^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^
;TEXT^WARNING - Numbered subroutines may invalidate in-line canned cycles




%ENDM
*
*	*************************************************
*	*	Tab Name	:	Subroutine Call				*
*	*************************************************
*
%PROCEDURE=CODECON_SUBROUTINE-CALL
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Subroutine Call	*****>
@NO_CON-DEBUG

;Sequence Definition^<455>Subroutine Call^-1^<417>Subroutines^
;Use Tokens^DELETE^BLKNUM^SUBCALL^SUBNOCALL^N-SUBSTART^N-SUBEND^SUBNO^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^
;TEXT^WARNING - Numbered subroutines may invalidate in-line canned cycles




%ENDM
*
*	*************************************************
*	*	Tab Name	:	Subroutine End				*
*	*************************************************
*
%PROCEDURE=CODECON_SUBROUTINE-END
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Subroutine End	*****>
@NO_CON-DEBUG

;Sequence Definition^<456>Subroutine End^-1^<417>Subroutines^
;Use Tokens^DELETE^BLKNUM^SUBCALL^SUBNO^SUBEND^ABS-INC^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^



%ENDM

*	*************************************************
*	*	Tab Name	:	Translate				*
*	*************************************************
*
%PROCEDURE=CODECON_TRANSLATE
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Translate	*****>
@NO_CON-DEBUG


;Sequence Definition^<592>Translate^-1^<918>Repeat Machining^
;Use Tokens^DELETE^BLKNUM^XINC^ZINC^XABSORIGIN^ZABSORIGIN^PRESETGCODE^RAPIDGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^
;TEXT^WARNING - Numbered subroutines may invalidate in-line canned cycles



%CALL=HOLD
%ENDM


*	*************************************************
*	*	Tab Name	:	Translate Reset				*
*	*************************************************
*
%PROCEDURE=CODECON_TRANSLATE_RESET
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Translate Reset	*****>
@NO_CON-DEBUG


;Sequence Definition^<603>Translate Reset^-1^<918>Repeat Machining^
;Use Tokens^DELETE^BLKNUM^XINC^ZINC^XABSORIGIN^ZABSORIGIN^PRESETGCODE^RAPIDGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^
;TEXT^WARNING - Numbered subroutines may invalidate in-line canned cycles




%CALL=HOLD
%ENDM


*
*	*****************************************
*	*	Tab Name	:	Chuck Open			*
*	*****************************************
*
%PROCEDURE=CODECON_CHUCK-OPEN
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Chuck Open / Closed	*****>
@NO_CON-DEBUG

;Sequence Definition^<57>Chuck Open^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^CHUCKSTATUS^EJECT^RETR-EJECT^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[CHUCKSTATUS]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#MCODE=36]>




%ENDM
*
*	*****************************************
*	*	Tab Name	:	Chuck Pressure		*
*	*****************************************
*
%PROCEDURE=CODECON_CHUCK-PRESSURE
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Chuck Pressure	*****>
@NO_CON-DEBUG

;Sequence Definition^<133>Chuck Pressure^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^CHUCKPSI^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[CHUCKPSI]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#MCODE=36]>




%ENDM
*
*	*****************************************
*	*	Tab Name	:	Tailstock			*
*	*****************************************
*
%PROCEDURE=CODECON_TAILSTOCK
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Tailstock	*****>
@NO_CON-DEBUG

;Sequence Definition^<457>Tailstock^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^TAILSTOCK^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[TAILSTOCK]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#MCODE3=36]>




%ENDM
*
*	*****************************************
*	*	Tab Name	:	Tailstock Quill		*
*	*****************************************
*
%PROCEDURE=CODECON_TAILSTOCK-QUILL
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Tailstock Quill	*****>
@NO_CON-DEBUG

;Sequence Definition^<458>Tailstock Quill^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^TAILQUILL^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[TAILQUILL]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#MCODE2=36]>




%ENDM
*
*	*****************************************
*	*	Tab Name	:	Parts Catcher		*
*	*****************************************
*
%PROCEDURE=CODECON_PARTS-CATCHER
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Parts Catcher	*****>
@NO_CON-DEBUG

#EJECT2=DATA2(69)
%IF #EJECT=#FUNNY %THEN #EJECT2=#FUNNY


;Sequence Definition^<459>Parts Catcher^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^PARTCATCHER^EJECT^RETR-EJECT^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[PARTCATCHER]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#MCODE=36]>



%ENDM

*
*	*****************************************
*	*	Tab Name	:	Swarf Conveyor		*
*	*****************************************
*
%PROCEDURE=CODECON_SWARF
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Swarf Conveyor	*****>
@NO_CON-DEBUG

;Sequence Definition^<4183>Swarf Conveyor^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^CONVEYOR^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^[DELETE]^[BLKNUM]^[CONVEYOR]
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#SWARFMCODE=36]>



@END
%ENDM

*
*	*************************************************
*	*	Tab Name	:	Warnings        			*
*	*************************************************
*
%PROCEDURE=CODECON_WARNING

%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Warnings	*****>
@NO_CON-DEBUG

%IF MASK=0 %THEN #WARNCOUNT=#WARNCOUNT+1

;Sequence Definition^<1011>Warnings^-1^<903>Miscellaneous^
;Use Tokens^DELETE^BLKNUM^WARNING^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^* ^[WARNING]
<* [$WARNING]>



%ENDM

*
*	*****************************************
*	*	Tab Name	:	Turret park		*
*	*****************************************
*
%PROCEDURE=CODECON_PARK
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Turret Park	*****>
@NO_CON-DEBUG


;Sequence Definition^<3794>Turret Park^-1^<902>General Motion^
;Use Tokens^DELETE^BLKNUM^SAFEBLKNUM^RAPIDGCODE^PARK_POSITION^XMOVE^XPARK^XTURRETPK^XPARKINC^ZMOVE^ZPARK^ZTURRETPK^ZPARKINC^LBRKT^RBRKT^TURRETNO^TURRETNO_ATC^LENGTHOFFSET^COMMENT^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^( Turret Park )
;Default Sequence^[DELETE]^[BLKNUM]^ G0^[TURRETNO_ATC]
;Default Sequence^[DELETE]^[BLKNUM]^[<C>RAPIDGCODE]^[XMOVE]^[ZMOVE]
;TEXT^If a G30 style move is used, check the reference point
;TEXT^Note XMOVE etc give tool tip in CPL Coords
;TEXT^         XPARK etc give tool tip in MC Coords
;TEXT^ XTURRETPK etc give turret datum position in MC Coords
<( Turret Park )>
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39] G0[POSITION=19]>
%CALL=PT_BINC
#GCODE=DATA1(1)
%CANCEL=#GCODE
<[#DELETE=43][#BNUM=39][#GCODE=38][#XMOVE=0][#ZMOVE=2]>










@END
%ENDM



%PROCEDURE=CODECON_UNPARK
*
%IF $CONDEBUG=N @NO_CON-DEBUG
<*****	Code Constructor	:	Turret UnPark	*****>
@NO_CON-DEBUG


;Sequence Definition^<3795>Turret UnPark^-1^<902>General Motion^
;Use Tokens^SAFESTART^DELETE^BLKNUM^SAFEBLKNUM^WORKGCODE^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^( Turret UnPark )
;Default Sequence^[DELETE]^[BLKNUM]^[WORKGCODE]
;TEXT^SAFESTART calls Safe Restart Code Constructor
<( Turret UnPark )>
%CALL=PT_BINC
<[#DELETE=43][#BNUM=39][#WORKGCODE=41]>





@END
%ENDM


****************************************************
************ MACHINE SPECIFIC PROCEDURES ***********
****************************************************

%PROCEDURE=SET_FEEDGCODE
%IF #PROCTRACE=1 %THEN $PROCEDURE=SET_FEEDGCODE:%CALL=ENTER_PROCEDURE
* Allows for machine variants, specifically Okuma

#GCODE=DATA1(2)
%IF #EXACTSTOP=2 %THEN #GCODE=DATA1(9)

@DONE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM



************ Stub for Okuma specific codecon
%PROCEDURE=CODECON_START_TURN_CYCLE
%ENDM

************ Stub for G200 specific procedure
%PROCEDURE=G200_LONGHAND_RAPID
%ENDM

%PROCEDURE=G200_SET_REVERSE
%ENDM

%PROCEDURE=DIVERT_CYCLSUB_RAPID
%IF #PROCTRACE=1 %THEN $PROCEDURE=DIVERT_CYCLSUB_RAPID:%CALL=ENTER_PROCEDURE
* Procedure to enable varying route for G200 processing

%CALL=PT_OUTPUT_RAPID

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=DIVERT_CYCLSUB_FEED
%IF #PROCTRACE=1 %THEN $PROCEDURE=DIVERT_CYCLSUB_FEED:%CALL=ENTER_PROCEDURE
* Procedure to enable varying route for G200 processing

%CALL=PT_OUTPUT_FEED

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=DIVERT_CYCLSUB_ARC
%IF #PROCTRACE=1 %THEN $PROCEDURE=DIVERT_CYCLSUB_ARC:%CALL=ENTER_PROCEDURE
* Procedure to enable varying route for G200 processing

%IF RADIUS<0 %THEN %CALL=CODECON_CIRCULAR-INT-CLW %ELSE %CALL=CODECON_CIRCULAR-INT-CCLW

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM



*
*********************************
*
*  Code Wizard Templates
*  File Turn-Iso-Macros.cgi
*
*********************************
*
* Created from old templates 10 June 2003
* Placed under change control
* Richard Halton
*
* File contains basic macro definitions for
* turning templates based on generic ISO codes.

*Change Control
* 14/11/03 RHA DEV00009364 Correct coolant settings
* 18/11/03 RHA DEV00009247 Remove macro 110 and procedure
* 05/12/03 RHA DEV00007048 Add Rigid Tapping Option
* 10/12/03 RHA DEV00009413 Template type settings
* 15/12/03 RHA DEV00009616 Remove all Q67 series uservars
* 13/01/04 RHA DEV00009819 Correct ;IF in rapid and linear macros
* 27/01/04 RHA DEV00009901 Runtime mode switch for rotary output
* 05/02/04 RHA DEV00010058 Move all thread processing to procedure and add spindle conrol check
* 10/02/04 RHA DEV00004642 Through tool coolant switched by Toolstore setting
* 30/03/04 RHA DEV00010705 Correct uservar3 in CY hole cycle macros
* 09/06/04 RHA DEV00011069 TLO Q var fix & new procedure
* 15/07/04 RHA DEV00008178 Add multi level/depth to hole cycles
* 27/07/94 RHA DEV00011481 Replace HOLD and NOMOTION mechanism
* 03/08/04 RHA DEV00011616 Correct HOLD settings in Macro=45 (Scratch values)
* Version 9.5
* 05/11/04 RHA DEV00012467 Correct macro list for 2AX lathes
* 07/12/04 RHA DEV00012698 Manual option for Polar control
* Version 9.75
* 04/03/05 RHA DEV00012877 Use XCPL etc to reset HOLD values after B movement and at ToolChange
* 30/03/05 RHA DEV00011967 Reset threading flags off in macros 46 and 47
* Version 10
* 18/05/05 RHA DEV00013860 Implement direct procedure call for manual polar control
* 19/05/05 RHA DEV00013860 Rotary cartesian macro should be in CY macros area
* 23/05/05 RHA DEV00014071 Correct direction reference in CY tapping macro
* 31/05/05 RHA DEV00014025 Fix peck depth for chipbreak cycles
* 10/06/05 RHA DEV00013861 Correct BHOLD test in Macro=45
* 11/07/05 RHA DEV00013853 Correct CAX Tool and Home for lower turret
* 24/04/06 RHA DEV00014455 Implement spindle brake controls
* Version 11.0
* 07/08/06 RHA DEV00017645 Add C_AXIS_SELECT calls
* Version 11.5
* 27/10/06 RHA DEV00018477 Static drill processing
* 21/12/06 RHA DEV00018876 Correct coolant codes for sub spindle
* 26/01/07 RHA DEV00019085 Create and call PMACRO-12, Fix CRC register
* 05/02/07 RHA DEV00019146 Chamfer thread mode
* Version 11.75
* 03/04/07 RHA DEV00019655 Implement 21 flag in rotary rotate
* Version 12.25
* 03/12/07 RHA DEV00021534 Enable longhand tapping
* Version 12.50
* 18/01/08 RHA DEV00021841 Trap longhand with subroutines for holes
* 05/02/08 RHA DEV00006310 Canned cycles in Rotary Rotate
* Version 2009.1
* 22/04/08 RHA DEV00023110 Constant offset token etc for turn cycles
* 23/04/08 RHA DEV00023110 Use 64 modifier instead of 50.
* 28/04/08 RHA DEV00022293 Correct checking of SUBFUNCT in coolant macro
* 07/05/08 RHA DEV00017908 Improve axis reversal mechanisms
* 07/07/08 RHA DEV00023548 M Function to suspend NC Code output
* 23/07/08 RHA DEV00024116 Correct NC Suppression in macro 41
* 07/08/08 RHA DEV000022514 Allow polar switching at B0 and B180
* 13/08/08 RHA DEV00023795 Implement Back Bore & Face and Helical hole cycles
* Version 2009.2
* 07/11/08 RHA DEV00025098 Make tool angle available in setup & core tool change
* 26/01/09 RHA DEV00025914 Add attribute_extension to macros and whiteboard
* 09/03/09 RHA DEV00026386 Incorrect use of #USER18
* 13/03/09 RHA DEV00026483 Set #MACRO in macro 256
* 01/04/09 RHA DEV00025920 Add macros for turret parking
* 03/04/09 RHA DEV00026690 Set #THRDFLAG in macro 163
* 07/04/09 RHA DEV00026987 Make park macros available in all configurations
* Version 2010.1 SP1
* 29/10/09 RHA W32267 Correct use of #BNUMHOLD in %MACRO=SUBEND
* Version 2010.2
* 11/11/09 RHA W36658 Add new Thread Mill and canned cycle
* 12/11/09 RHA W36737 Move some macro logic to procedures
* 16/11/09 RHA W36658 Remove CRC settings from macro
* 24/11/09 RHA W33740 Improve Exact Stop Handling
* 08/12/09 RHA W35163 Add FEED modifier to macro 672
* 12/01/10 RHA W36917 Rationalise PT_SET_TOOL_POS, phase 1 split turn and CY
* Version 2011.1
* 26/07/10 RHA W39888 Correct thread mill dialog fields
* 03/08/10 RHA W40229 Move Attribute macro processing to a procedure
* 27/08/10 RHA W36797 Set G code just before code con call. Radial Arcs
* 07/09/10 RHA W40572 Ream, Bore, Chipbreak in fixed hole cycles
* 09/09/10 RHA W40572 Tidy CY hole longhand checking
* Version 2011.2
* 24/11/10 RHA W40496 Always round B and C values before use
* 30/11/10 RHA W36982 Polar Auto over-ride, use new procedure
* 13/12/10 RHA W42051 Add DEPTH (modifier 10) to tap cycle macros
* Version 2012.1
* 09/06/11 RHA W30038 Turning cycles safe approach (rough Turn)
* 09/06/11 RHA W30605 Implement Rough Profile canned cycle
* 03/08/11 RHA W42241 Improve helical taper warning for 675 cycle
* 16/08/11 RHA W36919 Add Programmable Tailstock processing
* 17/08/11 RHA W30605 Rough Profile canned cycle incomplete - removed
* Version 2012.2
* 25/10/11 RHA W30038 Safe approach for finish turn
* 31/10/11 RHA W43616 implement Swarf Conveyor on/off control
* 03/11/11 RHA W47190 Add data and controls for Steadies
* 26/04/12 RHA W49996 Correct use of Q206
* 26/04/12 RHA W50291 Correct parameter list on MACRO=501 (Steady)
* Version 2013.1
* 13/06/12 RHA W50240 Old tailstock, variable names mismatch fixed
* Version 2013.2
* 16/05/13 RHA W54506 Remove [] from Macro=109 definition
* Version 2014.1
* 24/09/13 RHA W56677 Implement new coolant controls
* Version 2014.2
* 19/11/13 RHA W61589 Implement additional turrets
* 13/03/14 RHA W55288 Add Customisation breakout calls
* 14/05/14 RHA W65095 Implement datum Shift in turning
* Version 2015.2
* 08/01/15 RHA W35019 Add prog stop and comment to Rapid Home and TC
* 28/04/14 RHA W67046 Force C in index for Rotary Rotate (Planar)
*
*

;
;___________________________________________________________ Macro = 1 _____
;
%MACRO=1=RA=Rapid move=1,2,
$SPC=" "; Reset trace spacing
#MACRO=1
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%CALL=PMACRO-1
@END
%ENDM
;
;___________________________________________________________ Macro = 2 _____
;
%MACRO=2=FE=Feed move=1,2,5,7,
$SPC=" "; Reset trace spacing
#MACRO=2
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%CALL=PMACRO-2
@END
%ENDM
;
;___________________________________________________________ Macro = 3 _____
;
%MACRO=3=TU=Simple turning cycle=1,2,5,7,10,-21,202,189|176,78|179,
$SPC=" "; Reset trace spacing
#MACRO=3
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-3
%ENDM
;
;___________________________________________________________ Macro = 4 _____
;
%MACRO=4=RT=Rough turn area clearance=5,7,10,30,31,-21,40,41,64,135,78|180,
$SPC=" "; Reset trace spacing
#MACRO=4
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-4
%ENDM
;
;___________________________________________________________ Macro = 5 _____
;
%MACRO=5=PR=Profiling cycle=5,7,30,31,-21,64,78|186,
$SPC=" "; Reset trace spacing
#MACRO=5
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-5
%ENDM
;
;___________________________________________________________ Macro = 6 _____
;
%MACRO=6=RG=Rough grooving cycle=4,5,7,10,30,31,-21,
$SPC=" "; Reset trace spacing
#MACRO=6
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
#INTHRD=#FALSE
%NOCYCLE                       ;NO CANNED CYCLE AVAILABLE
%ENDM
;
;___________________________________________________________ Macro = 7 _____
;
%MACRO=7=FG=Finish grooving cycle=4,5,7,30,31,-21,
$SPC=" "; Reset trace spacing
#MACRO=7
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
#INTHRD=#FALSE
%NOCYCLE                       ;NO CANNED CYCLE AVAILABLE
%ENDM
;
;___________________________________________________________ Macro = 8 _____
;
%MACRO=8=..=Threading Cycle=4,12,9,10,7,-21,206,207,208,78|182,
$SPC=" "; Reset trace spacing
#MACRO=8
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-8
%ENDM
;
;___________________________________________________________ Macro = 9 _____
;
%MACRO=9=DR=Drill cycle=1,10,5,7,21,73,27,203,50,53|176,200,201,
$SPC=" "; Reset trace spacing
#MACRO=9
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-9
%ENDM
;
;
;___________________________________________________________ Macro = 9 _____
;
%MACRO=265=CB=Chip break cycle=1,10,5,7,21,73,27,203,50,53|176,200,201,
$SPC=" "; Reset trace spacing

#MACRO=265
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%CALL=PMACRO-265
%ENDM
;
;
;___________________________________________________________ Macro = 9 _____
;
%MACRO=266=RE=Ream/Bore cycle=1,10,5,7,21,73,27,203,50,53|176,200,201,
$SPC=" "; Reset trace spacing

#MACRO=266
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%CALL=PMACRO-266
%ENDM
;
;
;___________________________________________________________ Macro = 9 _____
;
%MACRO=267=BO=Bore cycle=1,10,5,7,21,73,27,203,50,53|176,200,201,
$SPC=" "; Reset trace spacing

#MACRO=267
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%CALL=PMACRO-267
%ENDM
;
;___________________________________________________________ Macro = 10 _____
;
%MACRO=10=TA=Tapping cycle=1,7,10,12,27,21,203,200,201,
$SPC=" "; Reset trace spacing
#MACRO=10
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-10
%ENDM
;
;___________________________________________________________ Macro = 11 _____
;
%MACRO=11=RP=Rough profiling cycle=4,5,7,10,30,31,-21,78|180,
$SPC=" "; Reset trace spacing
#MACRO=11
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

#INTHRD=#FALSE
%NOCYCLE
* %CALL=PMACRO-4
%ENDM
;
;___________________________________________________________ Macro = 12 _____
;
%MACRO=12=CD=Change tool datum=13,201,
$SPC=" "; Reset trace spacing
#MACRO=12
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-12

%ENDM
;
;___________________________________________________________ Macro = 14 _____
;
%MACRO=14=MR=Move relative to profile=50,49,60,59,7,5,
$SPC=" "; Reset trace spacing
#MACRO=14
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%NOCYCLE
%ENDM
;
;___________________________________________________________ Macro = 15 _____
;
%MACRO=15=TL=Toolchange=8,12,13,24,80,47,48,16,15,201,202,203,206,
$SPC=" "; Reset trace spacing
#MACRO=15
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-15
%ENDM




;
;___________________________________________________________ Macro = 17 _____
;
%MACRO=17=DA=Select cutter drive angle=24,25,17,
$SPC=" "; Reset trace spacing
#MACRO=17
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%ENDM
;
;___________________________________________________________ Macro = 18 _____
;
%MACRO=18=CA=Select tool clearance angles=28,29,17,
$SPC=" "; Reset trace spacing
#MACRO=18
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%ENDM
;
;___________________________________________________________ Macro = 19 _____
;
%MACRO=19=SD=Set safe retract distances=1,2,
$SPC=" "; Reset trace spacing
#MACRO=19
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
#XSAFE=XSAFE:#ZSAFE=ZSAFE
%ENDM
;
;___________________________________________________________ Macro = 22 _____
;
%MACRO=22=DW=Dwell=27,
$SPC=" "; Reset trace spacing
#MACRO=22
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #SKIPTAP=1 %THEN #SKIPTAP=#FUNNY:%GOTO @END
%IF #NCSUPPRESS=1 %THEN MASK=1
%CALL=CODECON_DWELL
@END
%ENDM
;
;___________________________________________________________ Macro = 29 _____
;
%MACRO=29=NC=Compensation==Off/Left/Right/Pathcomp
$SPC=" "; Reset trace spacing
#MACRO=29
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-29
%ENDM
;
;___________________________________________________________ Macro = 32 _____
;
*
%MACRO=32=..=TRANSLATE=45,23[0],14,26,37,-21,
$SPC=" "; Reset trace spacing
#MACRO=32
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

#INTHRD=#FALSE
%CALL=PMACRO-32
%ENDM
*
;
;___________________________________________________________ Macro = 36 _____
;
*
%MACRO=36=TC/TM/TF=Select cut type override=85,
$SPC=" "; Reset trace spacing
#MACRO=36
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%ENDM
*
;
;___________________________________________________________ Macro = 40 _____
;
*
%MACRO=40=RH=Rapid to home=100,101,103,15,209,
$SPC=" "; Reset trace spacing
#MACRO=40
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-40
%ENDM
*
*
%MACRO=41=CH=Rapid to tool change=100,101,103,15,209,
$SPC=" "; Reset trace spacing
#MACRO=41
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-41

%ENDM
;
;___________________________________________________________ Macro = 46 _____
;
%MACRO=46=MR=Move Relative 2=59,7,5,
$SPC=" "; Reset trace spacing
#MACRO=46
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
#INTHRD=#FALSE:#THREADING=#FALSE
%NOCYCLE
%ENDM
;
;___________________________________________________________ Macro = 47 _____
;
%MACRO=47=MR=Move Constrain=59,7,5,
$SPC=" "; Reset trace spacing
#MACRO=47
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
#INTHRD=#FALSE:#THREADING=#FALSE
%NOCYCLE
%ENDM
*
;
;___________________________________________________________ Macro = 48 _____
;

%MACRO=48=..=Datum Shift=
$SPC=" "; Reset trace spacing
#MACRO=48
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%GETCPL=SUBFUNCT
%CALL=PMACRO-48
%ENDM

;
;___________________________________________________________ Macro = CLW _____
;
%MACRO=CLW
$SPC=" "; Reset trace spacing
#MACRO=53
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

#GCODE=DATA1(3)
%CALL=PMACRO-ARCS

%ENDM
*
*
;
;___________________________________________________________ Macro = CCLW _____
;
%MACRO=CCLW
$SPC=" "; Reset trace spacing
#MACRO=54
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

#GCODE=DATA1(4)
%CALL=PMACRO-ARCS

%ENDM
;
;___________________________________________________________ Macro = 55 _____
;
%MACRO=SUBSTART
$SPC=" "; Reset trace spacing
#MACRO=55
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
*	If Increment Subroutines by ... is not set then start at Progid & increment by one else use the increment.
%IF #INCRSUBNUMBER=#FUNNY %THEN #SUBROUTINE=SUBROUTINE+#SUBNOSTART %ELSE #SUBROUTINE=(SUBROUTINE*#INCRSUBNUMBER)+#SUBNOSTART
*
%IF MASK=1 @SKIP
*
%IF #RESTARTSUBSBNUM=#TRUE %THEN #BNUMHOLD=#BNUM:#BNUM=0			;	Restart Block numbering for Subprograms
*
STARTSUB=#BNUM ; this is necessary for subroutine start blocks ( not cyclsub )
*
*	If using incremental subroutines only, it is necessary to hardcode a G91 on extra Sequence definition line
%IF #INCRXYZHOLD=#TRUE @MAIN_PROG_IS_INCREMENTAL
%IF #INCRSUBS=#TRUE %THEN #INCRXYZ=#TRUE	; Set subs to incr if specified

@MAIN_PROG_IS_INCREMENTAL
%CALL=CODECON_SUBROUTINE-START
*
@SKIP
%ENDM
;
;___________________________________________________________ Macro = 56 _____
;
%MACRO=SUBEND
$SPC=" "; Reset trace spacing
#MACRO=56
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
#ROTROT=0 ; Cancel Rotary rotate mode

*				Only applies to Subprogram style NOT inline block number reference.
%IF #BNUMHOLD=#FUNNY @SKIP
%IF #RESTARTSUBSBNUM=#TRUE %THEN #BNUM=#BNUMHOLD			;	Restart Block numbering for Subprograms - re-instate sequence number
@SKIP
*
ENDSUB=#BNUM ; this is necessary for subroutine end block to be set up
%IF $MACHINE="NUM750T" %THEN ENDSUB=#BNUM-(#BNUMINC*5) ; Reset blknum for NUM control
*
#INCRXYZ=#INCRXYZHOLD

%CALL=CODECON_SUBROUTINE-END
*
%ENDM

;
;___________________________________________________________ Macro = 59 _____
;

%MACRO=SUBCALL
$SPC=" "; Reset trace spacing
#MACRO=59
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PT_OUTPUT_SUBCALL

%ENDM



;
;___________________________________________________________ Macro = Reset
;

%MACRO=RESET
$SPC=" "; Reset trace spacing
#MACRO=60
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%IF PATHTRACE=1 @END			;	Skip Datum Reset if processing longhand

* Reset is only needed if absolute subroutines have been used with G92 datum setting
%IF #INCRSUBS=#TRUE @END

* Update stored end point (XINC etc in Reset are TOTAL increments for this level)
#XHOLD=#XHOLD+YINC
#ZHOLD=#ZHOLD+XINC
*<*HOLD2 [#XHOLD=0] [#YHOLD=1] [#ZHOLD=2] >

* Final G92 position.
#XMOVE=#XHOLD ;+(XMOVE-XSUB)
#ZMOVE=#ZHOLD ;+(ZMOVE-ZSUB)

#GCODE=DATA1(24)

%CALL=CODECON_TRANSLATE_RESET

@END
%ENDM


;
;___________________________________________________________ Macro = 61 _____
;
%MACRO=CYCLSUB
$SPC=" "; Reset trace spacing
#MACRO=61
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-61
%ENDM

;
;___________________________________________________________ Macro = 71 _____

%MACRO=71=..=ATTRIBUTE=
$SPC=" "; Reset trace spacing
#MACRO=71
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PT_ATTRIBUTE_CONTROL


%ENDM



;
;___________________________________________________________ Macro = 673/4 _____
;

%MACRO=673=..=Turret Park=
$SPC=" "; Reset trace spacing
* Turret parking macro
#MACRO=673
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%CALL=PMACRO-673

%ENDM

%MACRO=674=..=Turret Unpark=
$SPC=" "; Reset trace spacing
* Turret un-parking macro
#MACRO=674
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%CALL=PMACRO-674

%ENDM

******************************************
******************************************
* Miscellaneous "User Defined" Macros : Reserved
******************************************
******************************************

*	101		Spindle				Spindle Stop/Spindle Forward/Spindle Reverse
*	102		Set Chord			Numerical input - used in Arc => Linear interpolation
*	103		Stop				Program/Optional
*	104		Coolant				Coolant Off/Coolant Flood/ Coolant Auto
*	105		Block Skip			Block Skip Off/Block Skip On
*	106		Exact Stop			Off/On
*	107	    XC Interpolation	Active/Inactive
*	108		Comment				Text string input - Operator message
*	109		Insert NC Code		Nc code literal input
*	110		Gear Range			Gear 1/Gear 2/Gear 3/ Gear 4
*	111		Chuck				Chuck  Close/Chuck Open
*	112		Quill				Quill Retract/ Quill Advance
*	113		Index Turret		Clockwise/Counterclockwise
*	114		Tailstock			Tailstock Advance/Tailstock Retract
*	115		Parts_Catcher		Catcher Retract/Catcher Advance
*	116		Length_Offset		numeric input for tool length offset register
*	117		Chuck Pressure		High / Low
*	118		Work Coord			G54/G55/G56/G57/G58/G59
*	119		Multi-plane Output	World / Cpl
*	120		Bar Feed            Speed, Feed, tool Pos, Start Z, End Z
*	121     Spindle Brake		On/Off/Low/Auto
*	122     Spindle Synchronisation	None/Speed/Phase
*	123     Rotary Cartesian	On/Off
*	124     NC Code Output Suspension  On/Off
***************************************************************

;
;___________________________________________________________ Macro = 252 _____
;

%MACRO=252=..=Spindle Control=
$SPC=" "; Reset trace spacing
#MACRO=252
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-252

%ENDM
;
;___________________________________________________________ Macro = 103 _____
;
%MACRO=103=..=Stop Type==Program/Optional
$SPC=" "; Reset trace spacing
#MACRO=103
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
%IF SUBFUNCT=1 %THEN #MCODE=DATA2(1)			;	M00
%IF SUBFUNCT=2 %THEN #MCODE=DATA2(2)			;	M01
#RPM=NEXTSPEED:#SPEED=NEXTSPEED
%CALL=PT_SPINDLE

%CALL=CODECON_PROGRAM-STOP

%CANCEL=#XMOVE,#ZMOVE,#SPEED,#FEED

%ENDM
;
;___________________________________________________________ Macro = 104 _____
;
%MACRO=104=../..=Coolant=201,202,204,206,205,=Mist/Flood/Off/Air
$SPC=" "; Reset trace spacing
#MACRO=104
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-104

%ENDM
;
;___________________________________________________________ Macro = 105 _____
;
%MACRO=105=../..=Block Skip==Off/On
$SPC=" "; Reset trace spacing
#MACRO=105
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1


%IF SUBFUNCT=2 %THEN #DELETE=0 %ELSE #DELETE=#FUNNY
%ENDM
;
;___________________________________________________________ Macro = 106 _____
;
%MACRO=106=../..=Exact Stop==Off/On
$SPC=" "; Reset trace spacing
#MACRO=106
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-106

%ENDM
;
;___________________________________________________________ Macro = 107 _____
;                     Used for XC Interpolation - See below


;
;___________________________________________________________ Macro = 108 _____
;
%MACRO=108=..=Comment=15,
$SPC=" "; Reset trace spacing
#MACRO=108
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=CODECON_COMMENT

@END
%ENDM
;
;___________________________________________________________ Macro = 109 _____
;
%MACRO=109=..=Insert Nc Code=15,
$SPC=" "; Reset trace spacing
#MACRO=109
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=CODECON_INSERT-NC-CODE

%ENDM


;
;___________________________________________________________ Macro = 113 _____
;
%MACRO=113=..=Index Turret== Index Clw/Index CClw
$SPC=" "; Reset trace spacing
#MACRO=113
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%IF SUBFUNCT=1 %THEN #INDEXTURDIR=DATA2(20) %ELSE #INDEXTURDIR=DATA2(21)

#MANUALIDX=#TRUE
@END
%ENDM


;
;___________________________________________________________ Macro = 117 _____
;
%MACRO=117=..=Chuck Pressure==High/Low
$SPC=" "; Reset trace spacing
#MACRO=117
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-117

%ENDM
;
;___________________________________________________________ Macro = 256 (was 120) _____
;


%MACRO=256=..=Bar Feed=1,5,7,27,
$SPC=" "; Reset trace spacing
#MACRO=256
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-256


%ENDM

;
;___________________________________________________________ Macro = 121 _____
;
%MACRO=121=..=Spindle Brake==On/Off/Low/Auto
$SPC=" "; Reset trace spacing
#MACRO=121
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

#BRAKE=#FUNNY
%CALL=PT_SPIN_BRAKE

%ENDM

;
;___________________________________________________________ Macro = 124 _____
;
%MACRO=124=..=NC Code Output==Suspend/Resume
$SPC=" "; Reset trace spacing
#MACRO=124
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*

* This macro allows the user to suspend NC code via a misc function
* Note that it relies on MASK being reset by Code Generator for each macro call
* In each macro -  %IF #NCSUPPRESS=1 %THEN MASK=1

%IF SUBFUNCT=2 @RESUME
* Suspend NC Code Output
#NCSUPPRESS=1
%GOTO @END

@RESUME
#NCSUPPRESS=0

@END
%ENDM

******************************************
******************************************
***** template defined macros 4xxx series
******************************************
******************************************
*
*  Record of 4xxx numbers allocated
* Macro 4001 Swarf Conveyor


%MACRO=4001=..=Swarf Conveyor==On/Off
$SPC=" "; Reset trace spacing
%IF #NCSUPPRESS=1 %THEN MASK=1
#Macro=4001
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*

%CALL=PMACRO-4001

@END
%ENDM





;
;___________________________________________________________ Macro = 257 _____
;
%MACRO=257=..=Chuck=
$SPC=" "; Reset trace spacing
#MACRO=257
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1
* FIELD1 (1=Open, 2=Closed)
%IF #SPINDLE=SPINDLEID2 @SECOND

* Main Spindle
%IF FIELD1=1 %THEN #MCODE=DATA2(16)
%IF FIELD1=2 %THEN #MCODE=DATA2(17)
%GOTO @GO

* Second Spindle
@SECOND
%IF FIELD1=1 %THEN #MCODE=DATA6(16)
%IF FIELD1=2 %THEN #MCODE=DATA6(17)


@GO
%CALL=CODECON_CHUCK-OPEN

%ENDM

;
;___________________________________________________________ Macro = 258 _____
;

%MACRO=258=..=Part Catcher=
* FIELD1 (1=Advance, 2=Retract)
* FIELD2 (1=Eject)
$SPC=" "; Reset trace spacing
#MACRO=258
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%IF FIELD1=1 %THEN #MCODE=DATA2(24)
%IF FIELD1=2 %THEN #MCODE=DATA2(25)
%IF FIELD2=1 %THEN #EJECT=DATA2(68) %ELSE #EJECT=#FUNNY
%CALL=CODECON_PARTS-CATCHER

%ENDM


;
;___________________________________________________________ Macro = 259 _____
;

%MACRO=259=..=Tailstock=
* FIELD1 (1=Advance, 2=Retract)
* FIELD2 (1=Quill)
$SPC=" "; Reset trace spacing
#MACRO=259
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%IF FIELD2=1 @QUILL

%IF FIELD1=1 %THEN #MCODE=DATA2(29)
%IF FIELD1=2 %THEN #MCODE=DATA2(28)
#MCODE3=#MCODE ; Indirect but preserves possible workrounds
%CALL=CODECON_TAILSTOCK
%GOTO @END

@QUILL
%IF FIELD1=1 %THEN #MCODE=DATA2(30)
%IF FIELD1=2 %THEN #MCODE=DATA2(31)
#MCODE2=#MCODE ; Indirect but preserves possible workrounds
%CALL=CODECON_TAILSTOCK-QUILL

@END
%ENDM





;
;___________________________________________________________  Macro = 716
;

%MACRO=716=..=Coolant=
$SPC=" "; Reset trace spacing
#MACRO=716
* New macro drives availability of new coolant options
%IF NOCYCLE=0 %THEN #EXECMACRO=#MACRO
%CALL=CODECON_BREAKOUT
*
%IF #NCSUPPRESS=1 %THEN MASK=1

%CALL=PMACRO-716  ; Process coolant and tap settings

@END
%ENDM
*
*********************************
*
*  Code Wizard Templates
*  File Turn-Procedures.cgi
*
*********************************
*
* Created from old templates 10 June 2003
* Placed under change control
* Richard Halton
*
* File contains all procedures for basic turn templates.
*
*********************************
*
*  Macro related procedures
*
*********************************

* 20/08/03 RHA DEV00008484 Correct multi-start threads in single block cycles.
* 26/08/03 RHA DEV00008539 Add warnings counter
* 18/11/03 RHA DEV00009387 Speed settings at ToolChange etc.
* 18/11/03 RHA DEV00009247 Remove macro 110 and procedure
* 20/11/03 RHA DEV00009231 Combined spindle and coolant codes added
* 28/11/03 RHA DEV00009456 AVN Feedback - Safe block numbering & Tool Change options
* 10/12/03 RHA DEV00009413 Template type settings
* 12/12/03 RHA DEV00009610 Remove automatic speed correction from out of limit warnings
* 13/01/04 RHA DEV00005023 Set M code to GEARCODE system variable
* 13/01/03 RHA DEV00009413 Template type setting corrections
* 20/01/04 RHA DEV00009702 Correct type filter in PMACRO-15
* 21/01/04 RHA DEV00008184 Correct use of #SBNUMCOUNT
* 26/01/04 RHA DEV00009968 Correct safe block numbering
* 26/01/04 RHA DEV00009902 Correct Z reverse at tool change
* 26/01/04 RHA DEV00009953 Split procedure for second leg return to ToolChange
* 27/01/04 RHA DEV00009918 Increment BNUM in CYCLESUB without output
* 21/01/04 RHA DEV00008184 Changes for Integrex
* 27/01/04 RHA DEV00008184 Integrex - Correct Z reverse on sub spindle (driven tools)
* 29/01/04 RHA DEV00010032 Speed range check correction (look ahead for RPM for macro 1)
* 02/02/04 RHA DEV00010088 Add diametral switches for axial/radial machining
* 03/02/04 RHA DEV00008669 Cycle sub turn/face switching on DEPTH setting
* 05/02/04 RHA DEV00010058 Check for spindle priority when tapping or threading (turn mode)
* 05/02/04                 Output all warnings via code constructor to increment count
* 09/02/04 RHA DEV00010058 Remove "abandon" from thread check
* 10/02/04 RHA DEV00010088 Correct #DIAM switching
* 09/02/04 RHA DEV00010058 Reinstate NOCYCLE in thread check
* 12/02/04 RHA DEV00010219 Correct RPLANE setting - fixed reverse axial
* 13/02/04 RHA DEV00010219 Separate Z reverse switch for sub spindle driven tools
* 13/02/04 RHA DEV00004642 PMACRO-15 Through tool coolant for static tools
* 09/03/04 RHA DEV00008840 Correct arc planes for CY arcs
* 11/03/04 RHA DEV00010538 Correct second leg code con calls
* 11/03/04 RHA DEV00010521 CSS speed check optional
* 22/03/04 RHA DEV00010537 Correct retract G codes
* 24/03/04 RHA DEV00010648 Correct priority check
* 01/04/04 RHA DEV00010560 Correct Z reversal of driven tools
* 05/04/04 RHA DEV10544 & 10738 Coordinate system corrections, rotary mode
* Version 900
* 16/04/04 RHA DEV00010784 Remove #FEED=#FUNNY from PT_OUTPUT_RAPID
* 16/04/04 RHA DEV00010783 Control all speed checks on CSS speed check switch
* 07/05/04 RHA DEV00010784 Add more spindle select variants,driven tool
*                          Procedure for driven tool codes to allow for subspindle
* 10/05/04 RHA DEV00010872 Correct spindle stop M Codes. Case of Data2 should be DATA2
* 20/05/04 RHA DEV00010961 Reinitialise #G54 etc for End code constructor
* 21/05/04 RHA DEV00010783 & 10710 Correct Gear setting and CSS warnings
* 08/06/04 RHA DEV00010896 Threadmill comp corrections
* 09/06/04 RHA DEV00011069 TLO fixes, new procedure
* 12/07/04 RHA DEV00011377 Correct calls in CALL_TC
* 13/07/04 RHA DEV00011406 Correct G72 (Cyclsub) when ending on an arc
* 16/07/04 RHA DEV00010973 Correct Tool Change HOLD
* 16/07/04 RHA DEV00011439 Spindle code selection for non CY machines
* 27/07/04 RHA DEV00011481 Replace HOLD and NOMOTION mechanism
* 29/07/04 RHA DEV00011481 Put new procedures in basic file
* 29/07/04 RHA DEV00011469 Add X Reversal options
* 03/08/04 RHA DEV00010179 Allow for zero spindle speed in PT_SPINDLE
* 04/08/04 RHA DEV00011481 Correct #POLAR value in Evaluation
* 06/08/04 RHA DEV00011316 Default start for rough turn cycle at HOLD
* Version 9.5
* 09/11/04 RHA DEV00011316 Correct G71 approach & depth
* 06/12/04 RHA DEV00012699 Restructure #DIAM calculations PT_MODIFIERS
* 10/12/04 RHA DEV00012305 Correct axial move plunge feeds
*                          Do not reset WORKGCODE for CAXIS=3 in Spindle Control
* 14/12/04 RHA DEV00012767 Prevent unwanted through tool coolant codes
* 22/12/04 RHA DEV00012877 Use XSCRATCH etc to suppress unwanted moves after toolchange
* 23/12/04 RHA DEV00012874 Turning Spindle Stop token
* 19/01/05 RHA DEV00013021 Correct Synch Turret Speeds
* 19/01/05 RHA DEV00010896 Threadmill comp corrections in PMACRO-29
* Version 9.75
* 16/02/05 RHA DEV00013394 Check Nomotion result in cyclsub_arc
* 16/02/05 RHA DEV00013309 Correct spindle brake - sub spindle when called from token
* 23/02/05 RHA DEV00012720 Option on turn cyclsub end point (Okuma)
* 25/02/05 RHA DEV00012893 Change static/driven switching to CAXIS flag
* 04/03/05 RHA DEV00012877 Use XCPL etc to reset HOLD values after B movement and at ToolChange
* 07/04/05 RHA DEV00012720 Avoid co-linears and allow for ending with arc
* Version 10
* 20/05/05 RHA DEV00013838 Add Retract Plane option to Holes and CY Holes
* 23/05/05 RHA DEV00013934 Correction to Datum Set output
* 27/05/05 RHA DEV00013912 Set C Hold values #FUNNY for running spindles
* 31/05/05 RHA DEV00013988 Correct #ZCLEAR setting
* 02/06/05 RHA DEV00013972 Allow use of user selected datums
* 02/06/05 RHA DEV00013861 Make HOLD values available at code constructors again
* 07/06/05 RHA DEV00014171 Correct coordinate initialisation for Lower Turret
* 08/06/05 RHA DEV00013972 Tweak
* 11/07/05 RHA DEV00013864 Stub procedure for lower turret assign
* 18/07/05 RHA DEV00014305 Correct Incremental output (Evaluate Move)
* 22/07/05 RHA DEV00014509 Correct Simple Turn Approach when X2Reversed
* 22/07/05 RHA DEV00013858 Correct thread approach checks
* 08/08/05 RHA DEV00014365 Correct CY_ANGLE calls, Evaluate_Move
* 18/08/05 RHA DEV00014693 Reinstate previous meaning for HOLD values, use KEEP values for #MOVE calculations
*                          Removed NOMOTION procedures, Call Evaluate_Move directly
* 22/08/05 RHA DEV00014693 Fix Polar_Off position re-initialisation - #RKEEP.
* 23/08/05 RHA DEV00014693 Correct #RKEEP, #C KEEP
* 26/08/05 RHA DEV00014693 CAXIS=0 in PT_SET_TOOL_POS
* 30/08/05 RHA DEV00014785 Force feed output after toolchange for safety
* 31/08/05 RHA DEV00014693 Do not set CHOLD values at driven toolchange
* 31/08/05 RHA DEV00014785 Do not "fix" sub spindle axial hole cycles
* 31/08/05 RHA DEV00014854 B Axis coordinate revese on sub-spindle
* 13/09/05 RHA DEV00013853 Correct blanked coords in moves to TC and Home
* 14/09/05 RHA DEV00014877 Corrections to PT_GEAR_MCODE
* 14/09/05 RHA DEV00014785 Correct XZ init for sub spindle tool changes
* 15/09/05 RHA DEV00013853 X reversal on lower turret
* 19/09/05 RHA DEV00014877 Set gear when spindle speed out of range
* 21/09/05 RHA DEV00015042 CRC reversal for lower turret turning
* 26/09/05 RHA DEV00015042 Use PT_FIX on expanded (longhand) hole cycles
* 30/09/05 RHA DEV00015213 Implement AutoCoolant option
* 03/10/05 RHA DEV00015042 Apply Automatic coolant on static tools
* 05/10/05 RHA DEV00015244 Flag G200 and do not apply PT_FIX
* 05/10/05 RHA DEV00015227 Axis reversals and Z lft for hole cycles
* 12/10/05 RHA DEV00015311 2CYBSS wont compile
* Version 10.5
* 27/10/05 RHA DEV00015445 PT_FIX Force G2/3 reverse if coords reversed
* 27/10/05 RHA DEV00015451 Arc plane correction
* 30/11/05 RHA DEV00015688 G41/2 reversal control on sub spindle
* 19/12/05 RHA DEV00015823 Spindle Clamp Control
* 25/01/06 RHA DEV00016090 Set flag for conditional through coolant token
* 25/01/06 RHA DEV00016091 Coolant fixes - NCO feedback
* 07/03/06 RHA DEV00015797 Correct single spindle lathe spindle/coolant codes
* Version 10.75
* 21/04/06 RHA DEV00014455 Combine two spindle clamping mechanisms
* 27/04/06 RHA DEV00016936 5 Axis cycle processing
* 09/05/06 RHA DEV00016963 5 Axis, B Move modality
* 10/05/06 RHA DEV00016963 5 Axis, Independent #DIAM setting
* 23/05/06 RHA DEV00017267 Correct spindle brake strategy for drill
* 23/05/06 RHA DEV00016340 Correct Baxis reversals on sub-spindle (Daewoo)
* 13/06/06 RHA DEV00017514 Corrections to #SPINDLE setting
* Version 11.0
* 19/07/06 RHA DEV00017604 Tool position initialisation in non-b axis posts
* 07/08/06 RHA DEV00017776 Add Spindle not started warning option
*                          Speed up Gear selection processing (on speed change only)
* 09/08/06 RHA DEV00017905 Correct ZCLEAR for Planar/Axial/SubSpindle holes
* 17/08/06 RHA DEV00017960 Correct second leg to toolchange for incremental
* 13/09/06 RHA DEV00018172 Correct KEEP reversals, lower turret driven radial
* 13/09/06 RHA DEV00017776 Correct use of spindle not started warning
* Version 11.5
* 20/09/06 RHA DEV00017909 Expand trace options
* 25/09/06 RHA DEV00018258 Correct pitch values for thread turn with incremental coords
* 29/09/06 RHA DEV00018205 Disable PT_CAX_REVERSE
* 10/10/06 RHA DEV00018318 Add PT_SET_TCMACRO for Siemens
* 27/10/06 RHA DEV00018477 Tidy static drill processing
* 06/11/06 RHA DEV00016817 Cancel TLO, control improvements
* 10/11/06 RHA DEV00018566 Initialise #POLARKEEP
* 17/11/06 RHA DEV00017343 Fix Tool change initialisation
* 01/12/06 RHA DEV00017360 Set plane G code for CYB arcs
* 15/12/06 RHA DEV00018824 PT_FIX only needed for B axis posts
* 10/01/07 RHA DEV00018968 Control of B axis reversal options
* 26/01/07 RHA DEV00019085 Create and call PMACRO-12, Fix CRC register
* 01/02/07 RHA DEV00016815 Correct conflicts in Rapid to TC priorities
* 01/02/07 RHA DEV00019149 Correct cyclsub X reversals
* 02/02/07 RHA DEV00019149 Correct use of #HOMETYPE
* 05/02/07 RHA DEV00019149 Correct KEEP values on first leg RtoTC
* 05/02/07 RHA DEV00016817 Modality of cancel TLO
* 06/02/07 RHA DEV00019146 Correct thread chamfer
* 07/02/07 RHA DEV00019203 Allow datum2 use on single spindle machine
* 12/02/07 RHA DEV00019241 Correct gear selection for CSS in ToolChange
* 14/02/07 RHA DEV00019241 Use NEXTSPEED in B Axis instructions
* Version 11.75
* 19/03/07 RHA DEV00019554 Correct precision of XCP YCPL ZCPL in use
* 11/04/07 RHA DEV00019431 Manual gear selection for CSS
*              DEV00015772 Set correct Gear for CSS (Maxrpm)
*              DEV00016792 Set Gear before speed set
* 12/04/07 RHA DEV00019259 Improve PT_SPINDLE efficiency
* 12/04/07 RHA DEV00019713 Implement output options for multi-turret - #BOTHSPEED
* 16/04/07 RHA DEV00015772 Set correct Gear for CSS (Maxrpm)
* 26/04/07 RHA DEV00019866 Set reference point flag in hole cycle processing
* Version 12.00
* 13/07/07 RHA F Spec      Spindle brake strategy enhancements
* 16/07/07 RHA F Spec      Length offset adjustment for Mazak sub spindle
* 20/07/07 RHA F Spec      Sub Spin TLO Offset on driven tools only
* 24/07/07 RHA DEV00020117 Use NEXTFEED in Rapid moves
* 26/07/07 RHA DEV00020117 Additional safeguards
* 02/08/07 RHA DEV00020531 Fix Incremental from Clearance option for hole cycles
* 22/08/07 RHA DEV00020771 Feedback from MCC, Force spin brake off before rot drill
* 12/09/07 RHA DEV00020957 Fix spindle direction for 2AXSS and 4AXSS
* 14/09/07 RHA DEV00021000 Sub spindle dir&coolant codes (remove Autocool check)
* 17/09/07 RHA DEV00021026 Correct spindle reversals for tapping,
* 18/09/07 RHA DEV00021048 Spindle clamping improvements
* 25/09/07 RHA DEV00021100 %CANCEL #BRAKE when forced
* 28/09/07 RHA DEV00021048 Correct brake setting for non-priority spindle
* Version 12.25
* 01/11/07 RHA DEV00021407 Fix lower turret coolant codes
* 07/11/07 RHA DEV00019862 Suppress V0 on lower turret
* 07/11/07 RHA DEV00014237 Fix YTOOL output in Rapid to Tool Change
* 14/11/07 RHA DEV00019151 Cycle sub coordinates not output by trace
* 03/12/07 RHA DEV00021534 Enable longhand tapping
* 05/12/07 RHA             Remove , from IF TEMPLATE=
* 12/12/07 RHA DEV00021534 Correct tapping recerse code con calls
* Version 12.50
* 15/01/08 RHA DEV00022062 Avoid PT_FIX in Five Axis mode
* 17/01/08 RHA DEV00021866 Fix turret indexing codes
* 04/02/08 RHA DEV00022182 Remove #USER1 line from SET_WORK_DATUMS
* 08/02/08 RHA DEV00006310 Correct spindle clamping for rotary rotate
* 04/03/08 RHA DEV00022639 Add 0 option for TLO
* 04/03/08 RHA DEV00022626 Remove divide by zero condition by correcting previous test
* 05/03/08 RHA DEV00022663 Correct lower turret Z (#WMOVE) initialisation at ToolChange
* 06/02/08 RHA DEV00022664 Clamping for sub spindle hole cycles
* 11/03/08 RHA DEV00022711 Use procedure for calculation
* 31/03/08 RHA DEV00023018 Allow selection of sub spindle from toolchange
* Version 2009.1
* 09/04/08 RHA DEV00022589 Convert Rapid to highfeed
* 10/04/08 RHA DEV00022717 5 Axis TLO
* 14/04/08 RHA DEV00018979 Correct BNUM reset
* 15/04/08 RHA DEV00022589 Convert Rapid to Feed in Thread blocks
* 16/04/08 RHA DEV00023153 Rapid to feed conversion mop up
* 16/04/08 RHA DEV00023153 Correct rapid after TC Turning, remove duplicate evaluation
* 18/04/08 RHA DEV00020823 EXACTSTOP corrections
* 21/04/08 RHA DEV00023153 Correction to nomotion in PT_OUTPUT_RAPID
* 24/04/08 RHA DEV00023153 Reset drill feed in case of rapid convert
* 25/04/08 RHA DEV00023211 Corrections to G92 cycle in incremental mode & streamline PT_OUTPUT_FEED
* 28/04/08 RHA DEV00023225 Static tool hole cycle should finish at clearance
* 29/04/08 RHA DEV00023211 Set #GCODE in PT_OUTPUT_FEED - used later as mode check
* 07/05/08 RHA DEV00017908 Improve axis reversal, move macro processing to procedures
* 08/05/08 RHA DEV00017908 Move user reversals to the Evaluate procedure
* 15/05/08 RHA DEV00017908 Rapid to ToolChange diagnostic output
* 20/05/08 RHA DEV00023415 Convert hole cycle approach to FEED when requested
* 20/05/08 RHA DEV00023415 PT_CALC_VECTOR_DISTANCE allow for Y movement
* 28/05/08 RHA DEV00017908 CYCLSUB Regression issue
* 02/06/08 RHA DEV00023523 Allow modality of X Z in G92 cycle, upper turret
* 04/06/08 RHA DEV00023549 Correction of addition of gauge lengths to turn tools
* 05/06/08 RHA DEV00023556 Conversion of short rapids to feed
* 05/06/08 RHA DEV00023554 Face-Turn approach move for Finish Turn in Cyclsub
* 06/06/08 RHA DEV00023415 Remove hole approach regressions
* 10/06/08 RHA DEV00017908 Move to toolchange regression (X reversal)
* 11/06/08 RHA DEV00023415 lower turret reversals
* 16/06/08 RHA DEV00023539 Call cancel cylindrical from PT_RAPID_TO_HOME_TOOLCHANGE
* 01/07/08 RHA DEV00023676 Correct RAWHOLD values in EVALUATE
* 09/07/08 RHA DEV00023795/7 Add back bore and helical hole cycle capability
* 09/07/08 RHA DEV00017908 Correct #IVALUE diameter and axis reversals
* 11/07/08 RHA DEV00023795 Correct template context selection & macro line
* 14/07/08 RHA DEV00023979/23368 Polar change position initialisation, Use KEEP values, #POLARKEEP track Y
* 15/07/08 RHA DEV00023979 Correct initialisation of reverse axial tool on lower turret
* 16/07/08 RHA DEV00023994 Remove call to PT_SET_TOOL_POS from Rapid to ToolChange
* 17/07/08 RHA DEV00023994 Correct use of PT_SET_TOOL_POS by Move Angular
* 08/08/08 RHA DEV00023233 Correct polar C0 check after hole cycle
* 18/08/08 RHA DEV00023554 Finish turn cycle start point
* 26/08/08 GST DEV00024002 TLO shift added to absolute hole depth
* 26/08/08 RHA DEV00024002 Apply TLO adjustment to depth and retract, absolute only
* 10/10/08 RHA DEV00025173 Correct use of reversal modifiers in turn cycles
* Version 2009.2
* 31/10/08 RHA DEV00025336 Unwrapped data errors
* 07/11/08 RHA DEV00025336 Prevent checking polarmove in Evaluate when planar
* 08/01/09 RHA DEV00022131 Allow Y reversals on driven tools
* 09/01/09 RHA DEV00025777 X Startin rough turn to use #DIAM, Z Start to use #ZREVERSE
* 16/01/09 RHA DEV00025921 Turret Parking for Integrex
* 20/01/09 RHA DEV00025921 Fix 2cy compilation
* 28/01/09 RHA DEV00022131 Further correct for I J reversals (-0)
* 04/02/09 RHA DEV00026063 Add force feedtype options
* 06/02/09 RHA             Correct leaving trace in new procedure
* 06/02/09 RHA             Correct feedtype for convert rapid to feed
* 04/03/09 RHA             Fixes for Z Feed
* 05/03/09 RHA DEV00026198 Use Job data instead of ASK questions
* 09/03/09 RHA DEV00026198 Fix PROGDESCR with PARTNAME default
* 10/03/09 RHA DEV00026063 Remove ZFEED setting for Radial tools
* 12/03/09 RHA DEV00026063 Maintain FPM when converted from Rapid. New flag
* 16/03/09 RHA DEV00026063 Correct #MOVE for 360deg milled arcs
* 17/03/09 RHA DEV00026063 Fix NEXTFEED for Rapids
* 17/03/09 RHA DEV00026542 CompGcode for rough turn canned cycles
* 19/03/09 RHA DEV00026542 Fix non-CY compilation problem
* 19/03/09 RHA DEV00026542 Block number count fixes, End Style Switching added
* 19/03/09 RHA DEV00026198 Correct PROGID default
* 20/03/09 RHA DEV00026542 Ignore option for move to start & blocknum fix
* 20/03/09 RHA DEV00026198 Change ASK default behaviour, Programmer & Version
* 23/03/09 RHA DEV00026690 Set #Feed=Pitch for tapping in FPR mode
* 24/03/09 RHA DEV00026742 Fix for ENDBNUM if return outside cycle
* 25/03/09 RHA DEV00025921 Turret UnPark - Remove B Axis diagnostic
* 25/03/09 RHA DEV00025920 Tidy Park code in preparation for other templates
* 26/03/09 RHA DEV00026063 Feed mode settings for hole cycles
* 26/03/09 RHA DEV00026779 Correct feed conversion (#RPM setting) for arc moves
* 27/03/09 RHA DEV00026063 Convert rapid to FPR when requested
* 30/03/09 RHA DEV00026690 Correct #FEED setting for thread turn
* 30/03/09 RHA DEV00026819 Prevent conversion to FPM in CSS mode
* 31/03/09 RHA DEV00026883 Fix feed for converted rapid (threading)
* 01/04/09 RHA DEV00026690 Prevent feed over-ride when radial tapping
* 02/04/09 RHA DEV00026929 Position token for turret park
* 06/04/09 RHA DEV00026690 Set #FEEDMODEHOLD only when G code is output
* 07/04/09 RHA DEV00026983 Apply reversals etc to turret park coords
* 08/04/09 RHA DEV00026983 Correction on lower turret
* 17/04/09 RHA DEV00027099 Add BMOVE and WORKGCODE to Unpark
* 20/04/09 RHA DEV00027117 Fix PROGID for Lower Turret
* 21/04/09 RHA DEV00026256 Initialise position with XCPL etc at Move Angular
* 22/04/09 RHA DEV00026256 Process XCPL for C move as well
* 22/04/09 RHA DEV00026256 Initialise for Radial tools
* 24/04/09 RHA DEV00027177 Adjust parking ZMOVE for Sub Spindle datum
* 27/04/09 RHA DEV00027177 Further correction
* Version 2010.1
* 20/05/09 RHA DEV00026880,27000,27004,26997,12284 Feed mode control changes
* 21/05/09 RHA DEV00026691,27420 Lower turret tooling list
* 21/05/09 RHA DEV00021825 Rough turn FEED modality corrected
* 22/05/09 RHA DEV00027417 Correct C position checking for Move Angular
* 22/05/09 RHA DEV00027169 Don't initialise position for linear move angular
* 22/05/09 RHA DEV00020266 Correct line numbers in turn cycles with all blocks numbered
* 26/05/09 RHA DEV00026880, Etc.   Fix for spindle stopped, Fix C Keep values
* 27/05/09 RHA DEV00027417 Correct C KEEP values in 2CY to use #CMOVE
* 27/05/09 RHA DEV00012284 Correct converted rapids when tapping
* 27/05/09 RHA DEV00027169 Remove #CnKEEP inconsistancies
* 28/05/09 RHA DEV00026997 Reduce CSS warning messages and correct procedure trace name
* 28/05/09 RHA DEV00026880 Corrections to SFM processing, remove duplication
* 01/06/09 RHA DEV00027511 Re-instate part of PT_SPINDLE
* 02/06/09 RHA DEV00026880 Change radius variable used in RPM calculations in case #XMOVE is incremental
* 02/06/09 RHA DEV00027530 Call PT_CONTROL_FEEDTYPE for Thread milling
* 03/06/09 RHA DEV00027539 Regression - Duplicate M69 output by template
* 04/06/09 RHA WI33413 (DEV26880) Improve speed warnings
* 05/06/09 RHA WI33726 (DEV27417) Correct #ATREFPT setting
* 05/06/09 RHA             In-line documentation of EVALUATE_MOVE improved
* 09/06/09 RHA WI33726 (DEV27417) Correct #ATREFPT in Rapid to Toolchange
* 09/06/09 RHA WI33885 Templates turn - Add speed value diagnostics
* 12/06/09 RHA WI33885 Templates turn - Add modes and CSSRadius
* 12/06/09 RHA WI33726 Protect linear motion checks from Macro-253
* 17/06/09 RHA WI33528 (DEV27169)  Correct move angular X initialisation in axial rotary
* 17/08/09 RHA WI34679 Correct move angular initialisation for C moves
* 24/08/09 RHA W34679 Remove B move (Move Angular) initialisation from non-B posts
* 09/09/09 RHA W35703 Test replacement of some W34679 removals
* 09/09/09 RHA W35703 Allow for CPL inconsistency planar/rotary and main/sub
* 15/09/09 RHA W35703 Only initialise Move Angular for B changes ??
* 18/09/09 RHA W35999 Move Angular. Initialise wrong for radial tools
* Version 2010.1 SP1
* 14/10/09 RHA W31599 Correct gear calculation for Z only move after TC
* 14/10/09 RHA W32267 Correct use of #RESTARTSUBSBNUM for CYCLESUB
* 15/10/09 RHA W36459 Correct Spindle braking in RtoH RtoTC
* 15/10/09 RHA W32860 Comp D code fixes
* 21/10/09 RHA W31599 Needs #TOOLCHANGE set 0 after first move
* 21/10/09 RHA W32860 Comp D code fixes
* 22/10/09 RHA W32860 Comp D code fixes
* 23/10/09 RHA W36513 Ask only one time for same variable when not set
* 30/10/09 RHA W32860 Comp D code finish turn
* 02/11/09 RHA W36663 (W31599) Allow for null moves in rough turn cycle
* 04/11/09 RHA W36693 Rapid feedrate for lower turret
* Version 2010.2
* 11/11/09 RHA W35581 Call CY_ANGLE for C move in 5 axis on (Evaluate_Move)
* 12/11/09 RHA W36737 Move some macro logic to procedures
* 13/11/09 RHA W36755 Add #MOVE to Mode Flags trace
* 23/11/09 RHA W32626 Improve output of hole cycle G codes
* 24/11/09 RHA W36917 Correct Tool Position for rotary,axial,subspin in PT_SET_TOOL_POS
* 24/11/09 RHA W33740 Improve Exact Stop Handling
* 26/11/09 RHA W36917 Correct Tool Position again for rotary,axial,subspin
* 02/12/09 RHA W32626 Re-init #GCODE after drill cycle
* 02/12/09 RHA W36657 Set #COMPDCODE1 in PMACRO-29 for CRC register
* 04/12/09 RHA W31292 Move non-zero dwell procedure
* 08/12/09 RHA W37039 Adjust turn cycle end block when block numbers in use
* 11/12/09 RHA W36903 Add "Ask Once" to the NC Stlyes > Interactive Startup options
* 16/12/09 RHA W30888 Correct thread approach X for other side of CL.
* 04/01/10 RHA W33326 Default XZ Offsets to Constant Offset
* 12/01/10 RHA W36917 Rationalise PT_SET_TOOL_POS, phase 1 split turn and CY
* 13/01/10 RHA W37320 Fix C angle regressions after G113 block
* 13/01/10 RHA W37320 Remove duplicate processing from PMACRO-15
* 22/01/10 RHA W33326 Fix for reverse Z condition
* 29/01/10 RHA W36917 Fix for reverse X turning
* 02/02/10 RHA W36917 Fix for reverse X turning
* 03/02/10 RHA W36917 Use FIX_COORDS to reverse Z on cycle approach
* 17/02/10 RHA W37659 Add KEEP for cartesian X and use in Polar switching
* 18/02/10 RHA W37659 Use #YMOVE for #YSTOREABS, not YMOVE, in Evaluate_Move
*                     Centralise polar duplicate outpute blanking in Evaluate_Move
* 18/02/10 RHA W37659 Move PT_FIX call in Evaluate_Move
* 19/02/10 RHA W37659 remove conditions for PT_FIX call in Evaluate_Move, rely on checks in procedure
* 22/02/10 RHA W37659 Merge #POLAR and #YMOVE processing in Evaluate_Move
* 22/02/10 RHA W37659 Suppress #POLARMOVE in Radial mode
* 02/03/10 RHA W37970 Correct #MOVE calculation when Y=#FUNNY
* 15/03/10 RHA W36738 Support for mini turrets
* 17/03/10 RHA W37894 Do not add 2 to #MOVE for Y in rotary mode
* 13/04/10 RHA W38561 Set #XCARTKEEP at Home and Toolchange
* 19/04/10 RHA W38575 Force Y0 on cy radial rotary moves
* 13/04/10 RHA W38561 Rapid to Tool Change must initialise XYZ position after setting KEEP
* 06/05/10 RHA W39073 Adjust initialised position for Parking
* 10/05/10 RHA W39073 Adjust only if B axis present
* Version 2010.2 SP1
* 03/06/10 RHA W39452 Set nextspeed/feed for rapids to Y0 from macro 44
* 08/06/10 RHA W39535 Move initialisation instructions to common procedure
* 10/06/10 RHA W39270 Reset SPINWARN at Toolchange
* Version 2011.1
* 17/06/10 RHA W38384 Correct rounding of IJ centre in PT_ARC_CENTRE
* 17/06/10 RHA W35950 Correct cyclesub block numbers for new rough turn
* 21/06/10 RHA W35950 Fix CRC codes
* 22/06/10 RHA W35950 Fix CRC code at end of cyclsub processing
* 23/06/10 RHA W35950 Cyclsub processing, safe return to start
* 25/06/10 RHA W35950 Fix cyclsub processing, return to start block number
* 29/06/10 RHA W39766 Use corect Data1() references in %IF #GCODE
* 30/06/10 RHA W35950 Fix cyclsub_arc processing
* 30/06/10 RHA W39830 Cyclsub array, trace option added
* 06/07/10 RHA W39894 Place lt sub spin axial hole cycle angle fix on MM line SW44
* 08/07/10 RHA W35950 Fix cyclsub endpoint processing
* 26/07/10 RHA W39785 Move PT_CHECK_TAPPING to Basic procedures
* 29/07/10 RHA W40119 Re-instate application of #DIAM and reversal to simple turn end point
* 03/08/10 RHA W40229 Move Attribute macro processing to a procedure & add 204 option
* 06/08/10 RHA W40229 Use 205 instead of 204
* 09/08/10 RHA W40128 CX output to use NEXTSPEED if processing a rapid move PT_SPINDLE
* 10/08/10 RHA W40229 Fix trace name in PT_SET_STOP
* 10/08/10 RHA W34977 CY milling, more spindle brake control options
* 17/08/10 RHA W30923 Reset auto coolant after move to Toolchange
* 20/08/10 RHA W40114 Enable force feed at start of turning cycles
* 23/08/10 RHA W39611 Correct #NEXTTOOL setting
* 23/08/10 RHA W34977 Correction for axial planar
* 24/08/10 RHA W39784 Set #SPEED for spindle synch PT_SPINDLE
* 25/08/10 RHA W36639 Add #MAXTOOLS and group tooling settings in PT_SET_DEFAULTS
* 25/08/10 RHA W36639 Var settings needed in Toolchange as well in case of merged NC
* 31/08/10 RHA W36639 Fix merged NC data. Don't use PASS
* 03/09/10 RHA W40654 Rough turn corrections, new approach moves
* 06/09/10 RHA W30985 Divert cyclsub moves for G200
* 06/09/10 RHA W39748 Allow sub spin moves relative to G55 Datum
* 07/09/10 RHA W40572 Ream, Bore, Chipbreak in fixed hole cycles
* 09/09/10 RHA W40572 Re-activate canned/longhand switching
* 21/09/10 RHA W39748 Alternative #G55ZDATUM setting if sub spindle not used
* 22/09/10 RHA W39748 Alternative #G55ZDATUM setting removed
* Version 2011.2
* 26/10/10 RHA W41396 Use MAXFEED for Rapid conversion
* 10/11/10 RHA W41235 Correct feed type control for tapping cycle feed reduction
* 18/11/10 RHA W40496 Use procedure for precision rounding & apply to angular values
* 18/11/10 RHA W41711 Code Generator variables protected from value changes (0,#FUNNY)
* 19/11/10 RHA W41737 Allow gear to change when speed is constant
* 26/11/10 RHA W41711 Code Generator variables protected from value changes (0,#FUNNY)
* 29/11/10 RHA W41737 Allow gear to change when speed is constant
* 30/11/10 RHA W36982 Polar Auto over-ride, initialise variable
* 03/12/10 RHA W41935 Option for cycle approach inside/outside cycle definition
* 03/12/10 RHA W41711 Code Generator variables protected (Drill Cycles etc)
* 08/12/10 RHA W36982 Polar Auto over-ride fix
* 09/12/10 RHA W41998 Add peck token to tapping cycle
* 22/12/10 RHA W41711 Code Generator DWELL protected from #FUNNY
* 07/01/11 RHA W35876 Add lower turret main spindle offset
* 10/01/11 RHA W40121 Fix CRC Register in Rapid After Toolchange
* 13/01/11 RHA W42405 Move #SPEEDHOLD setting inside GEAR_MCODE, 41737 side effect
* 14/01/11 RHA W40121 Protect against null values in profiling etc.
* 17/01/11 RHA W42405 Protect #CSSXMOVE from #FUNNY & 0
* 18/01/11 RHA W42405 Protect speed warnings against repeat output
* 21/01/11 RHA W42405 Fix #SPEEDHOLD in toolchange & make #CSSXMOVE etc absolute
* 24/01/11 RHA W42405 Fix use of CSS flag
* 28/01/11 RHA W42627 Suppress turret park move to toolchange if already in that position
* 01/02/11 RHA W41464 Add warning if no Rapid To Toolchange
* 07/02/11 RHA W39505 Allow multi-start canned threads
* 09/02/11 RHA W42491 Correct tool change monitoring for twin turrets
* 09/02/11 RHA W42815 Set #ATREFPT at Home and protect for merged twin turrets
* 10/02/11 RHA W42491 Always set #TOOLCHANGE in Tool Change
* 11/02/11 RHA W42491 Check #TOOLCHANGE in PT_OUTPUT_FEED for spindle processing
* 15/02/11 RHA W42627 Correct lower turret warning and Unpark moves to TC
* 21/02/11 RHA W43025 Multi-start G92 cycles
* 17/03/11 RHA W43448 Ability to strip brackets from Tool Descriptions
* 24/03/11 RHA W43571 Reduce duplicate speed warnings
* 30/03/11 RHA W38580 Fix thread approach safe mode
* 05/04/11 RHA W38580 Add ZSAFE to start position, fix taper safe start
* 05/04/11 RHA W30038 Add FIELD4=0 check to canned cycle processing
* 11/04/11 RHA W38580 Fix ZSAFE for back threading
* 14/04/11 RHA W38580 Fix XSAFE for taper internal threading
* 20/04/11 RHA W38580 Fix XSAFE for lower turret & centre line crossing
* Version 2012.1
* 17/05/11 RHA W44357 Check spindle speeds in Docking procedure
* 23/05/11 RHA W44087 Allow gear code output for single gear spindles
* 24/05/11 RHA W42981 Find gear when spindle stopped (option)
* 26/05/11 RHA W44527 Improve max speed check in CSS mode
* 06/06/11 RHA W43934 Fix evaluation of rotary "Y only" moves
* 09/06/11 RHA W30038 Turning cycles safe approach (rough Turn)
* 09/06/11 RHA W30605 Implement Rough Profile canned cycle
* 19/07/11 RHA W44401 Z reverse correction, Rotary B180 orientation
* 20/07/11 RHA W30605 Rough Profile canned cycle
* 26/07/11 RHA W44401 Z reverse correction
* 02/08/11 RHA W45504 Fix evaluation of rotary moves to TC and Home
* 08/08/11 RHA W45036 Use XFIRST variable for safe approach ordering
* 09/08/11 RHA W45549 unwrapped coordinates corrections
* 16/08/11 RHA W45549 Allow Y for B90 unwrapped coordinates
* 16/08/11 RHA W36919 Add Programmable Tailstock processing
* 17/08/11 RHA W30605 Rough Profile canned cycle incomplete - removed
* 22/08/11 RHA W45686 Fix C only axial rotary
* 23/08/11 RHA W45835 Implement Tool Offset modifier in linear feed and arc blocks
* 24/08/11 RHA W45686 Fix Y only at BMOVE=90
* 24/08/11 RHA W35149 Modify Tool Offset output for datum change in finish groove cycle
* 30/08/11 RHA W45928 Correct #THRDINT variable use clash
* 25/08/11 RHA W45902 Turret Park variables and tokens
* 25/08/11 RHA W35149 Initialise variable for datum change in Finish Groove
* 01/09/11 RHA W46009 Fix turret park B angle when already at Toolchange
* 05/09/11 RHA W46055 Fix Lower Turret #XKEEP setting
* 06/09/11 RHA W46009 Set #BANGADJUST=0 instead of #FUNNY
* 06/09/11 RHA W46095 Add option to reverse X, rotary, B axis, B180
* 07/09/11 RHA W45902 Turret Park correct in-line comments
* 08/09/11 RHA W45240 Improve speed of Attribute macro processing
* 13/09/11 RHA W46161 programmable Tailstock move should call turret synch
* 14/09/11 RHA W45902 Turret Park - Fix for over-ride position
* 14/09/11 RHA W36919 Programmable Tailstock fixes
* 21/09/11 RHA W46428 Remove initialisation in PMACRO-12 pending W30319 completion
* 05/10/11 RHA W45879 Programmable Tailstock adjust position, #TSADJUST
* Version 2012.2
* 25/10/11 RHA W30038 Safe approach for finish turn
* 31/10/11 RHA W46914 Use procedure to set variables for Offset Change
* 31/10/11 RHA W43616 Implement Swarf Conveyor on/off control
* 01/11/11 RHA W46653 Tailstock movement options
* 01/11/11 RHA W47189 Options for G68 datum
* 02/11/11 RHA W47190 Add data and controls for Steadies
* 02/11/11 RHA W45240 Improve processing efficiency
* 03/11/11 RHA W47190 Add data and controls for Steadies - populate token variables
* 07/11/11 RHA W46019 Make diametral rounding optional
* 08/11/11 RHA W45240 Improve processing efficiency, Fix arc type flags
* 10/11/11 RHA W31018 Correct application of length offsets on move home/toolchange
* 16/11/11 RHA W31018 Fix lower turret coordinates, XTOOL1 etc.
* 23/11/11 RHA W31018 Force second leg for IndexG200 and merged NC
* 07/12/11 RHA W47637 Make Bref shift more robust
* 12/12/11 RHA W47637 G200 fix
* 15/12/11 RHA W37779 G200 Bar Feed approach fix
* 19/12/11 RHA W47662 Correct fixed tapping feed calculation
* 05/01/12 RHA W47637 Correct fixed hole cycle approach for IndexG200
* 09/01/12 RHA W46653 Correct quill calculation
* 11/01/12 RHA W44024 Additional Lower Turret code swaps
* 11/01/12 RHA W48150 Correct multistart thread pass offsets
* 11/01/12 RHA W48182 Correct FeedModeGcode after 5 axis
* 12/01/12 RHA W46019 Remove option, always use diametral rounding
*                     Input Coordinate trace set to Format Table 13
* 19/01/12 RHA W46019 Fix side effects
* 19/01/12 RHA W48182 Correct INDEXG200 side effects
* 25/01/12 RHA W46019 Correct turret parking side effects
* 26/01/12 RHA W46019 Correct turning cycle side effects
* 30/01/12 RHA W46019 Correct movement length calculation (radial dims)
* 14/02/12 RHA W47190 Additional tokens and m/c datum option
* 21/02/12 RHA W48952 Fix polar coordinate initialisation
* 21/02/12 RHA W46019 Correct I value turned arc centres
* 20/03/12 RHA W49533 Fix CRC output for side change in finish groove
* 21/03/12 RHA W49533 Remove previous change
* 27/03/12 RHA W39775 Implement Combined Coolant options in CY coolant control
* 29/03/12 RHA W49820 Remove tapping feedtype workround
* 29/03/12 RHA W49819 Expand steady movement options
* 02/04/12 RHA W49201 Make Turning arcs and CY arc centres consistent
* 11/04/12 RHA W49643 Use XCPL etc. to reset KEEP for incremental coords PMACRO-12
* 18/04/12 RHA W50079 Correct sub spindle coolant code
* 26/04/12 RHA W49819 Improve null move suppression for steadies
* 02/05/12 RHA W50398 Improve null move suppression for steadies
* 31/05/12 RHA W48527 Tidy and streamline CYLINDRICAL processing
* 07/06/12 RHA W48574 Improve safety on turn cycle approach
* Version 2013.1
* 13/06/12 RHA W50512 Steadies, consecutive null moves not being trapped
* 19/06/12 RHA W48574 Improve safety on turn cycle approach
* 03/07/12 RHA W50512 Steadies, consecutive null moves not being trapped
* 04/07/12 RHA W51455 Steadies, fix shift and Z reversals
* 11/07/12 RHA W42904 Add Specified Range to CRC register options
* 12/07/12 RHA W51561 Initialise #F1HOLD properly for steady rest movement mode
* 11/07/12 RHA W42904 Add Specified Range - INDEXG200 protection
* 12/07/12 RHA W51561 Allow first move without checks
* 02/08/12 RHA W44675 Start coords of canned cycle profile follow modality rules
* 09/08/12 RHA W51763 Add NEXT_GROUP_NUMBER token for Integrex
* 21/08/12 RHA W51030 Changes for more than 2 turrets
* 23/08/12 RHA W50485 Fix turn cycle block numbers and subroutine number
* 23/08/12 RHA W52271 Implement priority controls for secondary turrets
* 12/09/12 RHA W52580 Siemens tapping formats #ZLEVEL
* 13/09/12 RHA W50485 Fix Subroutine numbers
* 26/09/12 RHA W51030 TURRET variable is now correct, discontinue use of PASS which has changed
* 27/09/12 RHA W51030 Further changes to controls etc.
* 03/10/12 RHA W31018 Correct CPL tool tip option for Rapid to Tool Change
* 03/10/12 RHA W53223 Allow for XTOOL2 XTOOL3 etc. Multiple turrets
* 09/10/12 RHA W53218 Improve use of NUMTOOLSn, Merged tape fix
* 09/10/12 RHA W51030 Rapid feed for multiple turrets
* 09/10/12 RHA W31018 Correct CPL tool tip option for Rapid to Tool Change
* 10/10/12 RHA W31018 Initialise tool tip CPL position after Rapid to Tool Change
* 10/10/12 RHA W51030 Multi-turret feeds for rapid conversion
* 11/10/12 RHA W53218 Improve use of NUMTOOLSn, Another merged tape fix
* 17/10/12 RHA W53223 Correct use of XTOOLn etc. Multiple turrets
* 09/10/12 RHA W53443 CPL tool tip option - fix for radial driven tool
* 23/10/12 RHA W53630 Fix to Radial tool reversal in Rapid to TC or Home
* 23/10/12 RHA W53653 Fix XTOOL lower turret positive
* 23/10/12 RHA W53648 Fix position at toolchange, merged tapes
* 29/10/12 RHA W53787 Move coordinates at toolchange, no B axis
* Version 2013.2
* 14/11/12 RHA W53887 Correct Toolchange move from PARK macros
* 29/11/12 RHA W54387 Correct XZ move from PARK macros
* 03/01/13 RHA W54890 Correct upper turret sub spindle MOVE coords on Move to ToolChange
* 08/01/13 RHA W54955 Correct goto target labels
* 29/01/13 RHA W54890 Correct upper turret planar sub spindle, add radial XZ shuffle
* 29/01/13 RHA W55326 Fix PROGID output options
* 30/01/13 RHA W53774 Correct tool change positions for multiple turrets
* 31/01/13 RHA W55326 Fix PROGID output options
* 07/02/13 RHA W55525 Fix change of sign on some moves
* 12/02/13 RHA W53774 Fix Radial tool, fixed position=CPL coords
* 14/02/13 RHA W53774 Correct tool position setting for multi-turret
* 26/02/13 RHA W53774 Fix Caxis=0 and Caxis=3, Bmove=90
* 26/02/13 RHA W53774 Fix initialisation in PT_SET_DEFAULTS
* 27/02/13 RHA W55326 Fix PROGID output options
* 06/03/13 RHA W55909 Correct simple turn approach
* 14/03/13 GST W55326 New procedure for Ask ID to handle multiple turrets
* 19/03/13 RHA W53774 Rewrite coord shuffle for Tool Change position and rapid to TC
* 20/03/13 RHA W53774 Correct Park moves for multi-turret
* 21/03/13 RHA W53774 Correct #XMOVE etc on Sub Spindle (MOVE tokens)
* 22/03/13 GST W54195 Create NEXT tokens for toolchange parameters
* 25/03/13 GST W54191 Force feed type - implement independet floating x rigid tapping
* 26/03/13 RHA W53774 Correct previous change on this task
* 26/03/13 RHA W56631 Correct turret park/unpark in line with Tool Change position fixes
* 26/03/13 RHA W55909 Correct simple turn approach
* 27/03/13 RHA W56631 Correct turret park/unpark for multiple turrets
* 02/04/13 RHA W56631 Re-instate position initialisation lines in PARK
* 03/04/13 RHA W56631 Correct initialisation, radial driven non-B machines
* 09/04/13 RHA W56809 Correct Lower Turret start XTOOL
* 09/04/13 RHA W56811 Correct Move to TC for non B axis machines
* 09/04/13 RHA W55957 Correct feed after thread cycle
* 10/04/13 RHA W56631 Parking, correct for sub spindle coordinates
* 22/05/13 RHA W56631 Parking, correct for initial CPL variations, tidy declarations
* 28/05/13 RHA W56631 Parking, Initial CPL (Spindle) now in system variables
* Version 2014.1
* 03/09/13 RHA W47884 Correct thread cycle approach move
* 04/09/13 RHA W57656 Changes for standardised INDEXG200
* 08/10/13 RHA W47884 Changes removed pending Edgecam fix with approach move
* 09/10/13 RHA W56677 Implement new coolant controls
* 10/10/13 RHA W60799 Tailstock quill extension value
* Version 2014.2
* 18/12/13 RHA W62161 Fix Synch Calls and stub procedures
* 19/12/13 RHA W62161 Fix Synch numbering for 2 upper turrets
* 07/01/14 RHA W62447 Fix duplicate tool list entries, #TAPEOUTPUT setting
* 07/01/14 RHA W62161 Synch Calls from Move Steady
* 22/01/14 RHA W61745 Make YZ arc code swap configurable (G200)
* 06/02/14 RHA W58922 Implement CRC check in rapid moves
* 26/03/14 RHA W56773 Correct Parking with intermediate B moves
* 16/04/14 RHA W55407 Canned cycle profile gets feeds from finish cycle
* 27/05/14 RHA W65095 Implement datum Shift in turning
* Version 2015.1
* 17/06/14 RHA W64644 Initialise position at Turret Unpark
* 03/07/14 RHA W65474 Initialise position at Turn Datum Shift
* 05/08/14 RHA W66005 Fix Sync Calls for turrets - Tailstock & Steady moves
* 12/08/14 RHA W59462 Add angular precision setting
* 01/10/14 RHA W42553 Correction for subroutines at end of NC file
* Version 2015.2
* 17/12/14 RHA W79600 Warn if thread canned cycle finishes at end
* 18/12/14 RHA W80346 Separate set-up sheet for each turret
* 18/12/14 RHA W47884 Simplify thread cycle approach and use system variables
* 06/01/15 GST W66367 Separate common procedures for ToM and Turn
* 20/01/15 RHA W66683 Use of STOP codes in Sub Spindle commands
* 22/01/15 RHA W80786 Correct start end call switch for inactive turrets
* 04/02/15 RHA W81327 Tidy declarations for G200
* 11/02/15 RHA W79205 Avoid empty set-up sheets
* 11/02/15 RHA W79953 Remove #FUNNY coordinate settings in turning cycles
* 11/02/15 RHA W35019 Set STOP codes in all configurations
* 12/02/15 RHA W79953 Fix Incremental coordinate settings in turning cycles
* 17/02/15 RHA W79953 Fix more reversals
* 18/02/15 RHA W79953 Force XZ at canned start/end blocks
* 24/02/15 RHA W49417 Safe approach, fixed drill cycles
* 25/02/15 RHA W81419 Allow for MACRO=268 for Docking
* 03/03/15 RHA W79953 Force XZ at canned start/end on Lower Turret
* 01/04/15 RHA W67046 Use ROT1DIR values
* 01/04/15 RHA W61908 Correct direction for M code setting (Okuma)
* 14/04/15 RHA W67046 Fix Use of ROT1DIR values
* 23/04/15 RHA W67046 Force 0-360 range for sign=direction of angles
* 28/04/15 RHA W67046 Force C in index for Rotary Rotate (Planar)
* 28/04/15 RHA W83162 Provide default value (1) for #BREFDIAM
* 30/04/15 RHA W81563 Allow for X offset in spindle selection
* 05/05/15 RHA W83320 Correct #SPINSHIFT typo
* Version 2016.1
* 03/06/15 RHA W83489 Set #C-KEEP values in HOLD procedure, avoid refpt set if #MOVE=0
* 03/06/15 RHA ECAM-657 Output Speeds in turned cycle profile
* 04/06/15 RHA ECAM-695 Simplify C Index control in C_RAPID (#CWITHLINEAR)
* 25/06/15 RHA ECAM-693 Correct #CFIRST setting to avoid reversed angles in hole approach
* 30/06/15 RHA ECAM-1026 Correct for Y0 forced in template for rotary
* 02/07/15 RHA ECAM-693 Fix remaining minor regressions
* 02/07/15 RHA ECAM-693 Now it should do what was intended
* 08/07/15 RHA ECAM-1841 Hole approach corrections for Fanuc Polar
* 09/07/15 RHA ECAM-1582 Correct speed block output in canned cycle calls (Related to ECAM-657)
* 14/07/15 RHA ECAM-1841 Hole approach corrections - Reverse Radial
* 16/07/15 RHA ECAM-2241 Improve Initialisation and diagnostic after Fanuc Polar hole cycles
* 21/07/15 RHA ECAM-1841 More hole approach corrections for Fanuc Polar
* 28/07/15 RHA ECAM-2341 Implement angle at Tool Change
* 27/08/15 RHA ECAM-2238 Correct unsigned depth - protect depth from Evaluate calls
*
******************************************************************************
*
*							*******************
*                         Initialisation procedures
*							********************
*

%PROCEDURE=PT_SET_DEFAULTS
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_DEFAULTS:%CALL=ENTER_PROCEDURE

* Initialisation moved from individual start macros, based on Generic ISO.
* Now called by all templates except the INDEXG200
* Individual (different) requirements remain in start macros

#ATREFPT=1                             ;   Set ref position flag
%IF #BREFDIAM=#FUNNY %THEN #BREFDIAM=1 ; Default if not set

#Y0FORCED=0 ; Flag for template generated move

#AUTOGEAR=#TRUE					;	Defaults to automatic gear selection.
#INTHRD=#FALSE					;	Used when Longhand Threading to select Threadgcode else use Feedgcode

#COOL=DATA2(10)
<[#COOL=10]>            ;   Initialise Coolant

#XGHOLD=0:#ZGHOLD=0				;	Default X & Z Gauge lengths
#UZERO=0:#VZERO=0:#WZERO=0				;	Incremental (U0/W0) for Rapid to Home, Toolchange
$CYCLE=NOCYCLE					;	Set cycle type flag
*  $PLANAR=NO						;	Default to Rotary Mode for C & Yaxis machines
$CAXENGAGED=NO					;	Default Caxis interpolation not active.
#SPEEDHOLD=0:#RPMHOLD=0
#SPINWARNSAVE=#SPINWARN
#WARNCOUNT=0
#COMPACTIVE=0
* Set priority variables, workround for Code Gen problem DEV00009237
#PRIORITYMAIN=0
#PRIORITYSUB=0
%IF PRIORITYMAIN<>#FUNNY %THEN #PRIORITYMAIN=PRIORITYMAIN
%IF PRIORITYSUB<>#FUNNY %THEN #PRIORITYSUB=PRIORITYSUB

#SPINDLE=SPINDLE  ; Pick up initial spindle ID.

* 5 axis IJK machining
FIVEAXIS=0 ; Always start at OFF
#FIVEAXISKEEP=0
#AX5USEIJK=0  ; IJK used from MM
%IF #AX5USEIJK<>1 %THEN #AX5USEIJK=0 ; In case not set
#AX5INVTIME=0  ; Inverse Time used, from MM

* Initialise spindle clamp
#BRAKE=#BRAKEOFF
#BRAKEHOLD=#BRAKEOFF
#BRAKEHOLD2=#SUBBRAKEOFF
%IF SPINDLE=SPINDLEID2 %THEN #BRAKE=#SUBBRAKEOFF
<[#BRAKE=10]>

*	Retrieve from MM & MT lines
#USECAMDIR=0 ; Use rotary direction from ROT1DIR
#ROT1DIR=2 ; M15 Default 0104

#ROTROT=0 ; Cancel Rotary rotate mode
#CWITHLINEAR=0 ; 0406 Planar rotation style for G200

%IF #USECAMDIR=0 @NOSIGN
%IF #CANGMODE=3 %THEN #CANGLIMIT=1

@NOSIGN
%IF #BANGADJUST=#FUNNY %THEN #BANGADJUST=0 ;  B angle offset
#MAXTOOLS1=8
#TCANGLE1=0
#TCANGLE1=#TCANGLE1+#BANGADJUST
%IF #BANGREVERSE=1 %THEN #TCANGLE1=#TCANGLE1*-1

#FORCELEG2=0

#WRAP=0
#SWITCH44=1  ; LT SubSpin axial angle compatibility
%IF #SWITCH44<>1 %THEN #SWITCH44=0

* Set Spindle flags
%IF #CANGOFFSET2=#FUNNY %THEN #CANGOFFSET2=0
%IF #CANGOFFSETL=#FUNNY %THEN #CANGOFFSETL=0
%IF #CANGOFFSET2L=#FUNNY %THEN #CANGOFFSET2L=0
%IF #CANGREVERSEANGLE2L=#FUNNY %THEN #CANGREVERSEANGLE2L=0


* Set Tooling data
* Number of tools on this turret
* NUMTOOLS = Tools Actually Loaded
* MAXTOOLS = Maximum permitted
#MAXTOOLS=#MAXTOOLS1
#NUMTOOLS=NUMTOOLS

* Store Datum IDs in case output loop not called ; 1505
#UNIQUEDATUMS=#TRUE
#TURNZDATUM=ZSUB*-1 ; start value   ; 2205
* Initialise sysid variables before running loop
* So that loop will work again if run at end of program
#G54=#FUNNY
#G55=#FUNNY
#G56=#FUNNY
#G57=#FUNNY
#G58=#FUNNY
#G59=#FUNNY

#LOOP=0
#COORDNUM=1
*
@DATLOOPSTART
#LOOP=#LOOP+1
%GETCPL=#LOOP
%IF SYSID=#FUNNY @PARK

%IF #OUTPUTSHIFTS=1 @SYS ; 2205
%IF STYPE=0 @DATLOOPSTART		; Datum type is incremental, skip assignment.  ; 2005

@SYS    ; 2205
#SYSID=SYSID*1000000:%IF #UNIQUEDATUMS=#TRUE %THEN #SYSID=(#SYSID+(ROT1*1000)+ROT2) ; Make Datum unique by XYZ and Rotation

%IF #SYSID=#G54 @DATLOOPSTART  ; Skip if datum is already assigned.
%IF #SYSID=#G55 @DATLOOPSTART
%IF #SYSID=#G56 @DATLOOPSTART
%IF #SYSID=#G57 @DATLOOPSTART
%IF #SYSID=#G58 @DATLOOPSTART
%IF #SYSID=#G59 @DATLOOPSTART  ; 2005

%IF #COORDNUM=1 %THEN #G54=#SYSID:%GOTO @CARRYON
%IF #COORDNUM=2 %THEN #G55=#SYSID:%GOTO @CARRYON
%IF #COORDNUM=3 %THEN #G56=#SYSID:%GOTO @CARRYON
%IF #COORDNUM=4 %THEN #G57=#SYSID:%GOTO @CARRYON
%IF #COORDNUM=5 %THEN #G58=#SYSID:%GOTO @CARRYON  ; 2005
%IF #COORDNUM=6 %THEN #G59=#SYSID:%GOTO @CARRYON  ; 2005
%GOTO @PARK  ; 2005

@CARRYON
#COORDNUM=#COORDNUM+1
%GOTO @DATLOOPSTART

@PARK ; 1505
#TMP=1
%GETCPL=#TMP  ; Reset     2705

* Turret park positions
#XT1PARK1=900 ; Upper Main
#YT1PARK1=0
#ZT1PARK1=190
#XT1PARK2=900 ; Upper Sub
#YT1PARK2=0
#ZT1PARK2=1600


#RAPIDFEEDRATE=MAXFEED
%IF #USEMAXFEED=1 @RAPIDSET
#RAPIDFEEDRATE=24000
@RAPIDSET




%IF #INCRXYZ<>2 @RUNTIME1
%OPTIONS=Coordinate Mode^Absolute^Incremental=#INCRXYZ
#INCRXYZ=#INCRXYZ-1
*  Note  #incrxyz is current abs/inc setting
*        #incrxyzhold is main program setting
*        #incrsubs is subroutine setting
@RUNTIME1

#FIRSTIME=1:STARTSUB=0:ENDSUB=0:CSS=0

#FEEDMODEGCODE=DATA1(47)	;	Default Feed / Rev
#GCODE=DATA1(1)				;	Default Rapid
#BNUM=#BNUM-#BNUMINC:#SBNUM=#SBNUM-#SBNUMINC		; so that first increment is the user's start number
%IF #USEBNUM=#FALSE %THEN %DONT-OUTPUT=#BNUM		; suppress both block and safestart blocks
%IF #USESBNUM=#FALSE %THEN %DONT-OUTPUT=#SBNUM  		; suppress Blocknum if toolchange only
%IF UNIT=0 %THEN #UNITSGCODE=DATA1(16):#CSSFACTOR=12 %ELSE #UNITSGCODE=DATA1(17):#CSSFACTOR=1000
#CONVERTUNITS=25.4
%IF UNIT=0 %THEN #INCR=#INCHINCR %ELSE #INCR=#MMINCR	;	set smallest machine movement depending on NC Pogram units
*PRECISION=#INCR-(#INCR/100)		;	Set compiler to work to one digit less than machine minimum
PRECISION=#INCR/2
%CALL=FIND_PRECISION
%IF UNIT=0 %THEN RESOLUTION=#INCHINCR %ELSE RESOLUTION=#MMINCR ; Used for Arc bulge checking
%IF #USERADS=0 %THEN NOBULGECORRECTION=1 ; Suppress correction if IJK arcs
%IF CIRCLE=1 %THEN NOBULGECORRECTION=1 ; Suppress correction if single quadrant arcs

%IF #RAPDIST=#FUNNY %THEN #RAPDIST=0	; If user has unset value then set as 0
#INCRXYZHOLD=#INCRXYZ ; Used for main prog setting on return from subroutine

;
;         C O N D I T I O N S  D E P E N D A N T  O N  S E T V A R S         
;

%IF #ZMAINREVERSE=1 %THEN #ZMAINREVERSE=-1 %ELSE #ZMAINREVERSE=1	;	Output negative Z coordinates
%IF #ZSUBREVERSE=1 %THEN #ZSUBREVERSE=-1 %ELSE #ZSUBREVERSE=1	;	Output negative Z coordinates
%IF #ZSUBDRIVEN=1 %THEN #ZSUBDRIVEN=-1 %ELSE #ZSUBDRIVEN=1	;	Output negative Z coordinates
#ZREVERSE=#ZMAINREVERSE
%IF SPINDLE=SPINDLEID2 %THEN #ZREVERSE=#ZSUBREVERSE

%IF #XMAINREVERSE=1 %THEN #XMAINREVERSE=-1 %ELSE #XMAINREVERSE=1	;	Output negative Z coordinates
%IF #XSUBREVERSE=1 %THEN #XSUBREVERSE=-1 %ELSE #XSUBREVERSE=1	;	Output negative Z coordinates
%IF #XSUBDRIVEN=1 %THEN #XSUBDRIVEN=-1 %ELSE #XSUBDRIVEN=1	;	Output negative Z coordinates
#XREVERSE=#XMAINREVERSE
%IF SPINDLE=SPINDLEID2 %THEN #XREVERSE=#XSUBREVERSE

%IF #YMAINDRIVEN=1 %THEN #YMAINDRIVEN=-1 %ELSE #YMAINDRIVEN=1 ; Output negative Y coordinates
%IF #YSUBDRIVEN=1 %THEN #YSUBDRIVEN=-1 %ELSE #YSUBDRIVEN=1
#YREVERSE=#YMAINDRIVEN
%IF SPINDLE=SPINDLEID2 %THEN #YREVERSE=#YSUBDRIVEN


#TURNDIAM=#DIAM         ; Excludes reverse setting
#DIAM=#DIAM*#XREVERSE	;	Output negative X coordinates : #DIAM then 1 or 2 / -1 or -2


TOOLXSET=0:TOOLZSET=0 ; No tool selected yet  2602
%CALL=PT_TC_REFERENCE_SHIFT
#XTOOL=#XFIXED*#DIAM:#ZTOOL=#ZFIXED*#ZREVERSE ; 2602

%CALL=PT_HOME_REFERENCE_SHIFT ; 2602
#XHOME=#XFIXED*#DIAM:#ZHOME=#ZFIXED*#ZREVERSE ; 2602
#XKEEP=#XHOME*#ABSDIAM:#YKEEP=YHOME:#ZKEEP=#ZHOME
#XMOVE=#XHOME:#XHOLD=#XMOVE:#ZMOVE=#ZHOME:#ZHOLD=#ZMOVE		;	Initial start position   2602
#XSTOREABS=#XHOME:#ZSTOREABS=#ZHOME							;	Used when for Incremental output
#YSTOREABS=YTOOL

#CHOLD=#FUNNY
#C1HOLD=#FUNNY
#C2HOLD=#FUNNY
#C1KEEP=#FUNNY
#C2KEEP=#FUNNY

#POLARMAN=0
#POLARAUTO2=#POLARAUTO
%IF #POLARAUTO2=2 %THEN #POLARAUTO2=1
#TRANSMITMODE=0 ; Active for G200 only

#CANCELCODE=#CANCELTLO:<[#CANCELCODE=10]>


#ARCSWAPYZ=1 ; Controls YZ arc G2/3 swapping

* Run-time questions ask once
%IF PASS>1 @ID
#GOTPV=0
#GOTDE=0
#GOTPR=0
@ID
#GOTID=0
#PROGID=#FUNNY ; Reset for each turret

*******************************************************************************************
*	Multiple Turrets


*******************************************************************************************

; initialise Sub-Spindle related variables
#ADVANCEHOLD=#FUNNY
#ADVANCE=#FUNNY; Start at Home position
* #SPINDLECODE=1 ; Default to main
#SPINDLECODE=#FUNNY ; Force output when needed
#WORKGCODE=DATA1(26)
#MAINDATUMCODE=DATA1(26)
#SUBDATUMCODE=DATA1(27)

#SPINSELECT=#MAINSPINDLECODE ; Default to main

* Hold values #FUNNY trigger initialisation before first use
#SETALLCOOL=0
* #CHUCKFACE1=#CHUCKFACE1OFF
#CHUCKFACE1HOLD=#FUNNY
* #TURRETFACE1=#TURRETFACE1OFF
#TURRETFACE1HOLD=#FUNNY
* #THROUGHSPIN1=#THROUGHSPIN1OFF
#THROUGHSPIN1HOLD=#FUNNY

#THROUGHTOOL1=#THROUGHTOOL1OFF
#THROUGHTOOL1HOLD=#THROUGHTOOL1OFF


%IF SPINDLE=SPINDLEID1 %THEN #CHUCKFACE=#CHUCKFACE1:#THROUGHSPIN=#THROUGHSPIN1 %ELSE #CHUCKFACE=#CHUCKFACE2:#THROUGHSPIN=#THROUGHSPIN2
<[#CHUCKFACE=10][#THROUGHSPIN=10]>


%IF TURRET=0 %THEN #TURRETFACE=#TURRETFACE1:#THROUGHTOOL=#THROUGHTOOL1 %ELSE #TURRETFACE=#TURRETFACE2:#THROUGHTOOL=#THROUGHTOOL2
<[#TURRETFACE=10][#THROUGHTOOL=10]>


%IF #TOOLSHEET<>3 %THEN %CALL=SET_UP_SHEET
%IF #TAPEOUTPUT<>0 @JUMP
*  Merged Tape
* Force PASS and TURRET for two turret merged tapes
#TEMP=PASS
* Lower Turret tools
PASS=2
TURRET=1
#NUMTOOLS=NUMTOOLS1
%IF #TOOLSHEET<>3 %THEN %CALL=SET_UP_SHEET
* Reset PASS variable
PASS=#TEMP
#NUMTOOLS=NUMTOOLS1
%IF PASS=1 %THEN TURRET=0:#NUMTOOLS=NUMTOOLS
@JUMP

* Set Spindle and sub spindle work datum XZ positions
#LOOP=0
@GET-SPINDLE-FACES
#LOOP=#LOOP+1
%GETCPL=#LOOP
%IF SYSID=#FUNNY @DONE
%IF SYSID=SPINDLEID1 %THEN #G54XDATUM=XSUB:#G54ZDATUM=ZSUB:%GOTO @GET-SPINDLE-FACES
%IF SYSID=SPINDLEID2 %THEN #G55ZDATUM=ZSUB:#G55XDATUM=XSUB:%GOTO @GET-SPINDLE-FACES
%GOTO @GET-SPINDLE-FACES
@DONE
#LOOP=1
%GETCPL=#LOOP
#SUBSPINDLETOFACE1=(MCSUBDATUMZ-(#G54ZDATUM+MAINDATUMTOCHUCKFACE))*-1

* Main Spindle max speed from highest gear
#TMP1=SPINDLE
SPINDLE=SPINDLEID1
#TEMP=GEAR(0)
#TEMP=GEAR(NUMGEARS)
#HIGHMAIN=GEARCODE
#MAXMAIN=GEARMAXRPM
#TEMP=GEAR(1)
#LOWMAIN=GEARCODE
#MINMAIN=GEARMINRPM


* Reset SPINDLE
SPINDLE=#TMP1

%OUTPUT-IF-CHANGED=#POSREP

* B Axis Datum Shift
#G68SHIFT=0

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


**********************
* STUB PROCEDURES
**********************


*********** Synch Stubs for 2 axis configurations
%PROCEDURE=CODECON_LT_SYNC-TURR
* STUB
%ENDM

%PROCEDURE=CODECON_LT_SYNC2-TURR
* STUB
%ENDM

%PROCEDURE=CODECON_SYNC2-TURR
* STUB
%ENDM

%PROCEDURE=CODECON_SYNC-TURR
* STUB
%ENDM
***********




**********************


;
;___________________________________________________________ Macro = 1 _____
;

%PROCEDURE=PMACRO-1
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-1:%CALL=ENTER_PROCEDURE

#XMOVE=XMOVE
#ZMOVE=ZMOVE
#GCODE=DATA1(1)


%CALL=PT_OUTPUT_RAPID

%IF #MOVE=0 @END
#TOOLCHANGE=0 ; First move completed

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 1 _____
;

%PROCEDURE=PMACRO-2
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-2:%CALL=ENTER_PROCEDURE

#XMOVE=XMOVE
#ZMOVE=ZMOVE


%CALL=PT_OUTPUT_FEED

%IF #MOVE=0 @END
#TOOLCHANGE=0 ; First move completed

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 3 _____
;

%PROCEDURE=PMACRO-3
* Processing logic called by macro 3, Simple Turning Cycle
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-3:%CALL=ENTER_PROCEDURE


#INTHRD=#FALSE
%IF #FORCEFEED3=1 %THEN %CANCEL=#FEED

%IF PATHTRACE=1 %THEN %NOCYCLE				;	User requested longhand output
%IF SUBFUNCT=0 %THEN %NOCYCLE				; 	Drive/cut angles are not orthoginal
%IF #INCRSUBNUMBER=#FUNNY %THEN #SUBROUTINE=SUBROUTINE+#SUBNOSTART %ELSE #SUBROUTINE=(SUBROUTINE*#INCRSUBNUMBER)+#SUBNOSTART

; Check for invalid depth
%IF DEPTH=0 %THEN $WARNING="ERROR : DEPTH incorrectly set":%CALL=CODECON_WARNING:%GOTO @END
%IF DEPTH=#FUNNY %THEN $WARNING="ERROR : DEPTH incorrectly set">:%CALL=CODECON_WARNING:%GOTO @END

; Safe Approach. Move tool to start of cycle
#GCODE=DATA1(1)

%IF FIELD4=0 @START_POINT ; Safe Approach Off
%IF FIELD4=#FUNNY @START_POINT ; Safe Approach Off

%IF XFIRST=1 @XFIRST ; Use cycle flag if available
%IF XFIRST=0 @ZFIRST

%IF SUBFUNCT=1 @ZFIRST         ; Check which axis to travel first
%IF SUBFUNCT=4 @ZFIRST
%IF SUBFUNCT=7 @ZFIRST
%IF SUBFUNCT=8 @ZFIRST
%GOTO @XFIRST


@ZFIRST
#XMOVE=#XKEEP*#INVDIAM
%IF FIELD8>#XMOVE @XFIRST ; Override to lift in X
#ZMOVE=FIELD7
#XMOVE=#FUNNY
%GOTO @LEG_ONE


@XFIRST
#XMOVE=FIELD8
#XMOVE=#XMOVE
#ZMOVE=#FUNNY

@LEG_ONE
%CALL=DIVERT_CYCLSUB_RAPID

@START_POINT
%IF FIELD8=#FUNNY %THEN FIELD8=#XKEEP/#ABSDIAM:FIELD7=#ZKEEP ; Use hold position if Start Position has not been used.
#XMOVE=FIELD8:#ZMOVE=FIELD7

%CALL=DIVERT_CYCLSUB_RAPID
*
*	Canned cycle
*
%IF SUBFUNCT=2 @FACE
%IF SUBFUNCT=4 @FACE
%IF SUBFUNCT=6 @FACE
%IF SUBFUNCT=8 @FACE

#GCODE=DATA1(53)
#DEPTHTURN=DEPTH:#DEPTHFACE=#FUNNY
#ZCYCLEEND=ZEND
#XCYCLEEND=#FUNNY
#CHIPF=#FUNNY
#CHIPT=USERVAR2
%IF #CHIPT=0 %THEN #CHIPT=#FUNNY
%GOTO @OUTPUT

@FACE
#GCODE=DATA1(54)
#DEPTHFACE=DEPTH:#DEPTHTURN=#FUNNY
#ZCYCLEEND=#FUNNY:#XCYCLEEND=XEND
#CHIPT=#FUNNY
#CHIPF=USERVAR2
%IF #CHIPF=0 %THEN #CHIPF=#FUNNY
@OUTPUT

* Retain #CHIP for compatibility
#CHIP=USERVAR2
%IF #CHIP=0 %THEN #CHIP=#FUNNY

#XMOVE=XEND:#ZMOVE=ZEND:#DEPTH=DEPTH
#XMOVE=#XMOVE*#DIAM
#ZMOVE=#ZMOVE*#ZREVERSE
%CANCEL=#GCODE,#FEED

; The #STURNTYPE is set from the Code Wizard Template
; See NC Style, G-Codes and Modality - Turning Cycles G-Codes - Simple Turn Cycle Type List box

; #STURNTYPE 1=Full Canned Cycle 2=Single Block Cycle

%CALL=PT_CONTROL_FEEDTYPE
%IF #STURNTYPE=2 %THEN %CALL=SIMPLE_TURN_SBLOCK %ELSE %CALL=CODECON_SIMPLE-TURN


; Reset current position to start point
%IF FIELD8=#FUNNY %THEN FIELD8=#XHOLD/#DIAM:FIELD7=#ZHOLD ; Use hold position if Start Position has not been used.
#XMOVE=FIELD8
#ZMOVE=FIELD7

@END
FIELD8=#FUNNY:FIELD7=#FUNNY ; Null out Start position

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Macro = 4 _____
;

%PROCEDURE=PMACRO-4
* Processing logic called by macro 4, Rough Turn Area Clear
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-4:%CALL=ENTER_PROCEDURE


%IF #FORCEFEED4=1 %THEN %CANCEL=#FEED

%IF PATHTRACE=1 %THEN %NOCYCLE			;	User requested longhand
%IF #INCRSUBNUMBER=#FUNNY %THEN #SUBROUTINE=SUBROUTINE+#SUBNOSTART %ELSE #SUBROUTINE=(SUBROUTINE*#INCRSUBNUMBER)+#SUBNOSTART
*
#SPEED=SPEED
#INTHRD=#FALSE
*
%IF SUBFUNCT=0 %THEN %NOCYCLE			;	Drive / Cut angles are not orthogonal to machine's coord system
*
%CALL=RT_VARIABLES
*
%CALL=DIVERT_CYCLSUB_RAPID
*
#DEPTH=DEPTH:#XSAFE=XSAFE:#ZSAFE=ZSAFE
*
#CYCENDSKIP=0 ; Add move over-ride
%IF SUBFUNCT=2 @FACE
%IF SUBFUNCT=4 @FACE
%IF SUBFUNCT=6 @FACE
%IF SUBFUNCT=8 @FACE
*
@TURN
********** rough turn *********
#XCYCSTART=#XKEEP*#INVDIAM  ;For Cyclesub end
#ZCYCSTART=#FUNNY
#XFIELD12=#XKEEP*#INVDIAM
#ZFIELD12=#ZKEEP
* New rough turn may end level with start point
#TMP=YPOINT(LAST)
%IF #TMP=#XCYCSTART %THEN #CYCENDSKIP=1

#GCODE=DATA1(33)
%IF #MACRO=11 %THEN #GCODE=#ROUGHPROF1  ; Rough Profile
#DEPTHTURN=DEPTH:#DEPTHFACE=#FUNNY
*
%GOTO @OUTPUT
*
@FACE
********** rough face *********
#XCYCSTART=#FUNNY  ;For Cyclesub end
#ZCYCSTART=#ZKEEP
#XFIELD12=#XKEEP*#INVDIAM
#ZFIELD12=#ZKEEP
* New rough turn may end level with start point
#TMP=XPOINT(LAST)
%IF #TMP=#ZCYCSTART %THEN #CYCENDSKIP=1

#GCODE=DATA1(34)
%IF #MACRO=11 %THEN #GCODE=#ROUGHPROF2  ; Rough Profile
#DEPTHFACE=DEPTH:#DEPTHTURN=#FUNNY
*
@OUTPUT
*
%CALL=PT_MTH_STOCK_OFFSETS				;	Determine X and Z (I & K) stock offsets)

%CALL=PT_CONTROL_FEEDTYPE

* Adjust end block if block numbers output
%IF #USEBNUM=0 @NOFIDDLE
%IF #ENDSTYLE<2 @NOFIDDLE
ENDSUB=ENDSUB-#BNUMINC
@NOFIDDLE
* %IF #MACRO=4 %THEN %CALL=CODECON_ROUGH-TURN:%GOTO @END ; Output CNC code
%CALL=CODECON_ROUGH-TURN:%GOTO @END ; Output CNC code

* Macro 11 Rough profiling, calculate number of passes
#NUMCUTS=#XKEEP-XSTART
#NUMCUTS=#NUMCUTS-OFFSETX
%IF SUBFUNCT=4 %THEN #NUMCUTS=#ZKEEP-ZSTART:#NUMCUTS=#NUMCUTS-OFFSETZ
%IF SUBFUNCT=8 %THEN #NUMCUTS=#ZKEEP-ZSTART:#NUMCUTS=#NUMCUTS-OFFSETZ
%IF SUBFUNCT=2 %THEN #NUMCUTS=#ZKEEP-ZSTART:#NUMCUTS=#NUMCUTS-OFFSETZ
%IF SUBFUNCT=6 %THEN #NUMCUTS=#ZKEEP-ZSTART:#NUMCUTS=#NUMCUTS-OFFSETZ
#NUMCUTS=#NUMCUTS/DEPTH
#NUMCUTS=INT(#NUMCUTS)
#NUMCUTS=#NUMCUTS+1
%CALL=CODECON_ROUGH-PROFILE ; Output CNC code

@END
*
#SUBROUTINE=SUBROUTINE:%CALL=CODECON_SUBROUTINE-CALL ;	Used for Subprograms - codecon empty for Blknum type
*
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM



;
;___________________________________________________________ Macro = 5 _____
;

%PROCEDURE=PMACRO-5
* Processing logic called by macro 5, Profiling Cycle
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-5:%CALL=ENTER_PROCEDURE


#XFIELD12=#XKEEP*#INVDIAM  ; 0110 For return move at end
#ZFIELD12=#ZKEEP           ; 0110

%IF #FORCEFEED5=1 %THEN %CANCEL=#FEED

#INTHRD=#FALSE
%IF USERVAR1=#FUNNY %THEN USERVAR1=0
%IF USERVAR1<>0 %THEN #COMPDCODE1=USERVAR1
*
%IF PATHTRACE=1 %THEN %NOCYCLE
%IF #INCRSUBNUMBER=#FUNNY %THEN #SUBROUTINE=SUBROUTINE+#SUBNOSTART %ELSE #SUBROUTINE=(SUBROUTINE*#INCRSUBNUMBER)+#SUBNOSTART
*
%CALL=PROFILE_VARIABLES
*	Move to digitised start position if requested
%IF FIELD9<>1 @SKIP_START

%IF FIELD11=0 @CALL2
%IF FIELD11=#FUNNY @CALL2
%IF XFIRST=1 @XFIRST ; Use cycle flag if available
*
#ZMOVE=FIELD7
#XMOVE=#XKEEP*#INVDIAM
%CALL=DIVERT_CYCLSUB_RAPID
%GOTO @CALL2

@XFIRST
#XMOVE=FIELD8
#ZMOVE=#ZKEEP
%CALL=DIVERT_CYCLSUB_RAPID

@CALL2
#ZMOVE=FIELD7
#XMOVE=FIELD8
%CALL=DIVERT_CYCLSUB_RAPID
*
@SKIP_START					;	Finish Turn cycle
*
%CALL=PT_MTH_STOCK_OFFSETS				;	Determine X and Z (I & K) stock offsets)
*
#DEPTH=DEPTH:#XSAFE=XSAFE:#ZSAFE=ZSAFE
%CALL=PT_CONTROL_FEEDTYPE

%IF SUBFUNCT=2 @FACE
%IF SUBFUNCT=4 @FACE
%IF SUBFUNCT=6 @FACE
%IF SUBFUNCT=8 @FACE
*
@TURN
********** turn *********
#XCYCSTART=#XHOLD  ;For Okuma Cyclesub end
#ZCYCSTART=#FUNNY
#DEPTHTURN=DEPTH
#DEPTHFACE=#FUNNY
%GOTO @OUTPUT
*
@FACE
********** face *********
#XCYCSTART=#FUNNY  ;For Okuma Cyclesub end
#ZCYCSTART=#ZHOLD
#DEPTHFACE=DEPTH
#DEPTHTURN=#FUNNY

@OUTPUT
#XCYCLESTART=XSTART*#DIAM
#ZCYCLESTART=ZSTART*#ZREVERSE

* Adjust end block if block numbers output
%IF #USEBNUM=0 @NOFIDDLE
%IF #ENDSTYLE<2 @NOFIDDLE
ENDSUB=ENDSUB-#BNUMINC
@NOFIDDLE

#GCODE=DATA1(32)
%CALL=CODECON_FINISH-TURN
*
@END
*
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;___________________________________________________________ Macro = 9 _____
;
%PROCEDURE=PMACRO-9
* Processing logic called by Macro 9, Hole Cycle
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-9:%CALL=ENTER_PROCEDURE

#INTHRD=#FALSE
#ATREFPT=0 ; Position checking
%IF #FDRCANNED=0 %THEN %NOCYCLE ; Cycle not supported
%IF PATHTRACE=1 %THEN %NOCYCLE ; Cycle not required
#HOLEFLAG=1
%CALL=PT_HOLE_CYCLES

%CALL=CODECON_DRILL-CYCLE
#HOLEFLAG=0

*Initialise Z position at clearance - end of cycle
#ZMOVE=ZCLEAR*#ZREVERSE
<[#ZMOVE=10]>
#DRGCODE=DATA1(65):<[#DRGCODE=10]> ; reset
#GCODE=DATA1(65):<[#GCODE=10]> ; reset

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 265 _____
;
%PROCEDURE=PMACRO-265
* Processing logic called by Chipbreak Cycle
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-265:%CALL=ENTER_PROCEDURE

#INTHRD=#FALSE
#ATREFPT=0 ; Position checking
%IF #FCHCANNED=0 %THEN %NOCYCLE ; Cycle not supported
%IF PATHTRACE=1 %THEN %NOCYCLE ; Cycle not required
#HOLEFLAG=1
%CALL=PT_HOLE_CYCLES

%CALL=CODECON_CHIP-CYCLE
#HOLEFLAG=0

*Initialise Z position at clearance - end of cycle
#ZMOVE=ZCLEAR*#ZREVERSE
<[#ZMOVE=10]>
#DRGCODE=DATA1(65):<[#DRGCODE=10]> ; reset
#GCODE=DATA1(65):<[#GCODE=10]> ; reset

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Macro = 266 _____
;
%PROCEDURE=PMACRO-266
* Processing logic called by Ream Cycle
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-266:%CALL=ENTER_PROCEDURE

#INTHRD=#FALSE
#ATREFPT=0 ; Position checking
%IF #FRMCANNED=0 %THEN %NOCYCLE ; Cycle not supported
%IF PATHTRACE=1 %THEN %NOCYCLE ; Cycle not required
#HOLEFLAG=1
%CALL=PT_HOLE_CYCLES

%CALL=CODECON_REAM-CYCLE
#HOLEFLAG=0

*Initialise Z position at clearance - end of cycle
#ZMOVE=ZCLEAR*#ZREVERSE
<[#ZMOVE=10]>
#DRGCODE=DATA1(65):<[#DRGCODE=10]> ; reset
#GCODE=DATA1(65):<[#GCODE=10]> ; reset

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 267 _____
;
%PROCEDURE=PMACRO-267
* Processing logic called by Bore Cycle
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-267:%CALL=ENTER_PROCEDURE

#INTHRD=#FALSE
#ATREFPT=0 ; Position checking
%IF #FBRCANNED=0 %THEN %NOCYCLE ; Cycle not supported
%IF PATHTRACE=1 %THEN %NOCYCLE ; Cycle not required
#HOLEFLAG=1
%CALL=PT_HOLE_CYCLES

%CALL=CODECON_BORE-CYCLE
#HOLEFLAG=0

*Initialise Z position at clearance - end of cycle
#ZMOVE=ZCLEAR*#ZREVERSE
<[#ZMOVE=10]>
#DRGCODE=DATA1(65):<[#DRGCODE=10]> ; reset
#GCODE=DATA1(65):<[#GCODE=10]> ; reset

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 10 _____
;
%PROCEDURE=PMACRO-10
* Processing logic called by macro 8, Tapping Cycle
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-10:%CALL=ENTER_PROCEDURE

#THRDFLAG=1 ; Threading flag for feedtype control

* Check peck tapping
%IF DEPTH=0 @NOPECK
%IF DEPTH=#FUNNY @NOPECK
%IF #LHFPECKTAP=1 %THEN %NOCYCLE
@NOPECK

%CALL=PRIORITY_CHECK
#ATREFPT=0 ; Position checking
#INTHRD=#FALSE
%IF #FTPCANNED=0 %THEN %NOCYCLE ; Cycle not supported
%IF PATHTRACE=1 %THEN %NOCYCLE ; Cycle not required

%CALL=PT_HOLE_CYCLES

%CALL=CODECON_TAPPING-CYCLE
*
*Initialise Z position at clearance - end of cycle
#ZMOVE=ZCLEAR*#ZREVERSE
<[#ZMOVE=10]>
#DRGCODE=DATA1(65):<[#DRGCODE=10]> ; reset
#GCODE=DATA1(65):<[#GCODE=10]> ; reset

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 15 _____
;

%PROCEDURE=PMACRO-15
* Processing logic called by macro 15, Toolchange
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-15:%CALL=ENTER_PROCEDURE

*Set macro ID
#MACRO=15
%IF USERVAR1=#FUNNY %THEN USERVAR1=0 ; Check
%IF USERVAR3=#FUNNY %THEN USERVAR3=0 ; Check
#THRDFLAG=0 ; Cancel feedtype flag
#SPINWARN=#SPINWARNSAVE ; Reset

* Check Rapid to ToolChange
%IF #ATREFPT=1 @CHECKDONE
%IF #TOOLRAPWARN=0 @CHECKDONE

* No Rapid_to_ToolChange call
$WARNING="Warning - Rapid to Toolchange should be performed prior to a Toolchange":%CALL=CODECON_WARNING

@CHECKDONE



* Force CAXIS=0
CAXIS=0
#SPINDLE=SPINDLE ; Maintain alignment
%IF #SPINDLE=SPINDLEID1 %THEN #C1HOLD=#FUNNY:#CMOVE1=#FUNNY:<[#CMOVE1=10]>  ; Spindle running
%IF #SPINDLE=SPINDLEID2 %THEN #C2HOLD=#FUNNY:#CMOVE2=#FUNNY:<[#CMOVE2=10]>

* #DIAM=#TURNDIAM*#XREVERSE
%CALL=PT_MODIFIERS ; Set X Z Reverses and #DIAM

#TOOLCHANGE=1 ; Toolchange
#TOOLCHANGEROT=#TRUE		;	Flag for spindle brake
#INTHRD=#FALSE
#GCODE=DATA1(1)

* Set driven flag
#DRIVENTOOL=#TOOLSTATIC
*Set plane
;	Axial = G17, Radial = G19  (Turn = G18)
#PLANEGCODE=DATA1(14) ; Turn
%IF CAXIS=1 %THEN #PLANEGCODE=DATA1(13)  ; Axial
%IF CAXIS=2 %THEN #PLANEGCODE=DATA1(15) ; Radial
%IF CAXIS=3 %THEN #PLANEGCODE=DATA1(13) ; B axis profiling

%LOAD=SUBFUNCT
#CSS=CSS
#POSREP=POSITION:<[#POSREP=10]>
%OUTPUT-IF-CHANGED=#POSREP

%IF USERVAR2=1 %THEN #WORKGCODE=DATA1(26)
%IF USERVAR2=2 %THEN #WORKGCODE=DATA1(27)
%IF USERVAR2=3 %THEN #WORKGCODE=DATA1(28)
%IF USERVAR2=4 %THEN #WORKGCODE=DATA1(29)
%IF USERVAR2=5 %THEN #WORKGCODE=DATA1(30)
%IF USERVAR2=6 %THEN #WORKGCODE=DATA1(31)


* Coolant setting
* Auto Coolant control
%IF #AUTOCOOL=0 @NOTAUTO
#COOL=DATA2(8)          ; Coolant flow
#SETCHUCKCOOL=#AUTOCHUCKFACE     ; Coolant taps as required
#SETSPINDLECOOL=#AUTOSPINDLE
#SETTURRETCOOL=#AUTOTURRET
@NOTAUTO

*Manual Over-ride
* %CALL=PT_COOL_CANCEL
%CALL=PT_THROUGH_COOL
%CALL=PT_SET_COOLANT_FLOW
%CALL=PT_SET_COOLANT_TAPS

* Set Angle at Tool Change
#TCANGLE=#TCANGLE1


%CALL=GET_QUADRANT

#USERMAXRPM=USERVAR1

* Load all next tool parameters and reload current
%CALL=PT_LOAD_NEXT

#CSS=CSS

%CALL=PT_TLO_SET

*
%IF TOOLNUM=0 %THEN $TOOLDESCRIPTION=USERDEFINEDSTRING %ELSE $TOOLDESCRIPTION=TOOLDESCRIPTION
*
%IF #TLOCOMP=#TRUE %THEN #TOOLXSET=TOOLXSET %ELSE #TOOLXSET=0		;	If TLOCOMP=True output turret datum else output gauge point
%IF #TLOCOMP=#TRUE %THEN #TOOLZSET=TOOLZSET %ELSE #TOOLZSET=0
*
%CALL=PT_GET-TNRXZ						;	Obtain and calculate correct sign for Tool Nose Rad in X and Z
*	Calculate Turret Index Direction hence MCode
#TCFUNCT=SUBFUNCT:%CALL=PT_INDEX_TURRET	;	#TCFUNCT used to determine turret rotation shortest path
*
* Feed Type
%IF FEEDTYPE=1 @FEED-MIN
#TMP=DATA1(47)
%IF #FEEDMODEGCODE=#TMP @ENDFEED
#FEEDMODEGCODE=DATA1(47)		;	Feed / rev
%GOTO @ENDFEED

@FEED-MIN
#TMP=DATA1(46)
%IF #FEEDMODEGCODE=#TMP @ENDFEED
#FEEDMODEGCODE=DATA1(46)		;	Feed / min
*
@ENDFEED
%CANCEL=#FEEDMODEGCODE

* CRC Register
%IF USERVAR1<>0 %THEN #COMPDCODE1=USERVAR1:%GOTO @CRCDONE
%IF #AUTOREG=1 %THEN #COMPDCODE1=POSITION+#MAXTOOLS %ELSE #COMPDCODE1=POSITION
@CRCDONE

* Spindle Control
#SPEEDHOLD=0 ; Trap same value after ToolChange
#RPMHOLD=0
%CALL=PMACRO-252

*  Reset Toolchange positions
%CALL=PT_TC_REFERENCE_SHIFT
#XTOOL=#XFIXED*#DIAM
#ZTOOL=#ZFIXED*#ZREVERSE

*Reset HOLD values
%CALL=PT_SET_TOOL_TURN

@CALL
* Tool Change Call
#COMPDCODE=#COMPDCODE1
%CALL=CALL_TC
%CANCEL=#FEED

#COMPDCODE=#FUNNY

@END
#FIRSTIME=2
*	Hold Tool Gauge values for use in G92/G50 type machines
#XGHOLD=TOOLXSET:#ZGHOLD=TOOLZSET
*
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;_________________________________Tool Change Utility
;

%PROCEDURE=PT_LOAD_NEXT
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_LOAD_NEXT:%CALL=ENTER_PROCEDURE
* Load next tool parameters and first tool
* Reload current tool at the end

#TMP=SUBFUNCT+1
%IF SUBFUNCT=#NUMTOOLS %THEN #TMP=1
%LOAD=#TMP
#NEXTTOOL=POSITION
$NEXTGROUP=GROUP
#NEXTGROUPNUM=GROUPNUMBER
$NEXTGROUPSTRING=GROUPSTRING
$NEXTID=ID
#NEXTIDNUMBER=IDNUMBER
$NEXTIDSTRING=IDSTRING
$NEXTCOM=USERDEFINEDSTRING
$NEXTDESCR=TOOLDESCRIPTION

%LOAD=1
#FIRSTTOOL=POSITION

* Always reload current tool before leaving
%LOAD=SUBFUNCT

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=CALL_TC
%IF #PROCTRACE=1 %THEN $PROCEDURE=CALL_TC:%CALL=ENTER_PROCEDURE

%IF #TOOLSTRIP=1 %THEN %CALL=STRIP_BRACKETS ; Modify description

%IF SUBFUNCT<>1 @GENERAL
*First

%CALL=CODECON_FIRST-TOOLCH:%GOTO @TC-DONE


*
@GENERAL


%CALL=CODECON_GEN-TOOLCH



*



@TC-DONE

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 20 _____
;

%PROCEDURE=PMACRO-20
* This procedure is no longer used by template logic
* Processing logic called by macro 20, Constant_Surface_Speed
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-20:%CALL=ENTER_PROCEDURE

%IF CSS=1 %THEN %GOTO @CSSON %ELSE %GOTO @CSSOFF
@CSSON
* Check for FPM Conversion
%IF #FTYPETURN=2 %THEN $WARNING="WARNING : Constant surface speed active with FPM conversion":%CALL=CODECON_WARNING

%IF #CSSGCODE=DATA1(45) %THEN #TEMP=#FALSE %ELSE #TEMP=#TRUE
%GOTO @COMPLETE

@CSSOFF
%IF #CSSGCODE=DATA1(44) %THEN #TEMP=#FALSE %ELSE #TEMP=#TRUE
%GOTO @COMPLETE

@COMPLETE

%IF #TEMP=#FALSE @END ; CSS mode has not changed.
#SPEED=NEXTSPEED:#RPM=NEXTSPEED
%IF CSS=1 %THEN #CSSGCODE=DATA1(45) %ELSE #CSSGCODE=DATA1(44)

%IF NEXTMACRO=101 @END		;Spindle Direction
%IF NEXTMACRO=110 @END		;Gear Select
%IF NEXTMACRO=15 @END		;Tool Change
%IF #FIRSTIME=1 @END		;Tool change has not occured yet

%IF NEXTCSS=1 %THEN #SFM=NEXTSPEED:%CALL=PT_MTH_SFM_TO_RPM	;	Calculate the Rpm at X after Toolchange
%IF NEXTCSS=1 %THEN #SPEED=#SFM %ELSE #SPEED=#RPM			;	Assign Speed variable as either surface speed or Rpm

%CALL=CODECON_SPINDLE_CONTROL
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 29 _____
;

%PROCEDURE=PMACRO-29
* Processing logic called by macro 29, Compensation==Off/Left/Right/Pathcomp
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-29:%CALL=ENTER_PROCEDURE

#COMPGCODETOTAL=DATA1(86)+DATA1(87) ; Used for code swaps

$COMPOUTPUT=FALSE
%IF USERVAR1=#FUNNY %THEN USERVAR1=0
%IF USERVAR1<>0 %THEN #COMPDCODE1=USERVAR1  ; CRC Register
#LEADOUTCOUNT=#FUNNY  ;	Comp is cancelled when #LEADOUTCOUNT=1

%IF SUBFUNCT=1 %THEN #COMPON=#FALSE:#COMPGCODEHOLD=DATA1(85):%GOTO @CONTINUE2	;	Off
%IF SUBFUNCT=2 %THEN #COMPON=#TRUE:#COMPGCODEHOLD=DATA1(86):%GOTO @MODECHECK	;	Left
%IF SUBFUNCT=3 %THEN #COMPON=#TRUE:#COMPGCODEHOLD=DATA1(87):%GOTO @MODECHECK	;	Right
#COMPON=#FALSE  ; SUBFUNCT=4 Pathcomp

* Conpensation is handled by the PT_OUTPUT_FEED and XZ_PLANE procedures
@MODECHECK
%IF TURRET=0 @CONTINUE ; 11/01
%IF CAXIS>0 @CYMODECHECK
%IF #LOWERREVCRC=1 %THEN #COMPGCODEHOLD=#COMPGCODETOTAL-#COMPGCODEHOLD ; Reverse on lower turret
%GOTO @CONTINUE2

@CYMODECHECK
* Lower Turret Driven
%IF #LOWERCYCRC=1 %THEN #COMPGCODEHOLD=#COMPGCODETOTAL-#COMPGCODEHOLD ; Reverse on lower turret

@CONTINUE
* Axial only
%IF CAXIS>1 @CONTINUE2
%IF SPINDLE=SPINDLEID1 @CONTINUE2
%IF #SUBREVCRCDRIVEN<>1 @CONTINUE2
* Sub Spindle, driven
#COMPGCODEHOLD=#COMPGCODETOTAL-#COMPGCODEHOLD ; Reverse on sub spindle

@CONTINUE2
* If Compensation factor is 0 then output comp codes imediately
* Note that subfunct is not used in profiling if CRCFactor=0
#TEMP=1.5 ; Radius Comp Factor from MM line
%IF #TEMP<>0 @END
#COMPDCODE=#COMPDCODE1
#COMPGCODE=#COMPGCODEHOLD
*
%IF #COMPGCODE=#FUNNY @END
%CALL=CODECON_CUTTER-COMPENSATION
#COMPON=1
%IF SUBFUNCT=1 %THEN #COMPON=0
#COMPDCODE=#FUNNY

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 32 _____
;
%PROCEDURE=PMACRO-32
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-32:%CALL=ENTER_PROCEDURE


* TURNING  X values in YSUB YINC YEND,  Z values in XSUB, XINC XEND  !!

%IF NOCYCLE=1 @ALLPASSES

* First pass only - Initialise start point
* First pass through translate is second call of subroutine.
#XSUB=YEND
#ZSUB=XEND

@ALLPASSES
*
%IF PATHTRACE=1 %THEN %NOCYCLE

#GCODE=DATA1(1)

%IF #INCRSUBS=#FALSE @ABSSUBS
* Incremental Subroutines
#XSUB=#XSUB+YINC
#ZSUB=#ZSUB+XINC
#XMOVE=#XSUB
#ZMOVE=#ZSUB

%IF #INCRXYZ=0 @APPROACH
#XMOVE=XINC+#XHOLD
#ZMOVE=ZINC+#ZHOLD
%GOTO @APPROACH

@ABSSUBS
* Absolute subroutines
#XMOVE=#XSUB+YINC
#ZMOVE=#ZSUB+XINC

@APPROACH
* #XMOVE=#XMOVE
* #ZMOVE=#ZMOVE
%CALL=PT_OUTPUT_RAPID

* prevent output of null effect G92 block
%IF XEND<>#XHOLD @APPLY
%IF ZEND=#ZHOLD @SUBCALL

@APPLY
*	Apply translation - G92 will reset registers
#XMOVE=XEND
#ZMOVE=ZEND
#PRESETGCODE=DATA1(24)

@OUTPUT
#XMOVE=#XMOVE*#DIAM
#ZMOVE=#ZMOVE*#ZREVERSE
%IF #INCRSUBS=#FALSE %THEN %CALL=CODECON_TRANSLATE

@SUBCALL
*	Call Subroutine
*	If Increment Subroutines by ... is not set then start at Progid & increment by one else use the increment.
%IF #INCRSUBNUMBER=#FUNNY %THEN #SUBROUTINE=SUBROUTINE+#SUBNOSTART %ELSE #SUBROUTINE=(SUBROUTINE*#INCRSUBNUMBER)+#SUBNOSTART

%IF MASK=1 @SKIP
%IF #MACRO=32 @SKIP
*Output approach move for first call, not translated calls

#XMOVE=NEXTXMOVE
#YMOVE=NEXTYMOVE
#ZMOVE=NEXTZMOVE
%CALL=PT_OUTPUT_RAPID
@SKIP

%CANCEL=STARTSUB,ENDSUB
%CALL=CODECON_SUBROUTINE-CALL


@END

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM





;
;___________________________________________________________ Macro = 40 _____
;
*
%PROCEDURE=PMACRO-40
* Processing logic called by macro 40, Rapid to home
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-40:%CALL=ENTER_PROCEDURE

#INTHRD=#FALSE
*	Better to Externalise into procedure call called from RAPIDGCODE Token
#GCODE=DATA1(1):#FEED=#FUNNY
*
%IF #FEEDRAPIDS=#FALSE @MISS_CONVERT_TO_FEED
#GCODE=DATA1(2)
#FEEDMODEGCODE=DATA1(46)	;	Feed / Min for high feed move
#CONVERTEDMOVE=1
%CALL=PT_CONTROL_FEEDTYPE
*
@MISS_CONVERT_TO_FEED
%CALL=PT_HOME_REFERENCE_SHIFT ; Set move target
*
%CALL=PT_RAPID_TO_HOME_TOOLCHANGE
*	Code Constructor called from procedure since loop used for output different strategies
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
*
;
;___________________________________________________________ Macro = 41 _____
;
*
%PROCEDURE=PMACRO-41
* Processing logic called by macro 41, Rapid to tool change
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-41:%CALL=ENTER_PROCEDURE

#INTHRD=#FALSE
*	Better to Externalise into procedure call called from RAPIDGCODE Token
#GCODE=DATA1(1):#FEED=#FUNNY
*
%IF #FEEDRAPIDS=#FALSE @MISS_CONVERT_TO_FEED
*
#GCODE=DATA1(2)
#FEEDMODEGCODE=DATA1(46)	;	Feed / Min for high feed move
#CONVERTEDMOVE=1
%CALL=PT_CONTROL_FEEDTYPE
*
@MISS_CONVERT_TO_FEED
*
%CALL=PT_TC_REFERENCE_SHIFT ; Set move target
%CALL=PT_RAPID_TO_HOME_TOOLCHANGE
*
* Reset ToolChange position for subsequent use
#XTOOL=#XFIXED*#DIAM
#ZTOOL=#ZFIXED*#ZREVERSE
*
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 48 _____
;

%PROCEDURE=PMACRO-48
* Datum Shift
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-48:%CALL=ENTER_PROCEDURE

#XMOVE=XSUB:#YMOVE=YSUB:#ZMOVE=ZSUB


%IF STYPE=0 @INCR   ; 2005a

* <Sysid [SYSID=13]>
#SYSID=SYSID*1000000:%IF #UNIQUEDATUMS=#TRUE %THEN #SYSID=(#SYSID+(ROT1*1000)+ROT2) ; Make Datum unique by XYZ and Rotation

%IF #G54=#SYSID %THEN #WORKGCODE=54:%GOTO @CALL ; 2005
%IF #G55=#SYSID %THEN #WORKGCODE=55:%GOTO @CALL ; 2005
%IF #G56=#SYSID %THEN #WORKGCODE=56:%GOTO @CALL ; 2005
%IF #G57=#SYSID %THEN #WORKGCODE=57:%GOTO @CALL ; 2005
%IF #G58=#SYSID %THEN #WORKGCODE=58:%GOTO @CALL ; 2005
%IF #G59=#SYSID %THEN #WORKGCODE=59:%GOTO @CALL ; 2005
STYPE=0

@INCR ; 2005
%IF #BASETYPE=0 %THEN #TURNZDATUM=ZSUB-#TURNZDATUM %ELSE #TURNZDATUM=ZINC ; 2205
#XMOVE=0
#YMOVE=0
#ZMOVE=#TURNZDATUM
%CALL=CODECON_DATUM_SHIFT_TURN
%GOTO @END  ; 2005

@CALL ;2005
#ZMOVE=ZSUB ; 2005
#TURNZDATUM=ZSUB
%CALL=CODECON_DATUM_SET_TURN

@END

#XMOVE=XCPL*#DIAM*#XREVERSE                        ; W65474
%IF TURRET=1 %THEN #XMOVE=#XMOVE*#X2REVERSE        ; W65474

#YMOVE=YCPL*#YREVERSE                              ; W65474
#ZMOVE=ZCPL                                        ; W65474
#ZMOVE=#ZMOVE*#ZREVERSE                            ; W65474
<[#XMOVE=10][#YMOVE=10][#ZMOVE=10]> ; initialise   ; W65474
%IF TURRET=0 @ENDALL                               ; W65474
#UMOVE=#XMOVE:#WMOVE=#ZMOVE                        ; W65474
<[#UMOVE=10][#WMOVE=10]>            ; initialise   ; W65474

@ENDALL                                            ; W65474
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

; ________________________________________________

%PROCEDURE=PT_TC_REFERENCE_SHIFT
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_TC_REFERENCE_SHIFT:%CALL=ENTER_PROCEDURE
* Controls target point for Rapid to Tool Change
* Sets #XFIXED etc and #TMP1/2/3 for processing according to options

%IF #REFSHIFT=2 @SHIFT2

* Upper Turret
#XFIXED=XTOOL
#ZFIXED=ZTOOL
#YFIXED=YTOOL

%IF #REFSHIFT=1 @ALLFIX
* REFSHIFT=1 Datum not adjusted
* REFSHIFT=0 Datum adjusted by Gauge Length
#XFIXED=#XFIXED-TOOLXSET
#ZFIXED=#ZFIXED-TOOLZSET	;	TMP1&2 common variables in procedure
%GOTO @ALLFIX


@ALLFIX
%IF TURRET=1 %THEN #XFIXED=#XFIXED*#X2REVERSE

@SHIFT2
* Set MOVE position via #TMP1 etc
#TMP1=XMOVE   ; Move positions
#TMP2=ZMOVE
#TMP3=YMOVE
%IF #MACRO=15 %THEN #TMP1=XCPL:#TMP2=ZCPL:#TMP3=YCPL:%GOTO @SHUFFLEPLANAR1  ; 2802
%IF #MACRO=165 %THEN #TMP1=XCPL:#TMP2=ZCPL:#TMP3=YCPL:%GOTO @SHUFFLEPLANAR1 ; 2802
*
%IF MILLMODE=0 @NOSHUFFLE1
@SHUFFLEPLANAR1
%IF BAXIS=0 @NOSHUFFLE1
%IF CAXIS<>2 @NOSHUFFLE1
*
#SHUFFLE=#TMP1
#TMP1=#TMP2
#TMP2=#SHUFFLE*-1
*
@NOSHUFFLE1
*
%IF #REFSHIFT<>2 @END
* <REFSHIFT 2>
%IF #MACRO=165 @TOOLCHANGE
%IF #MACRO=15 @TOOLCHANGE

* <RAPID TO TOOLCHANGE Caxis=[CAXIS=13] Millmode=[MILLMODE=13]>
* Set Fixed position to MOVE coords
#XFIXED=XMOVE ; Fixed positions
#YFIXED=YMOVE
#ZFIXED=ZMOVE
%IF CAXIS>0 @CY
%IF TURRET=0 @END
*
@LWR
#XFIXED=#XFIXED*#X2REVERSE
%GOTO @END
*
@CY
%IF MILLMODE=0 @NOSHUFFLE2
* <SHUFFLE2 BAXIS=[BAXIS=13]>
%IF CAXIS<>2 @NOSHUFFLE2
%IF BAXIS=0 @NOSHUFFLE2  ; 1403
*
#SHUFFLE=#XFIXED
#XFIXED=#ZFIXED
#ZFIXED=#SHUFFLE*-1
%IF TURRET=1 @NOSHUFFLE2
%IF MILLMODE=1 @NOSHUFFLE2 ; 1403
%IF SPINDLE=SPINDLEID2 %THEN #ZFIXED=#ZFIXED*-1

@NOSHUFFLE2
%IF TURRET=1 %THEN #XFIXED=#XFIXED*#X2REVERSE
%IF CAXIS<>1 @END
%IF SPINDLE=SPINDLEID1 @END
*
* Align coordinates for axial on sub spindle
%IF TURRET=1 @LOWER99
* %IF MILLMODE=1 @END   ; 1403 removed
#XFIXED=#XFIXED*-1:#ZFIXED=#ZFIXED*-1  ; Upper turret
%GOTO @END

@LOWER99
%IF MILLMODE=0 @END
* #XFIXED=#XFIXED*-1 ;1403 removed
%IF SPINDLE=SPINDLEID2 %THEN #ZFIXED=#ZFIXED*-1
%GOTO @END

@TOOLCHANGE
* <TOOLCHANGE Caxis=[CAXIS=13] Millmode=[MILLMODE=13]  [XCPL=0][YCPL=1][ZCPL=2]>
* Set Fixed position to XCPL etc
#XFIXED=XCPL
#YFIXED=YCPL
#ZFIXED=ZCPL
%IF CAXIS=2 @TCRADIAL
%IF TURRET=1 %THEN #XFIXED=#XFIXED*#X2REVERSE
%IF CAXIS=1 @TCAXIAL
%IF CAXIS=3 @END
%IF SPINDLE=SPINDLEID1 @END ;1403
* Turning, sub spindle
#ZFIXED=#ZFIXED*-1
%GOTO @END
*
@TCAXIAL
* Axial
%IF TURRET=1 @TCAXIALLWR
* <* Upper Turret Axial>
%IF BMOVE=0 @END      ; 1403
%IF MILLMODE=1 %THEN #XFIXED=#XFIXED*-1:#ZFIXED=#ZFIXED*-1
%GOTO @END

@TCAXIALLWR
%IF BMOVE=0 @END      ; 1403
#XFIXED=#XFIXED*-1:#ZFIXED=#ZFIXED*-1  ; 1403 XCPL etc always planar
%GOTO @END

@TCRADIAL
* Radial
#SHUFFLE=#XFIXED
#XFIXED=#ZFIXED
#ZFIXED=#SHUFFLE   ; 1903 Fix
%IF TURRET=0 %THEN #ZFIXED=#SHUFFLE*-1 ; 1903 Fix
%IF TURRET=1 %THEN #XFIXED=#XFIXED*-1:#XFIXED=#XFIXED*#X2REVERSE

@END
* <Fixed [#XFIXED=0][#ZFIXED=2]>
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

%PROCEDURE=PT_HOME_REFERENCE_SHIFT
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_HOME_REFERENCE_SHIFT:%CALL=ENTER_PROCEDURE
* Controls target point for Rapid to Home
* Sets #XFIXED etc and #TMP1/2/3 for processing according to options

%IF #REFSHIFT=2 @SHIFT2

* Upper Turret
#XFIXED=XHOME
#ZFIXED=ZHOME
#YFIXED=YHOME

%IF #REFSHIFT=1 @ALLFIX
* REFSHIFT=1 Datum not adjusted
* REFSHIFT=0 Datum adjusted by Gauge Length
#XFIXED=#XFIXED-TOOLXSET
#ZFIXED=#ZFIXED-TOOLZSET	;	TMP1&2 common variables in procedure
%GOTO @ALLFIX


@ALLFIX
%IF TURRET=1 %THEN #XFIXED=#XFIXED*#X2REVERSE

@SHIFT2
* Set MOVE position via #TMP1 etc
#TMP1=XMOVE   ; Move positions
#TMP2=ZMOVE
#TMP3=YMOVE
*
%IF MILLMODE=0 @NOSHUFFLE1
@SHUFFLEPLANAR1
%IF BAXIS=0 @NOSHUFFLE1
%IF CAXIS<>2 @NOSHUFFLE1
*
#SHUFFLE=#TMP1
#TMP1=#TMP2
#TMP2=#SHUFFLE*-1
*
@NOSHUFFLE1
*
%IF #REFSHIFT<>2 @END
* <REFSHIFT 2>
* Set Fixed position to MOVE coords
#XFIXED=XMOVE ; Fixed positions
#YFIXED=YMOVE
#ZFIXED=ZMOVE
%IF CAXIS>0 @CY
%IF TURRET=0 @END
*
@LWR
#XFIXED=#XFIXED*#X2REVERSE
%GOTO @END
*
@CY
%IF MILLMODE=0 @NOSHUFFLE2
* <SHUFFLE2 BAXIS=[BAXIS=13]>
%IF CAXIS<>2 @NOSHUFFLE2
%IF BAXIS=0 @NOSHUFFLE2  ; 1403
*
#SHUFFLE=#XFIXED
#XFIXED=#ZFIXED
#ZFIXED=#SHUFFLE*-1
%IF TURRET=1 @NOSHUFFLE2
%IF MILLMODE=1 @NOSHUFFLE2 ; 1403
%IF SPINDLE=SPINDLEID2 %THEN #ZFIXED=#ZFIXED*-1

@NOSHUFFLE2
%IF TURRET=1 %THEN #XFIXED=#XFIXED*#X2REVERSE
%IF CAXIS<>1 @END
%IF SPINDLE=SPINDLEID1 @END
*
* Align coordinates for axial on sub spindle
%IF TURRET=1 @LOWER99
* %IF MILLMODE=1 @END   ; 1403 removed
#XFIXED=#XFIXED*-1:#ZFIXED=#ZFIXED*-1  ; Upper turret
%GOTO @END

@LOWER99
%IF MILLMODE=0 @END
* #XFIXED=#XFIXED*-1 ;1403 removed
%IF SPINDLE=SPINDLEID2 %THEN #ZFIXED=#ZFIXED*-1
*
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;___________________________________________________________ Macro = 53 & 54 _____
;
%PROCEDURE=PMACRO-ARCS
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-ARCS:%CALL=ENTER_PROCEDURE

#INTHRD=#FALSE


@FEED
%CALL=XZ_PLANE

* Check result of NOMOTION for single quadrant arcs
* Modified Feb05 - always check #move as 360 arc not possible in turning
* %IF CIRCLE<>1 @OUTPUT
%IF #MOVE=0 @END

@OUTPUT
%IF #MACRO=53 %THEN %CALL=CODECON_CIRCULAR-INT-CLW
%IF #MACRO=54 %THEN %CALL=CODECON_CIRCULAR-INT-CCLW

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Macro = 59 _____
;

%PROCEDURE=PT_OUTPUT_SUBCALL
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_OUTPUT_SUBCALL:%CALL=ENTER_PROCEDURE

*	If Increment Subroutines by ... is not set then start at Progid & increment by one else use the increment.
%IF #INCRSUBNUMBER=#FUNNY %THEN #SUBROUTINE=SUBROUTINE+#SUBNOSTART %ELSE #SUBROUTINE=(SUBROUTINE*#INCRSUBNUMBER)+#SUBNOSTART

%IF MASK=1 @SKIP
*Output approach move for first call
*#XMOVE=NEXTXMOVE
*#ZMOVE=NEXTZMOVE
#ZMOVE=XPOINT(LAST) ; 0110 JRI
#XMOVE=YPOINT(LAST) ; 0110 JRI

%IF #XCYCSTART=#FUNNY @SKIP_JRI
#XMOVE=#XCYCSTART	; field12 will be compared to these
@SKIP_JRI
%IF #ZCYCSTART=#FUNNY @SKIP_JRI2
#ZMOVE=#ZCYCSTART
@SKIP_JRI2

#XKEEP=#XMOVE
#ZKEEP=#ZMOVE
#XMOVE=#XMOVE*#DIAM
* <[#XMOVE=10][#ZMOVE=10]>

* that use of '=10' should have updated everything to the state at the end of the subroutine without any nc output
* so that cyclesub_return will now succeed in actually outputting the field12 values:-
%CANCEL=#ZMOVE,#XMOVE
%IF #ENDSTYLE=2 %THEN <[#XMOVE=10][#ZMOVE=10]>:%CALL=CYCLSUB_RETURN ; new idea jri :140421 output zx field12 vars for the AT-END case

* ;IF TEMPLATE=2AXLATHE^2AXSSLATHE^4AXLATHE^4AXSSLATHE
* %CALL=PT_OUTPUT_RAPID
* ;ENDIF

* ;IF TEMPLATE=2CXLATHE^2CYLATHE^2CYSSLATHE^2CYBLATHE^2CYBSSLATHE^4CXLATHE^4CYLATHE^4CYSSLATHE^4CYBLATHE^4CYBSSLATHE
* %IF CAXIS=0 %THEN %CALL=PT_OUTPUT_RAPID %ELSE %CALL=C_RAPID
* ;ENDIF

@SKIP

%CANCEL=STARTSUB,ENDSUB

%CALL=CODECON_SUBROUTINE-CALL

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 61 _____
;
%PROCEDURE=PMACRO-61
* Processing logic called by macro 61, Cyclesub
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-61:%CALL=ENTER_PROCEDURE

%IF #RESTARTSUBSBNUM=#TRUE %THEN #BNUMHOLD=#BNUM:#BNUM=0 ; Restart Block numbering for Subprograms

* <Cyclsub start  [#XKEEP=0][#ZKEEP=2]>
%IF DEPTH=#DEPTHTURN %THEN #XMOVE=YPOINT(1):#ZMOVE=#ZKEEP	;#TMP stash for Arc Ivalue use
* Note that #XKEEP is diametral in canned cycle
%IF DEPTH=#DEPTHFACE %THEN #XMOVE=#XKEEP/#ABSDIAM:#ZMOVE=XPOINT(1)

%IF #FORCESTART=1 %THEN %CANCEL=#XMOVE,#ZMOVE,#UMOVE,#WMOVE

*  Block numbering, special cases
%IF #USEBNUM>0 @JUMP
#BNUM=#BNUM+#BNUMINC
%IF #FORCEBNUM=0 @JUMP
%OUTPUT-IF-CHANGED=#BNUM

@JUMP

********************************************************
%IF #TRCYCLSUB=0 @NOTRACE
<*>
<* Current (Start) position [#XKEEP=0][#ZKEEP=2]>
<* CYCLSUB ARRAY -  [LAST=13] Records>
#LOOP=0
@START
#LOOP=#LOOP+1
%IF #LOOP>LAST @ENDTRACE
* Output position in CAM coordinates
#TRZ=XPOINT(#LOOP)
#TRX=YPOINT(#LOOP)
#TMP=RADIUS(#LOOP)
%IF #TMP=0 @LINE
$TMPSTR="Radius "
$CYCLTYPE="Arc Centre "

<* [#LOOP=13] [$CYCLTYPE][#TRX=0][#TRZ=2] [$TMPSTR][#TMP=13]>
#LOOP=#LOOP+1
#TRZ=XPOINT(#LOOP)
#TRX=YPOINT(#LOOP)
%IF MASK=0 %THEN FEED=CYCLFEED(#LOOP)
%IF MASK=0 %THEN SPEED=CYCLSPEED(#LOOP)
$CYCLTYPE="End    "
<*       [$CYCLTYPE][#TRX=0][#TRZ=2] Feed=[FEED=13] Speed=[SPEED=13]>  ; 0306
%GOTO @START

@LINE
$CYCLTYPE="Line       "
%IF MASK=0 %THEN FEED=CYCLFEED(#LOOP)
%IF MASK=0 %THEN SPEED=CYCLSPEED(#LOOP)
<* [#LOOP=13] [$CYCLTYPE][#TRX=0][#TRZ=2] Feed=[FEED=13] Speed=[SPEED=13]>  ; 0306
%GOTO @START

@ENDTRACE
<*>
@NOTRACE
********************************************************

%IF $MACHINE=OKUMA %THEN %CALL=CODECON_START_TURN_CYCLE

* Set and call compensation if required. This is the same logic as used in CRC_HANDLER procedure
* NB #COMPON may be uninitialised - same as #false

%IF #COMPON<>#TRUE @SKIP
%IF #CYCENDMOVE<>1 @SKIP ; CRC on only if extension lead out in use for G40

#COMPGCODE=#COMPGCODEHOLD
* %IF #AUTOREG=1 %THEN #COMPDCODE1=POSITION+#MAXTOOLS %ELSE #COMPDCODE1=POSITION
#COMPDCODE=#COMPDCODE1
%CALL=CODECON_CUTTER-COMPENSATION

$COMPOUTPUT=TRUE
* #COMPDCODE=#FUNNY
#LEADOUTCOUNT=#FUNNY
@SKIP

* Approach start of profile before cycle
%IF #APPROACHIN=0 %THEN %CALL=DIVERT_CYCLSUB_RAPID

* Set up start block for cyclsub
STARTSUB=#BNUM
%IF #APPROACHIN>0 %THEN STARTSUB=STARTSUB+#BNUMINC ;Adjust

* Start outputing array
#LOOP=1
#SUBROUTINE=SUBROUTINE:%CALL=CODECON_SUBROUTINE-START ;	Used for Subprograms - codecon empty for Blknum type

* Approach start of profile inside cycle
%IF #APPROACHIN=1 %THEN %CALL=DIVERT_CYCLSUB_RAPID

*	XY Point array used for linear and arc moves
@LOOP

%IF #LOOP>LAST @ENDLOOP ; end of array

#LOOP2=#LOOP
RADIUS=RADIUS(#LOOP)
%IF RADIUS<>0 %THEN #LOOP2=#LOOP+1 ; Arc record takes 2 lines in array
%IF #LOOP2<LAST @JUMP11

* Last block, special case block numbers
%IF #USEBNUM>0 @JUMP11
#BNUM=#BNUM+#BNUMINC

@JUMP11
%IF RADIUS=0 %THEN %CALL=CYCLSUB_LINEAR %ELSE %CALL=CYCLSUB_ARC


#LOOP=#LOOP+1
%GOTO @LOOP
@ENDLOOP
* #PROF=#FUNNY
@END



%CALL=CODECON_SUBROUTINE-END			;	Used for Subprograms - codecon empty for Blknum type

%IF #CYCENDMOVE<>1 @CONTINUE
#XHOLD=#XCYCSTART ;Okuma Cyclesub end
#ZHOLD=#ZCYCSTART

@CONTINUE
#TOOLCHANGE=0 ; Toolchange

%IF #USEBNUM=#FALSE %THEN %DONT-OUTPUT=#BNUM      ;Reset block number output
%IF #USESBNUM=#FALSE %THEN %DONT-OUTPUT=#SBNUM

* Cancel Cutter comp if turned on
%IF #COMPON=#FALSE @SKIPCOMPOFF
%IF #COMPON=#FUNNY @SKIPCOMPOFF
#COMPGCODE=DATA1(85)
%CALL=CODECON_CUTTER-COMPENSATION

$COMPOUTPUT=TRUE
#LEADOUTCOUNT=#FUNNY

@SKIPCOMPOFF
%IF #ENDSTYLE<>2 @END99
%IF FIELD12=0 @END99
%CALL=CYCLSUB_RETURN
@END99

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*******************************************************************

%PROCEDURE=PMACRO-104
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-104:%CALL=ENTER_PROCEDURE

*Macro 104, Code Generator instruction
* Pressure
%IF SUBFUNCT=1 %THEN #COOL=DATA2(9)
%IF SUBFUNCT=2 %THEN #COOL=DATA2(8)
%IF SUBFUNCT=3 %THEN #COOL=DATA2(10)
%IF SUBFUNCT=4 %THEN #COOL=#AIRCOOL:COOLANT=3

* Set coolant taps
#SETCHUCKCOOL=USERVAR1 ; Q201=_check=Chuck Face
#SETTURRETCOOL=USERVAR2 ; Q202=_check=Turret Face
#SETSPINDLECOOL=USERVAR4 ; Q204=_check=Through Spindle
#SETALLCOOL=USERVAR5 ; Q205=_check=All

%CALL=PT_SET_COOLANT_TAPS
%CALL=PT_OUTPUT_COOLANT

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*******************************************************************

%PROCEDURE=PMACRO-716
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-716:%CALL=ENTER_PROCEDURE

%CALL=PT_SET_COOLANT_FLOW
%CALL=PT_SET_COOLANT_TAPS
%CALL=PT_OUTPUT_COOLANT

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*******************************************************************

%PROCEDURE=PT_OUTPUT_COOLANT
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_OUTPUT_COOLANT:%CALL=ENTER_PROCEDURE

#COOLCHANGE=#NEEDTHROUGH ; Count number of changes including through tool coolant
* Check subfunct change
%IF #COOL<>#COOLHOLD %THEN #COOLCHANGE=1

* Check for changes & Blank unchanged values
%IF SPINDLE=SPINDLEID2 @SPIN2
* Main Spindle
* %IF #CHUCKFACE1HOLD=#CHUCKFACE1 %THEN #CHUCKFACE1=#FUNNY %ELSE #COOLCHANGE=#COOLCHANGE+1
%IF #CHUCKFACE1HOLD=#FUNNY %THEN #CHUCKFACE=#CHUCKFACE1OFF:<[#CHUCKFACE=10]>:#CHUCKFACE1HOLD=#CHUCKFACE1OFF
%IF #CHUCKFACE1HOLD<>#CHUCKFACE1 %THEN #COOLCHANGE=#COOLCHANGE+1:#CHUCKFACE=#CHUCKFACE1

* %IF #THROUGHSPIN1HOLD=#THROUGHSPIN1 %THEN #THROUGHSPIN1=#FUNNY %ELSE #COOLCHANGE=#COOLCHANGE+1
%IF #THROUGHSPIN1HOLD=#FUNNY %THEN #THROUGHSPIN=#THROUGHSPIN1OFF:<[#THROUGHSPIN=10]>:#THROUGHSPIN1HOLD=#THROUGHSPIN1OFF
%IF #THROUGHSPIN1HOLD<>#THROUGHSPIN1 %THEN #COOLCHANGE=#COOLCHANGE+1:#THROUGHSPIN=#THROUGHSPIN1
%GOTO @TURR

@SPIN2
* Sub Spindle
* %IF #CHUCKFACE2HOLD=#CHUCKFACE2 %THEN #CHUCKFACE2=#FUNNY %ELSE #COOLCHANGE=#COOLCHANGE+1
%IF #CHUCKFACE2HOLD=#FUNNY %THEN #CHUCKFACE=#CHUCKFACE2OFF:<[#CHUCKFACE=10]>:#CHUCKFACE2HOLD=#CHUCKFACE2OFF
%IF #CHUCKFACE2HOLD<>#CHUCKFACE2 %THEN #COOLCHANGE=#COOLCHANGE+1:#CHUCKFACE=#CHUCKFACE2

* %IF #THROUGHSPIN2HOLD=#THROUGHSPIN2 %THEN #THROUGHSPIN2=#FUNNY %ELSE #COOLCHANGE=#COOLCHANGE+1
%IF #THROUGHSPIN2HOLD=#FUNNY %THEN #THROUGHSPIN=#THROUGHSPIN2OFF:<[#THROUGHSPIN=10]>:#THROUGHSPIN2HOLD=#THROUGHSPIN2OFF
%IF #THROUGHSPIN2HOLD<>#THROUGHSPIN2 %THEN #COOLCHANGE=#COOLCHANGE+1:#THROUGHSPIN=#THROUGHSPIN2

@TURR
%IF TURRET=1 @LWRFACE
* Upper Turret
* %IF #TURRETFACE1HOLD=#TURRETFACE1 %THEN #TURRETFACE1=#FUNNY %ELSE #COOLCHANGE=#COOLCHANGE+1
%IF #TURRETFACE1HOLD=#FUNNY %THEN #TURRETFACE=#TURRETFACE1OFF:<[#TURRETFACE=10]>:#TURRETFACE1HOLD=#TURRETFACE1OFF
%IF #TURRETFACE1HOLD<>#TURRETFACE1 %THEN #COOLCHANGE=#COOLCHANGE+1:#TURRETFACE=#TURRETFACE1
%GOTO @OUTPUT

@LWRFACE
* Lower Turret
* %IF #TURRETFACE2HOLD=#TURRETFACE2 %THEN #TURRETFACE2=#FUNNY %ELSE #COOLCHANGE=#COOLCHANGE+1
%IF #TURRETFACE2HOLD=#FUNNY %THEN #TURRETFACE=#TURRETFACE2OFF:<[#TURRETFACE=10]>:#TURRETFACE2HOLD=#TURRETFACE2OFF
%IF #TURRETFACE2HOLD<>#TURRETFACE2 %THEN #COOLCHANGE=#COOLCHANGE+1:#TURRETFACE=#TURRETFACE2

@OUTPUT
%IF #COOLCHANGE=0 @END

%CALL=CODECON_COOLANT

*Save previous settings
%IF #CHUCKFACE1<>#FUNNY %THEN #CHUCKFACE1HOLD=#CHUCKFACE1
%IF #THROUGHSPIN1<>#FUNNY %THEN #THROUGHSPIN1HOLD=#THROUGHSPIN1
%IF #CHUCKFACE2<>#FUNNY %THEN #CHUCKFACE2HOLD=#CHUCKFACE2
%IF #THROUGHSPIN2<>#FUNNY %THEN #THROUGHSPIN2HOLD=#THROUGHSPIN2
%IF #TURRETFACE1<>#FUNNY %THEN #TURRETFACE1HOLD=#TURRETFACE1
%IF #TURRETFACE2<>#FUNNY %THEN #TURRETFACE2HOLD=#TURRETFACE2

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*******************************************************************

%PROCEDURE=PT_SET_COOLANT_FLOW
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_COOLANT_FLOW:%CALL=ENTER_PROCEDURE

* Coolant options
%IF COOLANT=2 %THEN #COOL=DATA2(9)     ; Mist
%IF COOLANT=1 %THEN #COOL=DATA2(8)     ; Flood
%IF COOLANT=3 %THEN #COOL=#AIRCOOL1     ; Air
%IF #AUTOCOOL=1 @SKIP1
%IF COOLANT=0 %THEN #COOL=DATA2(10)    ; Off
@SKIP1

%IF #SPINDLE=SPINDLEID1 @TAPCODES
* Subspindle
%IF COOLANT=2 %THEN #COOL=DATA6(9)     ; Mist
%IF COOLANT=1 %THEN #COOL=DATA6(8)     ; Flood
%IF COOLANT=3 %THEN #COOL=#AIRCOOL2     ; Air
%IF #AUTOCOOL=1 @SKIP2
%IF COOLANT=0 %THEN #COOL=DATA6(10)    ; Off
@SKIP2

@TAPCODES
%IF #AUTOCOOL=0 @TAPCODES2
* AUTOCOOL - Override Edgecam tap settings
%IF #AUTOCHUCKFACE=1 %THEN COOLANTCHUCK=1
%IF #AUTOTURRET=1 %THEN COOLANTTURRET=1
%IF #AUTOSPINDLE=1 %THEN COOLANTSPINDLE=1

@TAPCODES2
#SETCHUCKCOOL=COOLANTCHUCK ; Chuck Face
#SETTURRETCOOL=COOLANTTURRET ; Turret Face
#SETSPINDLECOOL=COOLANTSPINDLE ; Through Spindle
#SETALLCOOL=COOLANTCHUCK*COOLANTTURRET  ; All
#SETALLCOOL=#SETALLCOOL*COOLANTSPINDLE ; All
%GOTO @END

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*******************************************************************

%PROCEDURE=PT_SET_COOLANT_TAPS
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_COOLANT_TAPS:%CALL=ENTER_PROCEDURE

* Check for ALL setting
%IF #SETALLCOOL=0 @INDIVIDUAL

@ALL
%IF #SPINDLE=SPINDLEID2 @SPIN2A
*<Spin1>
#CHUCKFACE1=#CHUCKFACE1ON
#THROUGHSPIN1=#THROUGHSPIN1ON
%IF COOLANT=3 %THEN #CHUCKFACE1=#CHUCKFACE1AIR
%GOTO @TURRET

@SPIN2A
*<Spin2>
#CHUCKFACE2=#CHUCKFACE2ON
#THROUGHSPIN2=#THROUGHSPIN2ON
%IF COOLANT=3 %THEN #CHUCKFACE2=#CHUCKFACE2AIR

@TURRET
%IF TURRET=1 @TURRET2A
*<Turret 1>
#TURRETFACE1=#TURRETFACE1ON
%IF COOLANT=3 %THEN #TURRETFACE1=#TURRETFACE1AIR
%GOTO @END

@TURRET2A
*<Turret 2>
#TURRETFACE2=#TURRETFACE2ON
%IF COOLANT=3 %THEN #TURRETFACE2=#TURRETFACE2AIR
%GOTO @END

@INDIVIDUAL
* Check Coolant tap settings
*
*<Individual>
%IF #SPINDLE=SPINDLEID2 @SPIN2
*<Spin1>
%IF #SETCHUCKCOOL=0 %THEN #CHUCKFACE1=#CHUCKFACE1OFF:%GOTO @NOTCHUCK1
#CHUCKFACE1=#CHUCKFACE1ON
%IF COOLANT=3 %THEN #CHUCKFACE1=#CHUCKFACE1AIR

@NOTCHUCK1
%IF #SETSPINDLECOOL=1 %THEN #THROUGHSPIN1=#THROUGHSPIN1ON %ELSE #THROUGHSPIN1=#THROUGHSPIN1OFF
%GOTO @TURRETA

@SPIN2
*<Spin2>
%IF #SETCHUCKCOOL=0 %THEN #CHUCKFACE2=#CHUCKFACE2OFF:%GOTO @NOTCHUCK2
#CHUCKFACE2=#CHUCKFACE2ON
%IF COOLANT=3 %THEN #CHUCKFACE2=#CHUCKFACE2AIR

@NOTCHUCK2
%IF #SETSPINDLECOOL=1 %THEN #THROUGHSPIN2=#THROUGHSPIN2ON %ELSE #THROUGHSPIN2=#THROUGHSPIN2OFF

@TURRETA
%IF TURRET=1 @TURRET2
*<Turret 1>
%IF #SETTURRETCOOL=0 %THEN #TURRETFACE1=#TURRETFACE1OFF:%GOTO @END
#TURRETFACE1=#TURRETFACE1ON
%IF COOLANT=3 %THEN #TURRETFACE1=#TURRETFACE1AIR
%GOTO @END

@TURRET2
*<Turret 2>
%IF #SETTURRETCOOL=0 %THEN #TURRETFACE2=#TURRETFACE2OFF:%GOTO @END
#TURRETFACE2=#TURRETFACE2ON
%IF COOLANT=3 %THEN #TURRETFACE2=#TURRETFACE2AIR

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM





%PROCEDURE=PMACRO-117
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-117:%CALL=ENTER_PROCEDURE
* Chuck Pressure
%IF #SPINDLE=SPINDLEID1 @MAIN

* Second Spindle
%IF SUBFUNCT=1 %THEN #MCODE=DATA6(18)
%IF SUBFUNCT=2 %THEN #MCODE=DATA6(19)
%GOTO @GO

* Main Spindle
@MAIN
%IF SUBFUNCT=1 %THEN #MCODE=DATA2(18)
%IF SUBFUNCT=2 %THEN #MCODE=DATA2(19)

@GO
%CALL=CODECON_CHUCK-PRESSURE

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Macro = 106 _____
;

%PROCEDURE=PMACRO-106
* Processing logic called by macro 106, Exact Stop
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-106:%CALL=ENTER_PROCEDURE

%IF #EXACTMODE=1 @MODAL
* Single shot, G code set in linear move
#EXACTSTOP=SUBFUNCT	;	If On then G09 will be output in Feed Macro instead of FeedGcode
%IF SUBFUNCT=2 %THEN %ALWAYS-OUTPUT=#GCODE
%IF SUBFUNCT=1 %THEN %OUTPUT-IF-CHANGED=#GCODE
%GOTO @CALL

@MODAL
* Mode setting
#EXACTSTOP=1  ; Suppress G09 on linear blocks
%IF SUBFUNCT=2 %THEN #EXACTGCODE=DATA1(9)   ; Mode ON
%IF SUBFUNCT=1 %THEN #EXACTGCODE=DATA1(10) ; Mode OFF

@CALL
%CALL=CODECON_EXACT-STOP

@END
*
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;___________________________________________________________ Macro = 252 _____
;

%PROCEDURE=PMACRO-252
* Spindle Control
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-252:%CALL=ENTER_PROCEDURE

#CSS=CSS

* Direction <Direction= [DIRECTION=23]>



* Set main Conditions
#SPINSELECT=#MAINDRIVENCODE



@TURN


@MAIN
*  <252 Main>
#SPINDLECODE=1
#SPINSELECT=#MAINSPINDLECODE

%IF USERVAR2<2 %THEN #WORKGCODE=#MAINDATUMCODE


%IF DIRECTION=1 %THEN #DIRECTION=DATA2(6):%GOTO @CONTINUE ; Stop
%IF DIRECTION=2 %THEN #DIRECTION=DATA2(4):%GOTO @CONTINUE ; Fwd
%IF DIRECTION=3 %THEN #DIRECTION=DATA2(5):%GOTO @CONTINUE ; Rev
%IF DIRECTION=4 @MAINDIR4
%IF DIRECTION=5 @MAINDIR5
%GOTO @CONTINUE

@MAINDIR4
%IF COOLANT<>1 %THEN #DIRECTION=DATA2(4):%GOTO @CONTINUE
#TEMP=DATA2(14)
#COOL=#FUNNY
%IF #TEMP<>-1 %THEN #DIRECTION=DATA2(14):%GOTO @CONTINUE
#DIRECTION=DATA2(4):#COOL=DATA2(8) ; Fwd Cool
%GOTO @CONTINUE

@MAINDIR5
%IF COOLANT<>1 %THEN #DIRECTION=DATA2(5):%GOTO @CONTINUE
#TEMP=DATA2(15)
#COOL=#FUNNY
%IF #TEMP<>-1 %THEN #DIRECTION=DATA2(15):%GOTO @CONTINUE
#DIRECTION=DATA2(5):#COOL=DATA2(8) ; Fwd Cool


@CONTINUE
%IF GEAR=0 @MRPM
#GEAR=GEAR-1
*
@MRPM
*<CSS= [CSS=23]>
%IF #CSS=1 @CSS
* Not CSS
#CSSGCODE=DATA1(44)
%GOTO @CALL
*
@CSS
#CSSGCODE=DATA1(45)
* Check for FPM Conversion
%IF #FTYPETURN=2 %THEN $WARNING="WARNING : Constant surface speed active with FPM conversion":%CALL=CODECON_WARNING

@CALL
%CALL=PT_SPINDLE
* Call code constructor if not a tool change
%IF #MACRO=252 %THEN %CALL=CODECON_SPINDLE_CONTROL

* Set Coolant Taps and output for SPINDLE instruction
%IF #MACRO=252 %THEN %CALL=PMACRO-716 ; 2908

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;___________________________________________________________ Macro = 256 _____
;

%PROCEDURE=PMACRO-256
* Bar Feed
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-256:%CALL=ENTER_PROCEDURE

%IF DWELL=#FUNNY %THEN DWELL=0

* Save existing feed and speed values
#TMP1=#SPEED
#TMP2=#FEED
#TMP3=#HCODE

* Set bar feed parameters
#SPEED=SPEED
#FEED=FEED
#HCODE=TOOLOFFSET

*Approach - Use Rapid call(s)
#XMOVE=XAPPROACH
#ZMOVE=ZAPPROACH
#XMOVEmode0=#XMOVE*#DIAM ; IndexG200 only
#YMOVEmode0=#FUNNY ; IndexG200 only
#ZMOVEmode0=#ZMOVE ; IndexG200 only
* %IF TURRET=1 %THEN #XMOVE=#XMOVE*#X2REVERSE

%IF STRATEGY=3 @SECOND ; Direct Approach
%IF STRATEGY=1 %THEN #XMOVE=#FUNNY:#XMOVEmode0=#FUNNY ; Z First
%IF STRATEGY=2 %THEN #ZMOVE=#FUNNY:#ZMOVEmode0=#FUNNY ; X First
%CALL=PT_OUTPUT_RAPID

#XMOVE=XAPPROACH
#ZMOVE=ZAPPROACH
#XMOVEmode0=#XMOVE*#DIAM ; IndexG200 only
#YMOVEmode0=#FUNNY ; IndexG200 only
#ZMOVEmode0=#ZMOVE ; IndexG200 only

@SECOND
%CALL=PT_OUTPUT_RAPID
*
*Bar Feed
%CALL=CODECON_BAR_FEED

*Re-instate feed and speed etc.
#FEED=#TMP2
#SPEED=#TMP1
#HCODE=#TMP3

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM




;
;___________________________________________________________ Macro = 673 _____
;

%PROCEDURE=PMACRO-673
* Turret Park
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-673:%CALL=ENTER_PROCEDURE

* <Input vars>
* <TOOL [XTOOL=0][YTOOL=1][ZTOOL=2] - Tool change turret centre wrt machine datum>
* <Park [XPARK=0][YPARK=1][ZPARK=2] - Parking tool tip wrt machine datum>
* <Move [XMOVE=0][YMOVE=1][ZMOVE=2] - Parking tool tip wrt current CPL>
* <Turret Centre [XPARKCENTRE=0][YPARKCENTRE=1][ZPARKCENTRE=2]>
* <Keep [#XKEEP=0][#YKEEP=1][#ZKEEP=2]>
* < ** >
* Token vars
* #XPARK etc     - Park Position MC Coordinates
* #XTURRETPK etc - Park Turret Datum
* #XPARKINC etc  - Incremental - Toolchange to Park


#SAVE1=XMOVE ; Save park move values
#SAVE2=ZMOVE

%IF #ATREFPT=1 @BAXIS ; Already at ToolChange
* Move to TC ordering, X First
FIELD1=0
FIELD2=0
FIELD3=0
FIELD4=1

%CALL=PT_SET_TOOLCHANGE_MOVE


@TURN
#MACRO=41 ; For Home/TC decision
%CALL=PMACRO-41

@BAXIS
#MACRO=673 ; Reset
XMOVE=#SAVE1 ; Reset
ZMOVE=#SAVE2

@BSKIP
* Initialise position
#XKEEP=XCPL
#YKEEP=YCPL
#ZKEEP=ZCPL
* Upper turret
#XKEEP=#XKEEP*#ABSDIAM
#XMOVE=#XKEEP*#XREVERSE
#YMOVE=#YKEEP*#YREVERSE
#ZMOVE=#ZKEEP*#ZREVERSE
<[#XMOVE=10][#YMOVE=10][#ZMOVE=10]> ; 2603
* initialise X positions at Tool Change for modality
* Get this Toolchange coordinate
#XFIXED=XTOOL:#YFIXED=YTOOL:#ZFIXED=ZTOOL

@SET2
#XPARK=#XMOVE:<[#XPARK=10]>
#XTPARK=#XFIXED:<[#XTPARK=10]>

* Set park position variables
#XPARK=XPARK*#DIAM ; MC coords
#YPARK=YPARK*#YREVERSE ; MC coords
#ZPARK=ZPARK*#ZREVERSE ; MC coords
$PARKPOS=$UPPERMAIN
%IF SUBFUNCT=2 %THEN $PARKPOS=$UPPERSUB

#XTPARK=XPARKCENTRE
#YTPARK=YPARKCENTRE
#ZTPARK=ZPARKCENTRE

* Incremental vars
#XPARKINC=#XTPARK-#XFIXED:#XPARKINC=#XPARKINC*#DIAM
#YPARKINC=#YTPARK-#YFIXED:#YPARKINC=#YPARKINC*#YREVERSE
#ZPARKINC=#ZTPARK-#ZFIXED:#ZPARKINC=#ZPARKINC*#ZREVERSE

*
@GO
#XMOVE=XMOVE*#DIAM
#YMOVE=YMOVE*#YREVERSE
#ZMOVE=ZMOVE
#ZMOVE=#ZMOVE*#ZREVERSE

%CALL=CODECON_PARK
#ATREFPT=0 ; Position checking

* Reset Keep values
#XKEEP=XMOVE
%IF YMOVE<>#FUNNY %THEN #YKEEP=YMOVE
#ZKEEP=ZMOVE

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

%PROCEDURE=PMACRO-674
* Turret Un-Park
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-674:%CALL=ENTER_PROCEDURE
%IF #ATREFPT=1 @UNPARK2 ; Already at ToolChange
*
%IF NEXTMACRO=41 @END
%IF NEXTMACRO=191 @END

* Move to TC ordering
FIELD1=0
FIELD2=0
FIELD3=0
FIELD4=0

%CALL=PT_SET_TOOLCHANGE_MOVE

#MACRO=41 ; For Home/TC decision
%CALL=PMACRO-41

@UNPARK
#MACRO=674 ; Reset true value
#ATREFPT=1 ; Position checking
*
@UNPARK2
#XMOVE=XCPL*#DIAM*#XREVERSE                        ; W64644
%IF TURRET=1 %THEN #XMOVE=#XMOVE*#X2REVERSE        ; W64644
#YMOVE=YCPL*#YREVERSE                              ; W64644
#ZMOVE=ZCPL*#ZREVERSE                              ; W64644
<[#XMOVE=10][#YMOVE=10][#ZMOVE=10]> ; initialise   ; W64644

%CALL=CODECON_UNPARK

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
*
*
*
%PROCEDURE=PT_SET_TOOLCHANGE_MOVE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_TOOLCHANGE_MOVE:%CALL=ENTER_PROCEDURE
*
* Set move for Tool Change before Parking move
* Upper main
XMOVE=XMOVE+XTOOL-XPARKCENTRE
ZMOVE=ZMOVE+ZTOOL-ZPARKCENTRE
%IF CAXIS>0 %THEN YMOVE=YMOVE+YTOOL-YPARKCENTRE
*
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*********************************
*
*  template defined macros 4xxx series
*
*********************************


%PROCEDURE=PMACRO-4001
* Swarf Conveyor
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-4001:%CALL=ENTER_PROCEDURE

%OUTPUT-IF-CHANGED=#SWARFMCODE
#SWARFMCODE=DATA2(26)
%IF SUBFUNCT=1 %THEN #SWARFMCODE=DATA2(27)

%CALL=CODECON_SWARF


@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*
*********************************
*
*  General processing procedures
*
*********************************


;                                      
; ENTER_PROCEDURE                  
;                                      
%PROCEDURE=ENTER_PROCEDURE
%IF #PROCTRACE2=0 @END
%IF $SPC="              " %THEN $SPC="               "     ;1
%IF $SPC="             "  %THEN $SPC="              "	   ;2
%IF $SPC="            "   %THEN $SPC="             "	   ;3
%IF $SPC="           "    %THEN $SPC="            "		   ;4
%IF $SPC="          "     %THEN $SPC="           "		   ;5
%IF $SPC="         "      %THEN $SPC="          "		   ;6
%IF $SPC="        "       %THEN $SPC="         "		   ;7
%IF $SPC="       "        %THEN $SPC="        "			   ;8
%IF $SPC="      "         %THEN $SPC="       "			   ;9
%IF $SPC="     "          %THEN $SPC="      "			   ;10
%IF $SPC="    "           %THEN $SPC="     "			   ;11
%IF $SPC="   "            %THEN $SPC="    "				   ;12
%IF $SPC="  "             %THEN $SPC="   "				   ;13
%IF $SPC=" "              %THEN $SPC="  "				   ;14
%IF $SPC=""               %THEN $SPC=" "				   ;15
<* [$SPC][$SPC]{62} [$PROCEDURE]>
@END
%ENDM
;                                      
; EXIT_PROCEDURE                   
;                                      
%PROCEDURE=EXIT_PROCEDURE

%IF #PROCTRACE2=0 @END
<* [$SPC][$SPC]{60} >
%IF $SPC=" "               %THEN $SPC=""	      			;1
%IF $SPC="  "              %THEN $SPC=" "		  			;2
%IF $SPC="   "             %THEN $SPC="  "		  			;3
%IF $SPC="    "            %THEN $SPC="   "		  			;4
%IF $SPC="     "           %THEN $SPC="    "	  			;5
%IF $SPC="      "          %THEN $SPC="     "	  			;6
%IF $SPC="       "         %THEN $SPC="      "	  			;7
%IF $SPC="        "        %THEN $SPC="       "	  			;8
%IF $SPC="         "       %THEN $SPC="        "	  		;9
%IF $SPC="          "      %THEN $SPC="         "			;10
%IF $SPC="           "     %THEN $SPC="          "			;11
%IF $SPC="            "    %THEN $SPC="           "			;12
%IF $SPC="             "   %THEN $SPC="            "		;13
%IF $SPC="              "  %THEN $SPC="             "		;14
%IF $SPC="               " %THEN $SPC="              "		;15
@END
%ENDM


;                                      
; Program Runtime Questions     
;                                      

%PROCEDURE=PT_ASK_PROGVERSION
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ASK_PROGVERSION:%CALL=ENTER_PROCEDURE
* Handle User Input, Token PROGVERSION
* Options - Always Ask (1), Ask if Not Set (2), Never Ask (3), Ask Only Once (4)
%IF #QUESTION<4 @CONTINUE
* Ask Only Once
%IF #GOTPV=0 @ALWAYS
%GOTO @ALREADY_SET

@CONTINUE
%IF #QUESTION=1 @ALWAYS
%IF $PROGVER<>"" @ALREADY_SET
$PROGVER=JOBREV

%IF #QUESTION=3 @ALREADY_SET
%IF $PROGVER<>"" @ALREADY_SET

@ALWAYS
%ASK=Program Version Number=$PROGVER
%IF $PROGVER="" %THEN $PROGVER=JOBREV
#GOTPV=1

@ALREADY_SET
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      

%PROCEDURE=PT_ASK_PROGRAMMER
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ASK_PROGRAMMER:%CALL=ENTER_PROCEDURE
* Handle User Input, Token PROGRAMMER
* Options - Always Ask (1), Ask if Not Set (2), Never Ask (3), Ask Only Once (4)
%IF #QUESTION<4 @CONTINUE
* Ask Only Once
%IF #GOTPR=0 @ALWAYS
%GOTO @ALREADY_SET

@CONTINUE
%IF #QUESTION=1 @ALWAYS
%IF $ID<>"" @ALREADY_SET
$ID=JOBPROG

%IF #QUESTION=3 @ALREADY_SET
%IF $ID<>"" @ALREADY_SET

@ALWAYS
%ASK=Programmer's Name=$ID
%IF $ID="" %THEN $ID=JOBPROG
#GOTPR=1

@ALREADY_SET
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      

%PROCEDURE=PT_ASK_PROGDESC
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ASK_PROGDESCR:%CALL=ENTER_PROCEDURE
* Handle User Input, Token PROGDESCR
* Options - Always Ask (1), Ask if Not Set (2), Never Ask (3), Ask Only Once (4)
%IF #QUESTION<4 @CONTINUE
* Ask Only Once
%IF #GOTDE=0 @ALWAYS
%GOTO @ALREADY_SET

@CONTINUE
%IF #QUESTION=1 @ALWAYS
%IF $DESCR<>"" @ALREADY_SET
$DESCR=PARTNAME

%IF #QUESTION=3 @ALREADY_SET
%IF $DESCR<>"" @ALREADY_SET

@ALWAYS
%ASK=Program Description=$DESCR
%IF $DESCR="" %THEN $DESCR=PARTNAME
#GOTDE=1

@ALREADY_SET
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      

%PROCEDURE=PT_ASK_PROGID
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ASK_PROGID:%CALL=ENTER_PROCEDURE
* Handle User Input, Token PROGID
* Options - Always Ask (1), Ask if Not Set (2), Never Ask (3), Ask Only Once (4)
*
%IF #QUESTION<4 @CONTINUE
* Ask Only Once
%IF #GOTID=0 @ASK
%GOTO @ALREADY_SET
*
@CONTINUE
%IF #QUESTION=1 @ASK  ; Always ask
%IF #QUESTION=3 @DEFAULTS ; Never ask
*
* Ask if not set #QUESTION=2
%IF #PROGID<>#FUNNY @ALREADY_SET
*
@DEFAULTS
%IF TURRET=1 @LWR

%IF #PROGID=#FUNNY %THEN #PROGID=JOBPROGID1 ; First upper turret
%GOTO @ASK ; 3101

@LWR
%IF #PROGID=#FUNNY %THEN #PROGID=JOBPROGID2 ; First lower turret

@ASK
%IF #QUESTION=3 @ALREADY_SET ; Never ask
%IF #PROGID<>#FUNNY @ALREADY_SET ; Ask if not set
* Ask moved to procedure to handle multiple turrets
%CALL=PT_ASK_ID
#GOTID=1

@ALREADY_SET
%IF #PROGID=#FUNNY %THEN #PROGID=1
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_ASK_ID         
;                                      

%PROCEDURE=PT_ASK_ID
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ASK_ID:%CALL=ENTER_PROCEDURE
* Better handling of ID question for multiple turrets

* Processing upper1
%ASK=Enter program ID number for upper turret=#PROGID
%GOTO @END


@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      
; Procedure = PT_INDEX_TURRET      
;                                      
%PROCEDURE=PT_INDEX_TURRET
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_INDEX_TURRET:%CALL=ENTER_PROCEDURE

* 	      User explicitly specified index direction
%IF #MANUALIDX=#TRUE %THEN #MANUALIDX=#FALSE:%GOTO @END
;
*         On first tool always index forward
%IF SUBFUNCT=1 %THEN #INDEXTURDIR=DATA2(20):%GOTO @END


*         shortest will always be 1 less than 1/2 the number of tools in the turret
#TMP2=#MAXTOOLS/2
;
;         load previous tool
#TMP=#TCFUNCT-1
%LOAD=#TMP
#TMP=POSITION
;
;         Reload current tool
%LOAD=#TCFUNCT
;
;         assume NEXT > LAST
#TMP1=POSITION-#TMP
;
;         if NEXT < LAST
%IF #TMP1<0 @CHECKREVERSE
*			Index Clw or Cclw depending upon the number of stations between current and next tools
%IF #TMP1<#TMP2 %THEN #INDEXTURDIR=DATA2(20) %ELSE #INDEXTURDIR=DATA2(21)

%GOTO @END

@CHECKREVERSE
#TMP1=ABS(#TMP1)
%IF #TMP1<#TMP2 %THEN #INDEXTURDIR=DATA2(21) %ELSE #INDEXTURDIR=DATA2(20)

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
*
;                                
; Procedure = PT_RAPID_TO_HOME_TOOLCHANGE
;                                
%PROCEDURE=PT_RAPID_TO_HOME_TOOLCHANGE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_RAPID_TO_HOME_TOOLCHANGE:%CALL=ENTER_PROCEDURE
*
* Modified for adaptive templates to have a procedure for first leg
* and a second procedure called by a token for the second leg
*
*	Handles Rapid to Home strategies e.g. Xfirst, Zfirst
*	No automation depending on tool type i.e. User must program Xfirst
*
* Axis Fixed
* FIELD 1 = 1 = X FIXED	(remain at current location	)
* FIELD 3 = 1 = Z FIXED	(	"		"		"		)
*
* Axis Priority
* FIELD 4 = 0 = None
*			1 = XFIRST
*           3 = ZFIRST

* %IF #AUTOCOOL=1 %THEN %CALL=PT_COOL_CANCEL ; Set coolant to OFF

* Check for CRC in use
%IF #CHECKRAPID=0 @MODE
%IF #COMPACTIVE=0 @MODE
$WARNING="Warning - CRC Active in Rapid Move":%CALL=CODECON_WARNING
#COMPACTIVE=0
@MODE
* Set up #HOMEGCODE
#HOMEGCODE=DATA1(82) 									; Default to XZ Simultaneously
%IF #HOMEGCODE=#FUNNY %THEN #HOMEGCODE=DATA1(80)		; If no value for simultaneous then set to X first
*
%IF FIELD1=1 %THEN #HOMEGCODE=DATA1(78)   ; X fixed
%IF FIELD3=1 %THEN #HOMEGCODE=DATA1(79)	  ; Z fixed
%IF FIELD4=1 %THEN #HOMEGCODE=DATA1(80)	  ; X first
%IF FIELD4=3 %THEN #HOMEGCODE=DATA1(81)	  ; Z first
*
#UZERO=0:#VZERO=0:#WZERO=0						; For used with U0 and W0 Tokens
* < [FIELD1=0]  [FIELD3=0]  [FIELD4=0] >
%IF #G92XSET=#FUNNY @NOT_USING_G92_STRATEGY

%IF FIELD1=0 %THEN #XMOVE=#G92XSET		; X not fixed hence move to destination
%IF FIELD3=0 %THEN #ZMOVE=#G92ZSET		; Z not fixed hence move to destination

%GOTO @CONTINUE

@NOT_USING_G92_STRATEGY
*	TMP1 & TMP2 are set as Home (Macro 40) or Toolchange (Macro 41) X&Z coords
*	No method of knowing if U/W or X/Z Tokens being used
%IF FIELD1=0 %THEN #XMOVE=#TMP1	;	X not fixed hence move to destination
%IF FIELD2=0 %THEN #YMOVE=#TMP3
%IF FIELD3=0 %THEN #ZMOVE=#TMP2	;	Z not fixed hence move to destination

%IF FIELD1=1 %THEN #UZERO=#FUNNY	;	Supress X motion when using U/W Tokens
%IF FIELD2=1 %THEN #VZERO=#FUNNY	;	Supress Y motion	"			"
%IF FIELD3=1 %THEN #WZERO=#FUNNY	;	Supress Z motion	"			"

%IF FIELD1=1 %THEN #XMOVE=#FUNNY	;	Supress X motion
%IF FIELD2=1 %THEN #YMOVE=#FUNNY	;	Supress Y motion
%IF FIELD3=1 %THEN #ZMOVE=#FUNNY	;	Supress Z motion

@CONTINUE
*	Store X & Z moves to re-instate after processing move
#TMP1=#XMOVE:#TMP3=#YMOVE:#TMP2=#ZMOVE

* Start of processing loop was here
*
%IF FIELD1=1 %THEN #UZERO=#FUNNY	;	Supress X motion
%IF FIELD2=1 %THEN #VZERO=#FUNNY	;	Supress Y motion
%IF FIELD3=1 %THEN #WZERO=#FUNNY	;	Supress Z motion

%IF FIELD4=0 @OUTPUT_MOVE
%IF #HOMETYPE=0 @OUTPUT_MOVE	; User selected output in single block regardless of XZ first.

*	Suppress non priority axis
%IF FIELD4=3 @Z_FIRST
%IF FIELD4=2 @Y_FIRST

@X_FIRST
*	Suppress YZ first time round then supress X
#ZMOVE=#FUNNY:#WZERO=#FUNNY
#YMOVE=#FUNNY:#VZERO=#FUNNY
%GOTO @OUTPUT_MOVE

@Y_FIRST
*	Suppress XZ first time round then supress X
#ZMOVE=#FUNNY:#WZERO=#FUNNY
#XMOVE=#FUNNY:#UZERO=#FUNNY
%GOTO @OUTPUT_MOVE

@Z_FIRST
*	Suppress XY first time round then supress Z
#XMOVE=#FUNNY:#UZERO=#FUNNY
#YMOVE=#FUNNY:#VZERO=#FUNNY

@OUTPUT_MOVE		;Replace with Code Con call

* Set Fixed positions
#XTOOL=#FUNNY:#ZTOOL=#FUNNY:#XHOME=#FUNNY:#ZHOME=#FUNNY
*
%IF #XMOVE=#FUNNY @SETZ
#XTOOL=#XFIXED*#DIAM
#XHOME=#XFIXED*#DIAM
@SETZ
%IF #ZMOVE=#FUNNY @ABS
#ZTOOL=#ZFIXED*#ZREVERSE
#ZHOME=#ZFIXED*#ZREVERSE
@ABS


* Set ..STOREABS to ensure correct KEEP values
%IF #XMOVE<>#FUNNY %THEN #XSTOREABS=#XMOVE
%IF #YMOVE<>#FUNNY %THEN #YSTOREABS=#YMOVE
%IF #ZMOVE<>#FUNNY %THEN #ZSTOREABS=#ZMOVE

%CALL=EVALUATE_MOVE

* Set Coolant if automatic
%IF #AUTOCOOL=0 @NOCHANGE
#COOL=DATA2(10)

@NOCHANGE

%IF #MACRO=40 %THEN %CALL=CODECON_RAPID-TO-HOME
%IF #MACRO=41 %THEN %CALL=CODECON_RAPID-TO-TOOLCHANGE



@END
* Reset Coolant if automatic
%IF #AUTOCOOL=0 @NOCHANGE2
#COOL=DATA2(8)

@NOCHANGE2

%IF #XMOVE<>#FUNNY %THEN <[#XMOVE=10]> ; Initialise if active
%IF #YMOVE<>#FUNNY %THEN <[#YMOVE=10]>
%IF #ZMOVE<>#FUNNY %THEN <[#ZMOVE=10]>

#ATREFPT=1 ; Position checking
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=PT_RAPID_TO_HOME_TOOLCHANGE_2
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_RAPID_TO_HOME_TOOLCHANGE_2:%CALL=ENTER_PROCEDURE

%IF #XMOVE<>#FUNNY %THEN <[#XMOVE=10]> ; Initialise if active, after first leg calls
%IF #YMOVE<>#FUNNY %THEN <[#YMOVE=10]>
%IF #ZMOVE<>#FUNNY %THEN <[#ZMOVE=10]>

%IF FIELD4=0 @END		; If priority not set then not needed since 2axis simultaneous move
%IF #HOMETYPE=0 @END	; User selected output in single block regardless of XZ first.

* Called via token to create second leg of move
#XMOVE=#TMP1:#YMOVE=#TMP3:#ZMOVE=#TMP2	;	Retrieve moves
#UZERO=0:#VZERO=0:#WZERO=0

%IF FIELD1=1 %THEN #UZERO=#FUNNY	;	Supress X motion
%IF FIELD2=1 %THEN #VZERO=#FUNNY	;	Supress Y motion
%IF FIELD3=1 %THEN #WZERO=#FUNNY	;	Supress Z motion

%IF FIELD4=0 @OUTPUT_MOVE
%IF #HOMETYPE=0 @OUTPUT_MOVE	; User selected output in single block regardless of XZ first.

*	Suppress non priority axis
%IF FIELD4=3 @Z_FIRST
%IF FIELD4=2 @Y_FIRST

@X_FIRST
*	Suppress X
#XMOVE=#FUNNY:#UZERO=#FUNNY
%GOTO @OUTPUT_MOVE

@Y_FIRST
*	Suppress Y
#YMOVE=#FUNNY:#VZERO=#FUNNY
%GOTO @OUTPUT_MOVE

@Z_FIRST
*	Suppress Z
#ZMOVE=#FUNNY:#WZERO=#FUNNY

@OUTPUT_MOVE

* Set Fixed positions
#XTOOL=#FUNNY:#ZTOOL=#FUNNY:#XHOME=#FUNNY:#ZHOME=#FUNNY
*
%IF #XMOVE=#FUNNY @SETZ
#XTOOL=#XFIXED*#DIAM
#XHOME=#XFIXED*#DIAM
@SETZ
%IF #ZMOVE=#FUNNY @ABS
#ZTOOL=#ZFIXED*#ZREVERSE
#ZHOME=#ZFIXED*#ZREVERSE
@ABS

%CALL=EVALUATE_MOVE

%IF #FORCELEG2=1 @JUMPMOVE
%IF #MOVE=0 @END
@JUMPMOVE

%IF #MACRO=40 %THEN %CALL=CODECON_RAPID-TO-HOME-2
%IF #MACRO=41 %THEN %CALL=CODECON_RAPID-TO-TOOLCHANGE-2



@END

* INITialise tool tip relative to CPL
#XMOVE=XMOVE*#DIAM:<[#XMOVE=10]>:#XKEEP=XMOVE
#YMOVE=YMOVE*#YREVERSE:<[#YMOVE=10]>:#YKEEP=YMOVE
#ZMOVE=ZMOVE*#ZREVERSE:<[#ZMOVE=10]>:#ZKEEP=ZMOVE
*
#ATREFPT=1 ; Position checking

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM



%PROCEDURE=PT_REMOVE_DUPLICATE_TOOLS
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_REMOVE_DUPLICATE_TOOLS:%CALL=ENTER_PROCEDURE

#TMP=1:#TMP2=POSITION

@TOP
%IF #HEADER=#TMP @END
%LOAD=#TMP

%IF #TMP2=POSITION %THEN #TMP1=#TRUE:%GOTO @END
#TMP=#TMP+1
%GOTO @TOP

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM




*
*
*							*******************
*							CSS Values
*							*******************
*
%PROCEDURE=PT_CSS_VALUES
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CSS_VALUES:%CALL=ENTER_PROCEDURE
* Called from token
* Set radius to current value
%IF #XMOVE=#FUNNY @NOSET
%IF #XMOVE=0 @NOSET
#CSSRAD=#XMOVE
@NOSET

*Check for change in status
%IF #CSSGHOLD=#CSSGCODE @END
%IF #CSSGCODE=DATA1(45) @END

*CSS OFF
%IF UNIT=0 %THEN #SPEED=#SPEED*12/(#CSSRAD*#PI) %ELSE #SPEED=#SPEED*1000/(#CSSRAD*#PI)
%IF #NOCSSRAD=1 %THEN #CSSRAD=#FUNNY
%IF #NOCSSSPIN=1 %THEN #SPEED=#FUNNY

@END
#CSSGHOLD=#CSSGCODE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
*
*							*******************
*							Block No. Increment
*							*******************
*
%PROCEDURE=PT_BINC
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_BINC:%CALL=ENTER_PROCEDURE

%IF #USEBNUM=0 @END ; Quick exit
%IF MASK=1 @END

;				Use Block numbers					(#USEBNUM=#TRUE)
;				Block No. Start						(#BNUM)
;				Block Number increment				(#BNUMINC)
;				Only Safe block numbers 			(#ONLYSBNUM=#TRUE)
;
#BNUM=+#BNUMINC
*
* Check top limit, reset if exceeded
%IF #USEBNUM=1 @END ; Reset not required
%IF #BNUM>#USEBNUM %THEN #BNUM=#BNUMSTART
*
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
*
*							******************************
*							Safe Start Block No. Increment
*							******************************
*
%PROCEDURE=PT_SBINC
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SBINC:%CALL=ENTER_PROCEDURE
%IF MASK=1 %THEN #BNUMVAR=0 %ELSE #BNUMVAR=#SBNUMINC

%IF #USESBNUM=0 @END
%IF MASK=1 @END

%IF #SBNUMCOUNT=1 %THEN #SBNUM=#SBNUM+#BNUMVAR
%IF #SBNUMCOUNT=2 %THEN #SBNUM=POSITION
%IF #SBNUMCOUNT=3 %THEN #BNUMVAR=#BNUMINC:#BNUM=#BNUM+#BNUMVAR:#SBNUM=#BNUM
%IF #SBNUMCOUNT=4 %THEN #SBNUM=#SBNUM+#BNUMVAR+POSITION

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=PT_SBINC2
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SBINC:%CALL=ENTER_PROCEDURE

* If SBNUM includes position remove it after output.
%IF #SBNUMCOUNT=4 %THEN #SBNUM=#SBNUM-POSITION

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;______________________________________ HOLD __________
;
%PROCEDURE=HOLD
%IF #PROCTRACE=1 %THEN $PROCEDURE=HOLD:%CALL=ENTER_PROCEDURE

%IF #XMOVE<>#FUNNY %THEN #XHOLD=#XMOVE
%IF #ZMOVE<>#FUNNY %THEN #ZHOLD=#ZMOVE

* Additional processing for rotary holes
%IF #HOLEFLAG<>2 @END         ; 1507
%IF #HOLEPOLAR=1 @END        			; 1607
%IF CAXIS=2 @END          				; 1607
%IF MILLMODE=1 @END           ; 1507
%IF CAXIS=1 @MANGLE                     ; 1607
%IF BMOVE<>0 @END                       ; 1607

@MANGLE                                 ; 1607
;<MANGLE>
* Hole cycles only - set Keep vars in case initialised after Pseudo Polar output
%IF #XMOVE=0 %THEN #CMOVE=90:%GOTO @SKIP7    ; 1607
#CMOVE=#POLARMOVE/#XMOVE                     ; 1507
#CMOVE=ATAN(#CMOVE)                          ; 1507
%IF #CMOVE<0 %THEN #CMOVE=180+#CMOVE         ; 1507
%GOTO @SKIP8 ; 1607

@SKIP7 ;1607
%IF #POLARMOVE=0 %THEN #CMOVE=0:%GOTO @SKIP9  ; Centre line 1607

@SKIP8                                       ; 1507
%IF #POLARMOVE<0 %THEN #CMOVE=180+#CMOVE     ; 1507
%IF #POLARMOVE<>0 @SKIP9                     ; 1507
%IF #XMOVE<0 %THEN #CMOVE=180                ; 1507

@SKIP9                                       ; 1507
CMOVE=#CMOVE 								 ; 1507
%IF SPINDLE=SPINDLEID1 %THEN #C1KEEP=#CMOVE %ELSE #C2KEEP=#CMOVE ; 1507

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;______________________________________ NOMOTION ______
;
%PROCEDURE=NOMOTION
%IF #PROCTRACE=1 %THEN $PROCEDURE=NOMOTION:%CALL=ENTER_PROCEDURE
* No longer used in mainstream processing but retained for ;CODE calls
%CALL=EVALUATE_MOVE

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;_____________________________________ FIND_PRECISION _____
;
%PROCEDURE=FIND_PRECISION
%IF #PROCTRACE=1 %THEN $PROCEDURE=FIND_PRECISION:%CALL=ENTER_PROCEDURE
#PRECISION=1
#TMP=#INCR
@LOOP
%IF #TMP=>1 @END
#PRECISION=#PRECISION*10
#TMP=#TMP*10
%GOTO @LOOP

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;____________________________________ PT_INCREMENTAL_XYZ _____
;
%PROCEDURE=PT_INCREMENTAL_XYZ
* No longer used in template logic
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_INCREMENTAL_XYZ:%CALL=ENTER_PROCEDURE
*		XYZ moves to be incremental
#XSTOREABS=#XMOVE:#ZSTOREABS=#ZMOVE				;	Store absolute current, position
#XMOVE=#XMOVE-#XHOLD:#ZMOVE=#ZMOVE-#ZHOLD		;	Calc incremental move
%IF #XMOVE=0 %THEN #XMOVE=#FUNNY				;	Supress zero X move
%IF #ZMOVE=0 %THEN #ZMOVE=#FUNNY				;	Supress zero X move
%CANCEL=#XMOVE,#ZMOVE							;	Nescessary else incremental motion will be suppressed e.g.  X10, X10 (drilling)

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;______________________________________ PT_COMPENSATE_TLO _____
;
%PROCEDURE=PT_COMPENSATE_TLO
* No longer used in template logic
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_COMPENSATE_TLO:%CALL=ENTER_PROCEDURE

#XMOVE=#XMOVE+(#TOOLXSET*#DIAM)
#ZMOVE=#ZMOVE+(#TOOLZSET*#ZREVERSE)
%IF #ARCTYPE<>4 @SKIP
#IVALUE=#IVALUE+(#TOOLXSET*#DIAM)
#KVALUE=#KVALUE+(#TOOLZSET*#ZREVERSE)
@SKIP

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ PT_CALC_VECTOR_DISTANCE _____
;
%PROCEDURE=PT_CALC_VECTOR_DISTANCE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CALC_VECTOR_DISTANCE:%CALL=ENTER_PROCEDURE
*************************************************************************************
*	Purpose	:	Calculate vector distance from current to next coordinate			*
*				Use to determine if rapid move should be converted to feedrate move	*
*************************************************************************************
*	XZ distance
#XTEMP=#XKEEP*#INVDIAM ; #XKEEP may be diametral
#XTEMP=#XMOVE-#XTEMP
#XTEMP=#XTEMP*#XTEMP
#ZTEMP=#ZMOVE-#ZKEEP
#ZTEMP=#ZTEMP*#ZTEMP

#TMP=#XTEMP+#ZTEMP

#TMP=SQR(#TMP)

%IF #PROCTRACE=0 @END
<* Calculated Rapid Distance is [#TMP=13]>
%CALL=EXIT_PROCEDURE
@END
%ENDM
;
;___________________________________________________________ SIMPLE_TURN_SBLOCK _____
;
%PROCEDURE=SIMPLE_TURN_SBLOCK
%IF #PROCTRACE=1 %THEN $PROCEDURE=SIMPLE_TURN_SBLOCK:%CALL=ENTER_PROCEDURE
* This procedure will break the cycle into a series of single passes.

%CANCEL=#DEPTH


#XMOVE=XEND:#ZMOVE=ZEND
%IF SUBFUNCT=1 @XCUT
%IF SUBFUNCT=3 @XCUT
%IF SUBFUNCT=5 @XCUT
%IF SUBFUNCT=7 @XCUT
%GOTO @ZCUT


@XCUT
#TMP=FIELD8-XEND;<* DIST = [#TMP=0]>
#TMP=ABS(#TMP):#TMP=#TMP/DEPTH
#CUTCOUNT=#TMP+.99999:#CUTCOUNT=INT(#CUTCOUNT);<* No. OF CUTS = [#CUTCOUNT=0]>
#TMP1=FIELD8-XEND:#TMP1=#TMP1/#CUTCOUNT;<* ADJUSTED DEPTH = [#TMP1=0]>
%IF FIELD1=#FUNNY %THEN #DEPTH=#TMP1 %ELSE #DEPTH=DEPTH
#DEPTH=ABS(#DEPTH)
%IF SUBFUNCT=3 %THEN #DEPTH=#DEPTH*-1
%IF SUBFUNCT=5 %THEN #DEPTH=#DEPTH*-1
%IF TURRET=1 %THEN #DEPTH=#DEPTH*-1 ; Change cut direction for lower turret

#TMP1=#DEPTH ; Hold onto signed value of #DEPTH
#DEPTH=ABS(#DEPTH)
#TMP2=FIELD8
#LOOP=0

@LOOPX
#LOOP=#LOOP+1
#TMP2=#TMP2-#TMP1
%IF #LOOP=#CUTCOUNT %THEN #TMP2=XEND

#XMOVE=#TMP2*#DIAM:#ZMOVE=ZEND*#ZREVERSE
*%IF #TLOCOMP=#TRUE %THEN %CALL=PT_COMPENSATE_TLO
*%IF #INCRXYZ=#TRUE %THEN %CALL=PT_INCREMENTAL_XYZ
%CALL=CODECON_SIMPLE-TURN

%IF #LOOP<#CUTCOUNT @LOOPX
%GOTO @END


@ZCUT
#TMP=FIELD7-ZEND;<* DIST = [#TMP=2]>
#TMP=ABS(#TMP):#TMP=#TMP/DEPTH
#CUTCOUNT=#TMP+.99999:#CUTCOUNT=INT(#CUTCOUNT);<* No. OF CUTS = [#CUTCOUNT=0]>
#TMP1=FIELD7-ZEND:#TMP1=#TMP1/#CUTCOUNT;<* ADJUSTED DEPTH = [#TMP1=0]>
%IF FIELD1=#FUNNY %THEN #DEPTH=#TMP1 %ELSE #DEPTH=DEPTH
#DEPTH=ABS(#DEPTH)
%IF SUBFUNCT=2 %THEN #DEPTH=#DEPTH*-1
%IF SUBFUNCT=8 %THEN #DEPTH=#DEPTH*-1

*<* DEPTH USED = [#DEPTH=0]>

#TMP1=#DEPTH
#DEPTH=ABS(#DEPTH)
#TMP2=FIELD7
#LOOP=0

@LOOPZ
#LOOP=#LOOP+1
#TMP2=#TMP2-#TMP1
%IF #LOOP=#CUTCOUNT %THEN #TMP2=ZEND

#XMOVE=XEND*#DIAM:#ZMOVE=#TMP2*#ZREVERSE
*%IF #TLOCOMP=#TRUE %THEN %CALL=PT_COMPENSATE_TLO
*%IF #INCRXYZ=#TRUE %THEN %CALL=PT_INCREMENTAL_XYZ
%CALL=CODECON_SIMPLE-TURN

%IF #LOOP<#CUTCOUNT @LOOPZ

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ CYCLSUB_LINEAR _____
;
%PROCEDURE=CYCLSUB_LINEAR
%IF #PROCTRACE=0 @NOTRACE
********************************************************
$PROCEDURE=CYCLSUB_LINEAR:%CALL=ENTER_PROCEDURE
%IF #TRENDS=0 @NOTRACE
* Output position in CAM coordinates
#TRZ=XPOINT(#LOOP)
#TRX=YPOINT(#LOOP)
<* CAM Coordinates X[#TRX=13]  Z[#TRZ=13]>
@NOTRACE
********************************************************
#ZMOVE=XPOINT(#LOOP):#XMOVE=YPOINT(#LOOP):#TMP=#XMOVE
%IF MASK=0 %THEN FEED=CYCLFEED(#LOOP)
%IF MASK=0 %THEN SPEED=CYCLSPEED(#LOOP)
#GCODE=DATA1(2)
%IF #LOOP<LAST %THEN %CALL=DIVERT_CYCLSUB_FEED:%GOTO @END ; Normal block processing


******************************************************** Last cycle block
* Set Comp Off if needed
%IF #COMPON=1 %THEN #COMPGCODE=DATA1(85)
#BNUMTEMP=#BNUM
*
* #ENDSTYLE 0/1/2 No / Mv Start in Cycle / Mv Start after cycle
* #CYCENDMOVE  - Clearance moves wanted
* #CYCENDSKIP  - Not needed, already there
* #TEMPENDMOVE - Setting for this cycle

%IF #FORCEEND=1 %THEN %CANCEL=#XMOVE,#ZMOVE,#UMOVE,#WMOVE ; Force coordinates 1802
#TEMPENDMOVE=0
%IF #ENDSTYLE>0 %THEN #TEMPENDMOVE=1 ; Safe return to start
%IF #CYCENDMOVE=1 %THEN #TEMPENDMOVE=1
%IF #CYCENDSKIP=1 %THEN #TEMPENDMOVE=0
%IF #TEMPENDMOVE=0 @FIN2

* Optional clearance move at the end of a turn cycle
* Avoid LAST if Co-linear
%IF #XCYCSTART=#FUNNY @FACE
* <Turn>
%IF #ZMOVE=#ZHOLD @JUMP
%GOTO @FEED
@FACE
* <Face>
%IF #XMOVE=#XHOLD @JUMP
@FEED
* Suspend block number & CRC
%IF #USEBNUM=0 %THEN #BNUM=#BNUM-#BNUMINC
#COMPGCODE=#COMPGCODEHOLD

%CALL=DIVERT_CYCLSUB_FEED ; Output last normal block if needed
* Reset block number & CRC
%IF #USEBNUM=0 %THEN #BNUM=#BNUMTEMP
%IF #COMPON=1 %THEN #COMPGCODE=DATA1(85)
@JUMP

%IF #XCYCSTART<>#FUNNY %THEN #XMOVE=#XCYCSTART:%GOTO @DOZED  ; Set to cycle start for clearance move    1102
#XMOVE=#XSTOREABS/#ABSDIAM   ;  1702  Modified to suit X reversal in Turn 4cy Mori
*
@DOZED
%IF #ZCYCSTART<>#FUNNY %THEN #ZMOVE=#ZCYCSTART %ELSE #ZMOVE=#ZSTOREABS ; 1202
*
@FIN2
%IF FIELD12=0 @OUTPUT ; No Return to Start
%IF #ENDSTYLE<>1 @OUTPUT  ; Output block with number
* Move to start within cycle blocks
* Suspend block number again
%IF #USEBNUM=0 %THEN #BNUM=#BNUM-#BNUMINC

@OUTPUT
* <Output>
%CALL=DIVERT_CYCLSUB_FEED ; Output last cycle block

%IF #LOOP<LAST @END
%IF #ENDSTYLE=0 %THEN %CALL=CYCLSUB_RESET :%GOTO @END
%IF #ENDSTYLE=2 @END

%IF #USEBNUM=0 %THEN #BNUM=#BNUMTEMP  ; Reset
%CALL=CYCLSUB_RETURN ; Return to start

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ CYCLSUB_ARC _____
;

%PROCEDURE=CYCLSUB_ARC
%IF #PROCTRACE=0 @NOTRACE
********************************************************
$PROCEDURE=CYCLSUB_ARC:%CALL=ENTER_PROCEDURE
@NOTRACE
********************************************************
#LOOP=#LOOP-1
ZSTART=XPOINT(#LOOP):XSTART=YPOINT(#LOOP)   ; arc start
#LOOP=#LOOP+1
ZCENTRE=XPOINT(#LOOP):XCENTRE=YPOINT(#LOOP) ; arc centre
#LOOP=#LOOP+1
ZEND=XPOINT(#LOOP):XEND=YPOINT(#LOOP)       ; arc end
%IF MASK=0 %THEN FEED=CYCLFEED(#LOOP)
%IF MASK=0 %THEN SPEED=CYCLSPEED(#LOOP)
********************************************************
%IF #PROCTRACE=0 @NOTRACE2
%IF #TRENDS=0 @NOTRACE2
* Output position in CAM coordinates
#TRZ=ZSTART
#TRX=XSTART
<* CAM Arc Start X[#TRX=13] Z[#TRZ=13]>
#TRZ=ZCENTRE
#TRX=XCENTRE
<* CAM Arc Centre X[#TRX=13] Z[#TRZ=13]>
#TRZ=ZEND
#TRX=XEND
<* CAM Arc End X[#TRX=13] Z[#TRZ=13] Radius (&Direction) [RADIUS=13]>
@NOTRACE2
********************************************************

%IF RADIUS<0 %THEN #GCODE=DATA1(3) %ELSE #GCODE=DATA1(4)	; Arc Clw or CClw
%CALL=XZ_PLANE
%IF #LOOP=LAST @ENDBLOCKS
%IF #LOOP>LAST @ENDBLOCKS
* Normal block output
%CALL=DIVERT_CYCLSUB_ARC
%GOTO @END

@ENDBLOCKS
#BNUMTEMP=#BNUM
*
* #ENDSTYLE 0/1/2 No / Mv Start in Cycle / Mv Start after cycle
* #CYCENDMOVE  - Clearance moves wanted
* #CYCENDSKIP  - Not needed, already there
* #TEMPENDMOVE - Setting for this cycle

%IF #FORCEEND=1 %THEN %CANCEL=#XMOVE,#ZMOVE ; Force coordinates 1802
#TEMPENDMOVE=0
%IF #ENDSTYLE>0 %THEN #TEMPENDMOVE=1 ; Safe return to start
%IF #CYCENDMOVE=1 %THEN #TEMPENDMOVE=1
%IF #CYCENDSKIP=1 %THEN #TEMPENDMOVE=0
%IF #TEMPENDMOVE=0 @LASTARC

* Optional extra retract move at the end of a turn cycle
* Suspend block number
%IF #USEBNUM=0 %THEN #BNUM=#BNUM-#BNUMINC

@LASTARC
* Output last arc move
%CALL=DIVERT_CYCLSUB_ARC

* Reset block number & CRC
%IF #USEBNUM=0 %THEN #BNUM=#BNUMTEMP
%IF #COMPON=1 %THEN #COMPGCODE=DATA1(85)

%IF #XCYCSTART<>#FUNNY %THEN #XMOVE=#XCYCSTART:%GOTO @DOZED  ; Set to cycle start for clearance move    1102
#XMOVE=#XSTOREABS/#ABSDIAM   ;  1702
*
@DOZED
%IF #ZCYCSTART<>#FUNNY %THEN #ZMOVE=#ZCYCSTART %ELSE #ZMOVE=#ZSTOREABS ; 1202

%IF FIELD12=0 @OUTFEED ; No Return to Start
%IF #ENDSTYLE<>1 @OUTFEED  ; Output block with number
* Move to start within cycle blocks
* Suspend block number again
%IF #USEBNUM=0 %THEN #BNUM=#BNUM-#BNUMINC

@OUTFEED
* Move Clear
%CALL=DIVERT_CYCLSUB_FEED ; Lead out block

%IF #LOOP<LAST @END
%IF #ENDSTYLE=0 %THEN %CALL=CYCLSUB_RESET :%GOTO @END
%IF #ENDSTYLE=2 @END

%IF #USEBNUM=0 %THEN #BNUM=#BNUMTEMP  ; Reset
%CALL=CYCLSUB_RETURN

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ CYCLSUB_RETURN _____
;

%PROCEDURE=CYCLSUB_RETURN
%IF #PROCTRACE=1 %THEN $PROCEDURE=CYCLSUB_RETURN:%CALL=ENTER_PROCEDURE
* Cyclesub finish at cycle start - called when FIELD12=1

%IF FIELD12=0 @END ;No Return to Start

#XMOVE=#XFIELD12
#ZMOVE=#ZFIELD12
* Add move
%CALL=DIVERT_CYCLSUB_RAPID

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM



;
;___________________________________________________________ CYCLSUB_RESET _____
;
%PROCEDURE=CYCLSUB_RESET
%IF #PROCTRACE=1 %THEN $PROCEDURE=CYCLSUB_RESET:%CALL=ENTER_PROCEDURE
* Cyclesub reset to cycle start - called when #ENDSTYLE=0 (ignore)

#XKEEP=#XFIELD12*#ABSDIAM
#ZKEEP=#ZFIELD12

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;___________________________________________________________ Procedure = SET_UP_SHEET _____
;

%PROCEDURE=SET_UP_SHEET
%IF #PROCTRACE=1 %THEN $PROCEDURE=SET_UP_SHEET:%CALL=ENTER_PROCEDURE

#MASKHOLD=MASK  ; 2201
#APPENDHOLD=APPEND ; 1102

%IF #LTSTART=1 %THEN %CALL=PT_CHECK_CONTENT  ; 2201

* #TOOLSHEET	1=Output with Main NC program	2=Output as seperate file	3=None
* #TOOLSHEET2 0=Single setup sheet, 1=Sheet for each active turret

%OUTPUT=STANDARD
SETUPFILES=0
%IF #TOOLSHEET2=1 %THEN SETUPFILES=1
*
%IF #TOOLSHEET=1 @OUTPUT_WITH_NC_CODE
%IF #TOOLSHEET2=0 @APPEND ; 1102
%IF #NUMTOOLS=0 @OUTPUT_WITH_NC_CODE ; 79205 0402

@APPEND ; 1102
APPEND=1:%OUTPUT=$NAME

@OUTPUT_WITH_NC_CODE
%CALL=CODECON_SET-UP-SHEET

%OUTPUT=STANDARD
MASK=#MASKHOLD ; 2201
APPEND=#APPENDHOLD ; 1102
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Procedure = PT_OUTPUT_RAPID _____
;
%PROCEDURE=PT_OUTPUT_RAPID			;	Called for all rapid motion - single code constructor
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_OUTPUT_RAPID:%CALL=ENTER_PROCEDURE

;Reset threading flags if threading has finished
%IF NOCYCLE=0 %THEN #INTHRD=#FALSE:#THREADING=#FALSE:$CYCLE=NOCYCLE

#FEEDMODETEMP=#FEEDMODEGCODE	; Store current feed/rev - feed/min
*
%IF #INTHRD=#FALSE @GENERAL_RAPID_MOVE			;	Not processing %NOCYCLE from Thread
*
%IF #THDSTART=#TRUE @GENERAL_RAPID_MOVE
%IF $CYCLE=G92 @END		;	supress motion if G92
%IF $CYCLE=G76 @END		;	supress motion if G76
*
@GENERAL_RAPID_MOVE
*
* Check move length for conversion before call to Evaluate
%IF #FEEDRAPIDS=1 @CONVERT_TO_FEED
%IF #RAPDIST=0 @MISS_CONVERT_TO_FEED
%CALL=PT_CALC_VECTOR_DISTANCE ; Sets #TMP
%IF #TMP>#RAPDIST @MISS_CONVERT_TO_FEED
*
@CONVERT_TO_FEED
* Convert Rapid to Feed Move
#GCODE=DATA1(2)
#CONVERTEDMOVE=1
#FEEDMODEGCODE=DATA1(46)	;	Feed / Min for high feed move
%CALL=EVALUATE_MOVE
%IF #MOVE=0 @END
%CALL=CODECON_LINEAR-INTERPOLATION
%GOTO @END
*
@MISS_CONVERT_TO_FEED
*
%CALL=EVALUATE_MOVE
%IF #MOVE=0 @END

* Check for CRC in use
%IF #CHECKRAPID=0 @MODE
%IF #COMPACTIVE=0 @MODE
$WARNING="Warning - CRC Active in Rapid Move":%CALL=CODECON_WARNING
#COMPACTIVE=0
@MODE
#GCODE=DATA1(1)

%IF #TOOLCHANGE=1 %THEN %CALL=PT_RAPID_AFTER_TOOLCHANGE:%GOTO @END		; Call if first move after toolchange
*
%CALL=CODECON_RAPID-MOVE
*
@END
#FEEDMODEGCODE=#FEEDMODETEMP	;	Restore feed/rev - feed/min status
#THDSTART=#FALSE
#PASSCNT=1
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;
;___________________________________________________________ Procedure = PT_RAPID_AFTER_TOOLCHANGD _____
;
%PROCEDURE=PT_RAPID_AFTER_TOOLCHANGE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_RAPID_AFTER_TOOLCHANGE:%CALL=ENTER_PROCEDURE

* %IF #FEEDRAPIDS=1 @CONVERT_TO_FEED
* %IF #RAPDIST=0 @MISS_CONVERT_TO_FEED
* %CALL=PT_CALC_VECTOR_DISTANCE ; Sets #TMP
* %IF #TMP>#RAPDIST @MISS_CONVERT_TO_FEED
*
* @CONVERT_TO_FEED
* Convert Rapid to Feed Move
* #GCODE=DATA1(2)
* #FEED=#RAPIDFEEDRATE
* #CONVERTEDMOVE=1
* #FEEDMODETEMP=#FEEDMODEGCODE	; Store current feed/rev - feed/min
* #FEEDMODEGCODE=DATA1(46)	;	Feed / Min for high feed move
* %CALL=PT_CONTROL_FEEDTYPE
* %CALL=CODECON_LINEAR-INTERPOLATION
* #FEEDMODEGCODE=#FEEDMODETEMP	;	Restore feed/rev - feed/min status
* %GOTO @END
*
@MISS_CONVERT_TO_FEED
%CALL=CODECON_RA-AFTER-TOOLCHANGE

@END
#TOOLCHANGE=0


#CANCELCOMP=#TRUE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PT_OUTPUT_FEED _____
;
%PROCEDURE=PT_OUTPUT_FEED				;	Called for all feedrate motion including Longhand threading
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_OUTPUT_FEED:%CALL=ENTER_PROCEDURE
#GCODE=DATA1(2) ;Initialise for use as mode flag later

%IF NOCYCLE=0 %THEN #INTHRD=#FALSE:#THREADING=#FALSE:$CYCLE=NOCYCLE:#THRDFLAG=0

*******************************************************
* Test if Threading
*******************************************************
%IF #INTHRD=#FALSE @EVALUATE
%IF #MACRO=1 @EVALUATE  ; Converted from Rapid
%IF NOCYCLE=0 @EVALUATE ; Diverted from Cycle - Rturn, Groove, Thread etc.
* Threading
%IF $CYCLE=G76 @END ; Thread canned, no output
%IF $CYCLE=G32 @THRDLONG

* Single block threading G92
#GCODE=DATA1(19)
%CALL=PT_THD_BLOCK
%GOTO @END

@THRDLONG
* Longhand Threads
#GCODE=DATA1(18) ;G32 Thread longhand

*******************************************************
@EVALUATE
* Normal move processing, Evaluate move characteristics
*******************************************************
*Set feed unless tapping
%IF #MACRO=10 @NO-FEED-RESET
#FEED=FEED
@NO-FEED-RESET

%CALL=EVALUATE_MOVE
%IF #COMPON=#TRUE %THEN %CALL=CRC_HANDLER
%IF #MOVE=0 @END


%IF #INTHRD=1 @THRDOUT

%CALL=CODECON_LINEAR-INTERPOLATION ;	Standard linear move
%GOTO @END

*******************************************************
@THRDOUT
* longhand threading
*******************************************************
%CALL=CODECON_THREAD-LONGHAND-CYCLE ;G32 Longhand

@END
#PASSCNT=#PASSCNT+1				;	Threading counter for G32 longhand cycle
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = CRC_HANDLER _____
;
%PROCEDURE=CRC_HANDLER
%IF #PROCTRACE=1 %THEN $PROCEDURE=CRC_HANDLER:%CALL=ENTER_PROCEDURE

%IF #THREADMOVE=1 @OUTPUTCOMP			;	Apply cutter comp during first valid thread mill move
%IF #THREADMOVE=2 @LEAD_OUT			;	Cancel cutter comp during last valid thread mill move
%IF #MACRO=187 @END

%IF SUBFUNCT=1 @OUTPUTCOMP

%IF SUBFUNCT=2 %THEN %CALL=PT_LEAD_OUT
%IF #LEADOUTCOUNT=#FUNNY @END
%IF #LEADOUTCOUNT>0 %THEN #LEADOUTCOUNT=#LEADOUTCOUNT-1
%IF #LEADOUTCOUNT=0 @LEAD_OUT

%GOTO @END


@OUTPUTCOMP
%CALL=PT_CHECK_LEAD
%IF $COMPOUTPUT=TRUE @END
#COMPGCODE=#COMPGCODEHOLD
* %IF #AUTOREG=1 %THEN #COMPDCODE1=POSITION+#MAXTOOLS %ELSE #COMPDCODE1=POSITION
#COMPDCODE=#COMPDCODE1
%CALL=CODECON_CUTTER-COMPENSATION
$COMPOUTPUT=TRUE
#LEADOUTCOUNT=#FUNNY
%GOTO @END


@LEAD_OUT
#COMPGCODE=DATA1(85)
%CALL=CODECON_CUTTER-COMPENSATION

$COMPOUTPUT=FALSE
#LEADOUTCOUNT=#FUNNY
#COMPDCODE=#FUNNY

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE

%ENDM

;
;___________________________________________________________ Procedure = PT_CHECK_LEAD _____
;

%PROCEDURE=PT_CHECK_LEAD
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CHECK_LEAD:%CALL=ENTER_PROCEDURE

* #WarnCRC = 0  No warnings
*            1  CRC Warn if Used only
*            2  CRC warn if not 90 only
*            3  Both above warnings

* Check to warn if used
%IF #WARNCRC=1 %THEN $WARNING="Warning - Cutter Radius Compensation has been programmed":%CALL=CODECON_WARNING

* Check for arc move
%IF #WARNCRCARC=0 @LINEAR
%IF #MACRO=53 @ARCMOVE
%IF #MACRO=54 @ARCMOVE
%GOTO @LINEAR

@ARCMOVE
$WARNING="Warning - Cutter Compensation applied on arc move":%CALL=CODECON_WARNING

@LINEAR
%IF #WARNCRC90=0 @END				;	If Code Wizard option to warn not set then miss warning message
%IF FIELD1=#FUNNY @LEAD_NOT_90
%IF FIELD1<>90 @LEAD_NOT_90
%GOTO @END
@LEAD_NOT_90
$WARNING="Warning - Cutter Compensation active - Lead In not 90 degree":%CALL=CODECON_WARNING
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PT_LEAD_IN _____
;

%PROCEDURE=PT_LEAD_OUT
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_LEAD_OUT:%CALL=ENTER_PROCEDURE

*************************************************************
*	Purpose	:	To set number of moves in Lead out sequence	*
*	Called	:	when processing a Feed or Arc move which is	*
*				the first move of the Lead out sequence		*
*				Subfunct=2									*
*															*
*************************************************************
**************************************
*	Lead Out permutations
**************************************
*	Angle + Rad 			= 1 move
*	Length     				= 1 move
*	Length + Angle 			= 1 move
*	Length + Angle + Rad 	= 2 moves
*	All plus one if 90 compensation cancel set i.e. Radius Compensation Factor in MM line
#LEADOUTCOUNT=FIELD12
*%IF FIELD5<>0 %THEN #LEADOUTCOUNT=#LEADOUTCOUNT+1	;	Lead out radius
*%IF FIELD6<>0 %THEN #LEADOUTCOUNT=#LEADOUTCOUNT+1	;	Lead out length

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Procedure = TAP_LONGHAND _____
;
%PROCEDURE=TAP_LONGHAND
%IF #PROCTRACE=1 %THEN $PROCEDURE=TAP_LONGHAND:%CALL=ENTER_PROCEDURE

* %IF #FEEDMODEGCODE=DATA1(47) %THEN #FEED=ZFEED/SPEED  ;	Feed / rev
* %IF #FEEDMODEGCODE=DATA1(46) %THEN #FEED=ZFEED     		;   Feed / min
* #SPEED=SPEED

* Feed to depth
#ZMOVE=ZEND
%CALL=PT_OUTPUT_FEED

* Output Dwell if required
%IF DWELL>0 %THEN %CALL=CODECON_DWELL

* Change spindle direction and Return to Zclear
%CALL=PT_SPINDLE_REVERSE
#ZMOVE=ZCLEAR
%CALL=PT_OUTPUT_FEED

* Put spindle direction back to selected direction
%CANCEL=#DIRECTION
%CALL=PT_SPINDLE_REVERSE

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;
;___________________________________________________________ Procedure = PT_ARC_CENTRE _____
;
%PROCEDURE=PT_ARC_CENTRE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ARC_CENTRE:%CALL=ENTER_PROCEDURE

*	Setvar^#ARCTYPE, determines the method of fixing arc centre
*						Signed Start to Centre	1
*						Signed Centre to start	2
*						Unsigned Start / Centre	3
*						Centre					4
*	Setvar^#USERADS^Use Radius when possible
*						TRUE / FALSE		Sets #OUTPUTRADS=#TRUE as default, re-assigned FALSE if I&J forced by logic e.g. 360 degrees move

%IF #OUTPUTRADS=#TRUE @END	;	Use radius output

#IVALUE=XCENTRE-XSTART:#KVALUE=ZCENTRE-ZSTART  ;	Signed Start to Centre

%IF #ARCTYPE=2 %THEN #IVALUE=-1*#IVALUE:#KVALUE=-1*#KVALUE:%GOTO @ROUND		 ;	Signed Centre to start (reverse of type 1)
%IF #ARCTYPE=3 %THEN #IVALUE=ABS(#IVALUE):#KVALUE=ABS(#KVALUE):%GOTO @ROUND  ;	Unsigned Start / Centre
%IF #ARCTYPE=4 %THEN #IVALUE=XCENTRE:#KVALUE=ZCENTRE*#ZREVERSE		         ;	Absolute Centre

@ROUND
%CALL=PT_ARC_CENTRE_ROUNDING

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = XZ_PLANE _____
;
%PROCEDURE=XZ_PLANE
%IF #PROCTRACE=1 %THEN $PROCEDURE=XZ_PLANE:%CALL=ENTER_PROCEDURE


#XMOVE=XEND
#ZMOVE=ZEND
* #XMOVE=#XMOVE*#DIAM:#ZMOVE=#ZMOVE*#ZREVERSE
#RADIUS=ABS(RADIUS)

%CALL=EVALUATE_MOVE

#PLANEGCODE=DATA1(14)

%CALL=PT_ARC_CENTRE

%IF #COMPON=#TRUE %THEN %CALL=CRC_HANDLER

%IF #USERADS=#FALSE %THEN #RADIUS=#FUNNY %ELSE #IVALUE=#FUNNY:#KVALUE=#FUNNY
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PROFILE_VARIABLES _____
;
%PROCEDURE=PROFILE_VARIABLES
%IF #PROCTRACE=1 %THEN $PROCEDURE=PROFILE_VARIABLES:%CALL=ENTER_PROCEDURE

;
; Called from Profile macro to test input variables
; Lead in / out modifiers will NOT be present in profile definition
; generated from a Roughing cycle.
;
; Macro modifiers :- =5,7,30,31,-21,  (-21 is optional)
;
;

#TMP=FIELD1+FIELD2+FIELD3+FIELD4+FIELD5+FIELD6
%IF #TMP=0 @END

$WARNING="Warning - Lead in and Lead out parameters will not appear in":%CALL=CODECON_WARNING
$WARNING="Warning - profile definition blocks.":%CALL=CODECON_WARNING
$WARNING="Warning - Do not use Lead in/out, or do not use Canned cycle":%CALL=CODECON_WARNING

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Procedure = RT_VARIABLES _____
;
%PROCEDURE=RT_VARIABLES
%IF #PROCTRACE=1 %THEN $PROCEDURE=RT_VARIABLES:%CALL=ENTER_PROCEDURE


;
; Called from Rough turn area clear
; to output the rapid move to cycle start position and
; to test input variables are compatible with canned cycle requested
;
; Macro modifiers :-  =5,7,10,30,31,-21,40,41,   (-21 is optional)
;
; MUST BE MODIFIED TO SUIT PARTICULAR CONTROLLER FUNCTIONALITY !!
;
; < >
; < Canned cycle modifers (Rough Turn or Rough/Offset Profile) :->
; < >
; <    Degression (0=none)    Degr    =[DEGR=13]>
; <    Rough cuts 0/1 (N/Y)   Field11 =[FIELD11=13]>
; <    Billet 0/1/2 (T/D/B)   Field9  =[FIELD9=13]>
; <    Xstart                 Field8  =[FIELD8=13]>
; <    Zstart                 Field7  =[FIELD7=13]>
; <    Finish at 1/0 (S/E)    Field12 =[FIELD12=13]>
; <    Link type 1/2 (R/F)    Field2  =[FIELD2=13]>
; < >
;
* Default Start at current position
* #XMOVE=#XHOLD
* #ZMOVE=#ZHOLD
#ROUGHMACRO=#MACRO
; Move to digitised start position if requested
%IF FIELD9<>1 @SKIP
* <TOOLTYPE=[TOOLTYPE=13]>
* <FIELD5=[FIELD5=13]>
* <XEND= [XEND=0] XSTART= [XSTART=0]>
%IF FIELD5=#FUNNY @NOSAFE
%IF FIELD5=0 @NOSAFE  ; Avoid regression

%IF XFIRST=1 @XFIRST ; Use cycle flag if available
%IF XFIRST=0 @ZFIRST

#THRDINTFLG=0 ; External
%IF XEND<0 @REVTYPE
%IF TOOLTYPE=3 %THEN #THRDINTFLG=1:%GOTO @XFIRST ; Internal
%IF TOOLTYPE=5 %THEN #THRDINTFLG=1:%GOTO @XFIRST ; Internal
%GOTO @ZFIRST

@REVTYPE
* Crossed centreline
%IF TOOLTYPE=7 %THEN #THRDINTFLG=1:%GOTO @XFIRST ; Internal
%GOTO @ZFIRST


@ZFIRST
* <ZFirst>
#XMOVE=#XKEEP*#INVDIAM
%IF FIELD8>#XMOVE @XFIRST ; Override to lift in X
#ZMOVE=FIELD7
%GOTO @LEG_ONE

@XFIRST
* <XFirst>
* <Internal Bottom X then Z>
#ZMOVE=#ZKEEP
#XMOVE=FIELD8

@LEG_ONE
#MACRO=1
#PASSCNT=#FUNNY
%CALL=DIVERT_CYCLSUB_RAPID
#MACRO=#ROUGHMACRO ; Reset
* Safe complete

@NOSAFE
* Digitised position
#XMOVE=FIELD8
#ZMOVE=FIELD7
%GOTO @SKIP_START

@SKIP
* <Skip>
#XMOVE=#XKEEP*#INVDIAM
#ZMOVE=#ZKEEP

@SKIP_START
#XCYCLESTART=XSTART*#DIAM
#ZCYCLESTART=ZSTART*#ZREVERSE

;
; Warning for degression input (default to standard canned cycle)
%IF DEGR=0 @DEGR_OK
%IF DEGR=#FUNNY @DEGR_OK
$WARNING="Warning - Degression not available in controller cycle !":%CALL=CODECON_WARNING
@DEGR_OK
;
; Error if billet digitised

%IF FIELD9=2 %THEN $WARNING="ERROR : Billet consideration not available in controller cycle !":%CALL=CODECON_WARNING
;
; Warning if cycle end position for finish
%IF FIELD12=0 %THEN $WARNING="Warning - Controller will end at cycle start position !":%CALL=CODECON_WARNING
;
; Warning if rough cuts only
%IF FIELD11=1 %THEN $WARNING="Warning - Rough cuts only not available in controller cycle !":%CALL=CODECON_WARNING
;
; Warning if feed link type
%IF FIELD2=2 %THEN $WARNING="Warning - Feed link type not available in controller cycle !":%CALL=CODECON_WARNING
;
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*
*
%PROCEDURE=PT_SET_SPEED
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_SPEED:%CALL=ENTER_PROCEDURE
* Set #SPEED & #RPM including recalculate for CSS condition
* Used for all moves except array base thread mill and hole cycles

#SPEED=SPEED
%IF #TOOLCHANGE=1 %THEN #SPEED=NEXTSPEED
#RPM=#SPEED
%IF #CSS=0 @END

*CSS Mode
#SFM=#SPEED
%CALL=PT_MTH_SFM_TO_RPM  ; Recalculate RPM equivalent

* Check for FPM Conversion
%IF #MACRO=1 @NOWARN
%IF #FTYPETURN=2 %THEN $WARNING="WARNING : Constant surface speed active with FPM conversion":%CALL=CODECON_WARNING
@NOWARN

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


*
%PROCEDURE=PT_MTH_SFM_TO_RPM
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_MTH_SFM_TO_RPM:%CALL=ENTER_PROCEDURE
%IF #CSS=0 @END							;	Constant surface speed not active
*
* Calculate current spindle speed in RPM from Surface Speed
*
#TMP=NEXTXMOVE*2
#TMP=ABS(#TMP)
%IF #MACRO=15 @TCHANGE
%IF #TOOLCHANGE=0 @SETX
%IF #MOVE=4 @TCHANGE ; Z only after TC
*
@SETX
* Not Tool Change
#TMP=#CSSXMOVE*2 ; Diameter for speed calculation

@TCHANGE
%IF #TMP=0 %THEN #RPM=GEARMAXRPM+1:%GOTO @END  ; +1 to trigger warning
*
%IF #SFM=#FUNNY %THEN #SFM=NEXTSPEED
#TMP=#TMP*#PI:#TMP=#CSSFACTOR/#TMP:#RPM=#SFM*#TMP:#RPM=INT(#RPM)
*
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PT_MTH-STOCK_OFFSETS _____
;
%PROCEDURE=PT_MTH_STOCK_OFFSETS
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_MTH_STOCK_OFFSETS:%CALL=ENTER_PROCEDURE


%IF #DIAM<0 %THEN #SIGN=-1 %ELSE #SIGN=1
#OFFSETX=OFFSETX*#SIGN:#OFFSETZ=OFFSETZ

%IF #OFFSETPAR=0 @SFUNCT
%IF OFFSET=0 @SFUNCT
* Set XZ offsets to constant parallel value if necessary
%IF OFFSETX=0 %THEN #OFFSETX=OFFSET*#SIGN
%IF OFFSETZ=0 %THEN #OFFSETZ=OFFSET

@SFUNCT
%IF SUBFUNCT=7 @END		        ;EXTERNAL TURN
%IF SUBFUNCT=4 @END				;EXTERNAL FACE
%IF SUBFUNCT=1 @SWITCHZ         ;EXTERNAL BACK TURN
%IF SUBFUNCT=8 @SWITCHZ         ;EXTERNAL BACK FACE
%IF SUBFUNCT=3 @SWITCHX         ;INTERNAL TURN
%IF SUBFUNCT=6 @SWITCHX         ;INTERNAL FACE
%IF SUBFUNCT=5 @SWITCHBOTH      ;INTERNAL BACK TURN
%IF SUBFUNCT=2 @SWITCHBOTH      ;INTERNAL BACK FACE

@SWITCHX
#OFFSETX=#OFFSETX*-1:%GOTO @END
@SWITCHZ
#OFFSETZ=#OFFSETZ*-1:%GOTO @END
@SWITCHBOTH
#OFFSETX=#OFFSETX*-1:#OFFSETZ=OFFSETZ*-1
@END

#OFFSETXDIAM=#OFFSETX*2			;	X Stock is programmed as a Diameter.
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = SET_TOOLING_DATA _____
;

%PROCEDURE=SET_TOOLING_DATA
%IF #PROCTRACE=1 %THEN $PROCEDURE=SET_TOOLING_DATA:%CALL=ENTER_PROCEDURE
*
#HEADER=1

%IF #TAPEOUTPUT<>0 @STARTLOOP
* reset tooling limits for merged NC
#NUMTOOLS=NUMTOOLS
%IF TURRET=1 %THEN #NUMTOOLS=NUMTOOLS1
%IF #NUMTOOLS<1 @END

@STARTLOOP
%LOAD=#HEADER
*	Remove duplicate tools
%IF #REMOVEDUPLICATES=#FALSE @MISS_REMOVE_DUPLICATES
#TMP1=#FALSE:%CALL=PT_REMOVE_DUPLICATE_TOOLS:%IF #TMP1=#TRUE @SKIP
@MISS_REMOVE_DUPLICATES

%LOAD=#HEADER
%IF TOOLNUM=0 %THEN $TOOLDESCRIPTION=USERDEFINEDSTRING %ELSE $TOOLDESCRIPTION=TOOLDESCRIPTION

%CALL=PT_GET-TNRXZ				;	Obtain and calculate correct sign for Tool Nose Rad X&Z
%CALL=GET_QUADRANT

%CALL=CODECON_SET-TOOLING-DATA

@SKIP

#HEADER=#HEADER+1:%IF #HEADER>#NUMTOOLS @END

%GOTO @STARTLOOP

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PT_SPINDLE _____
;
%PROCEDURE=PT_SPINDLE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SPINDLE:%CALL=ENTER_PROCEDURE

%IF #MACRO=2 @JUMP ; Efficiency
*Look ahead at ToolChange or Rapid
%IF #MACRO=1 %THEN #SPEED=NEXTSPEED:%GOTO @JUMP
%IF #MACRO=44 %THEN #SPEED=NEXTSPEED:%GOTO @JUMP ; Rapid from Y0 move
%IF #MACRO=15 %THEN #SPEED=NEXTSPEED:%GOTO @JUMP
%IF #MACRO=165 %THEN #SPEED=NEXTSPEED:%GOTO @JUMP
%IF #MACRO=252 %THEN #SPEED=NEXTSPEED:%GOTO @JUMP
%IF #MACRO=253 %THEN #SPEED=NEXTSPEED:%GOTO @JUMP
* Setting
%IF #MACRO=122 %THEN #SPEED=SPEED:%GOTO @JUMP
%IF #MACRO<>66 @JUMP
* CX Interpolation
%IF SUBFUNCT=1 %THEN #SPEED=NEXTSPEED ; Rapid
*
@JUMP

* Suppress spindle controls
@CONTROL1
@CONTROL2
*
* Only process if speed changed
* %IF #MACRO=252 @CHECK  ; Spindle control
* %IF #SPEED=#SPEEDHOLD @END    ; Speed unchanged

* Check for running
@CHECK
%IF #SPEED=#SPEEDHOLD @NOTSTOP    ; Speed unchanged, check gear
%IF #DIRECTION<>#TMP @NOTSTOP
* Spindle Stop
%IF #GEARWHENSTOP=0 @NOGEAR
%IF #SPINWARN=1 @WARN
%GOTO @NOTSTOP

@NOGEAR
%IF #SPINWARN=0 @END  ; No warning
#SPEEDHOLD=0:#RPMHOLD=0
%IF #MACRO=15 @END
%IF #MACRO=165 @END
%IF #SPINWARN=2 @WARN ; Warn for all moves
* Warn for feed moves only
%IF #MACRO=1 @END
%IF #MACRO=41 @END
%IF #MACRO=40 @END
%IF #MACRO=191 @END
%IF #MACRO=190 @END
@WARN
$WARNING="Warning - Spindle is Not Running":%CALL=CODECON_WARNING
%IF #GEARWHENSTOP=1 @NOTSTOP
#SPEEDHOLD=#SPEED
%GOTO @END

@NOTSTOP
*
* Set CSS code
%IF #CSS=1 %THEN #CSSGCODE=DATA1(45) %ELSE #CSSGCODE=DATA1(44)

%IF NEXTMACRO=101 @END		;Spindle Direction
%IF NEXTMACRO=110 @END		;Gear Select
%IF NEXTMACRO=15 @END		;Tool Change

* Set speed variables
#RPM=#SPEED
#SFM=#SPEED

* Trap zero speed
%IF #SPEED=0 %THEN #SPEED=#FUNNY:#CSSGCODE=#FUNNY:%GOTO @END

%IF #CSS=0 @GEARS
*CSS is On Calculate RPM
%CALL=PT_MTH_SFM_TO_RPM ; Re-calculate the Rpm at next X

@GEARS
%CALL=PT_GEAR_MCODE
#SPEED=#SFM ; Reset

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PT_GEAR _____
;

%PROCEDURE=PT_GEAR_MCODE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_GEAR_MCODE:%CALL=ENTER_PROCEDURE

#TEMP=GEAR(0) ; Set sys var for gears - current spindle
*<NUMGEARS [NUMGEARS=0]>
%IF #TEMP=0 %THEN $WARNING="ERROR : Gear ranges not set":%CALL=CODECON_WARNING

* Get machine maximum speed from highest gear
#TEMP=GEAR(NUMGEARS)
#MACHINEMAXRPM=GEARMAXRPM
#GEARMCODE=GEARCODE
*
* Check speed if RPM programmed or CSS check required
* Even if speed unchanged, recheck for current spindle
%IF #CSS=0 @RPM
%IF #CSSRPMCHECK=0 @FIND_GEAR
*
%IF MAXRPM<#RPM %THEN #RPM=MAXRPM
* <MAXRPM=[MAXRPM=13]  #RPM=[#RPM=13]  Hold=[#RPMHOLD=13]>
%IF #RPM=#RPMHOLD @NOCHECK1    ; Speed unchanged
#RPMHOLD=#RPM
%GOTO @SPEEDCHECK
*
@RPM
%IF #SPEED=#SPEEDHOLD @NOCHECK1    ; Speed unchanged

@SPEEDCHECK
%IF #MACRO=254 @NOCHECK1 ; Docking
%IF #MACRO=262 @NOCHECK1 ; Docking
%IF #MACRO=268 @NOCHECK1 ; Docking
* Check speed in range for spindle
%IF #RPM>#MACHINEMAXRPM %THEN $WARNING="Error - Speed does not lie in range for selected spindle.":%CALL=CODECON_WARNING:%GOTO @END
@NOCHECK1
* Get details for first gear
#GEAR=1
#TEMP=GEAR(#GEAR)
#MACHINEMINRPM=GEARMINRPM
#GEARMCODE=GEARCODE
*
%IF #SPEED=#SPEEDHOLD @NOCHECK2    ; Speed unchanged
* Check speed in range for spindle
%IF #MACRO=254 @NOCHECK2 ; Docking
%IF #MACRO=262 @NOCHECK2 ; Docking
%IF #MACRO=268 @NOCHECK2 ; Docking
%IF #RPM<#MACHINEMINRPM %THEN $WARNING="Error - Speed does not lie in range for selected spindle.":%CALL=CODECON_WARNING:%GOTO @END
@NOCHECK2

@FIND_GEAR
%IF #ONEGEARFLG=0 @FIND_GEAR2
%IF NUMGEARS=1 @END
@FIND_GEAR2
#GEARMCODE=#FUNNY
%IF NUMGEARS=1 @END
%IF GEAR>0 %THEN #TEMP=GEAR(GEAR):%GOTO @SELECT_GEAR_MCODE ; Specified gear

* Auto - Find gear
#GEAR=1
@RPM_LOOP
#TEMP=GEAR(#GEAR)                    ; Select gear
%IF #RPM<=GEARMAXRPM @SELECT_GEAR_MCODE ; Speed in range ?
%IF #GEAR=NUMGEARS @SELECT_GEAR_MCODE  ; Last gear ?
#GEAR=#GEAR+1:%GOTO @RPM_LOOP	   ; Select next gear

@SELECT_GEAR_MCODE
#GEARMCODE=#FUNNY
%IF NUMGEARS=1 @END
#GEARMCODE=GEARCODE

%IF #MACRO=254 @SPEEDCHECK2 ; Docking
%IF #MACRO=262 @SPEEDCHECK2 ; Docking
%IF #MACRO=268 @SPEEDCHECK2 ; Docking
*	Warn if Gear Range selected greater than defined in Spindle Tab
%IF #GEAR>NUMGEARS %THEN $WARNING="ERROR : Higher gear selected than is configured for this machine":%CALL=CODECON_WARNING

%IF #CSS=0 @SPEEDCHECK2
%IF #CSSRPMCHECK=0 @END

@SPEEDCHECK2
%IF #SPEED<>#SPEEDHOLD @SPEEDCHECK2A ; Speed changed
%IF #GEAR<>#GEARHOLD @SPEEDCHECK2A   ; Gear changed
%GOTO @END
@SPEEDCHECK2A
* Check speed in range for gear
* GEARMAXRPM,GEARMINRPM  limits for this gear on this spindle
%IF #MACRO=254 @END ; Docking
%IF #MACRO=262 @END ; Docking
%IF #MACRO=268 @END ; Docking
%IF #RPM<GEARMINRPM %THEN $WARNING="Warning - Speed does not lie in range for selected gear.":%CALL=CODECON_WARNING
%IF #RPM>GEARMAXRPM %THEN $WARNING="Warning - Speed does not lie in range for selected gear.":%CALL=CODECON_WARNING

@END
#GEARHOLD=#GEAR
#SPEEDHOLD=#SPEED ; Reset after gear selection

@TRACE
%IF #PROCTRACE=0 @ALLEND
%IF #TRSPEED=0 @NOSPEED
<* >
#TRX=#RPM
<* Current RPM=[#TRX=13]  CAM Speed=[SPEED=13]  NextSpeed=[NEXTSPEED=13]>
<*         CSS Radius [#CSSXMOVE=0]>
<*         Modes #CSS=[#CSS=13]   CAXIS=[CAXIS=13]>
<*         Gear Speed Range [GEARMINRPM=13] to [GEARMAXRPM=13]>
<*         Spindle Speed Range [#MACHINEMINRPM=13] to [#MACHINEMAXRPM=13]>
<* >
@NOSPEED
%CALL=EXIT_PROCEDURE
@ALLEND
%ENDM


;                                      
; Procedure = Evaluate Move
;                                      

%PROCEDURE=EVALUATE_MOVE
%IF #PROCTRACE=1 %THEN $PROCEDURE=EVALUATE_MOVE:%CALL=ENTER_PROCEDURE
* Evaluate_move performs a number of operations sequentially on the coordinates
* The start of each section is clearly marked.

* Hold and nomotion checking grouped together.
* Hold values are output coords with reverse and diametral adjustments
* Keep values are machine coordinates adjusted for CPL variations

****************************************
* Adjust for CPL reversals, sub spindle related
****************************************

%CALL=PT_FIX


****************************************
* Initialise  variables
****************************************
#MOVE=0
%IF #MACRO=2 @LINE
%IF #MACRO=1 @LINE
%IF #MACRO=53 @ARC
%IF #MACRO=54 @ARC
%IF #MACRO=159 @FIVE
%IF #MACRO=160 @FIVE
%IF #MACRO=161 @FIVE
%IF #MACRO=162 @FIVE
%IF #MACRO=163 @FIVE

@LINE
* Do not set for hole cycles
#XRAWHOLD=XMOVE ; Used in Polar Mode Switching
#YRAWHOLD=YMOVE
%GOTO @JUMP2

@ARC
#XRAWHOLD=XMOVE ; Used in Polar Mode Switching
#YRAWHOLD=YMOVE
#RRAWHOLD=REND
#CRAWHOLD=CEND
%GOTO @FIVE

@JUMP2
#RRAWHOLD=RMOVE
#CRAWHOLD=CMOVE
%IF SPINDLE=SPINDLEID2 %THEN #CRAWHOLD=#C2KEEP

@FIVE

****************************************
* Set precision and #MOVE
****************************************
@XMOVE
%IF #MACRO=253 @CMOVE
%IF #XMOVE=#FUNNY @ZMOVE
* <TEMPROUND=[#TEMPROUND=0]>
#TEMPROUND=#XMOVE*#ABSDIAM
* <TEMPROUND=[#TEMPROUND=0]>
%CALL=PT_ROUND_VALUE
* <TEMPROUND=[#TEMPROUND=0]>
#XMOVE=#TEMPROUND
#XSTOREABS=#XMOVE
%IF #XMOVE<>#XKEEP %THEN #MOVE=#MOVE+1 ; Check for motion

@ZMOVE
%IF #ZMOVE=#FUNNY @CMOVE
#TEMPROUND=#ZMOVE
%CALL=PT_ROUND_VALUE
#ZMOVE=#TEMPROUND
#ZSTOREABS=#ZMOVE
%IF #ZMOVE<>#ZKEEP %THEN #MOVE=#MOVE+4 ; Check for motion

@CMOVE

@INCREMENTAL
#Y0FORCED=0                     ; Reset Forced Y 0 flag ; 1607

****************************************
* Set ref point flag
****************************************
%IF #MOVE=16 @NOMOVE ; C only
%IF #MOVE=32 @NOMOVE ; B Only
%IF #MOVE=48 @NOMOVE ; C and B
%IF #MOVE=0 @NOMOVE  ; No movement   2705
#ATREFPT=0 ; Position checking
@NOMOVE

%IF #XMOVE=#FUNNY @NOSET
%IF #XMOVE=0 @NOSET
#CSSXMOVE=ABS(#XMOVE):#CSSXMOVE=#CSSXMOVE*#INVDIAM ; Save radius for RPM calculation
@NOSET

****************************************
* Process Incremental Coordinates
****************************************
%IF #INCRXYZ=0 @SET_KEEP
****************************************
* Incremental linear moves, use KEEP not HOLD values
#XMOVE=#XMOVE-#XKEEP ;	Calc incremental move
#ZMOVE=#ZMOVE-#ZKEEP
%IF #XMOVE=0 %THEN #XMOVE=#FUNNY ;	Supress zero move
%IF #ZMOVE=0 %THEN #ZMOVE=#FUNNY
%CANCEL=#XMOVE,#ZMOVE;	Needed for incremental motion


@SET_KEEP
****************************************
* Set KEEP values
****************************************
* Note #XKEEP and #XSTOREABS are diametral values when appropriate
* #XCARTKEEP is a radial value
%IF #XSTOREABS<>#FUNNY %THEN #XKEEP=#XSTOREABS
%IF #ZSTOREABS<>#FUNNY %THEN #ZKEEP=#ZSTOREABS
%IF XMOVE<>#FUNNY %THEN #XCARTKEEP=XMOVE ; Always cartesian value
* CHANGE 21/02/12
%IF #MACRO=190 %THEN #XCARTKEEP=#XKEEP*#INVDIAM ; Move Home
%IF #MACRO=191 %THEN #XCARTKEEP=#XKEEP*#INVDIAM ; Move Toolchange
*
%IF MILLMODE=0 @XSKIP
%IF SPINDLE=SPINDLEID1 @XSKIP
#XCARTKEEP=#XCARTKEEP*-1 ; correct for sub spindle planar
@XSKIP




****************************************
* Tool Length adjustment
****************************************
@TLO
%IF #TLOCOMP=0 @LINEAR
#XMOVE=#XMOVE+#TOOLXSET
#ZMOVE=#ZMOVE+#TOOLZSET
%IF #ARCTYPE<>4 @LINEAR
#IVALUE=#IVALUE+#TOOLXSET*#DIAM
#KVALUE=#KVALUE+#TOOLZSET*#ZREVERSE

@LINEAR
****************************************
* Apply linear axis reversals etc
****************************************
#XMOVE=#XMOVE*#XREVERSE ; DIAM setting is earlier using #ABSDIAM
#YMOVE=#YMOVE*#YREVERSE
#ZMOVE=#ZMOVE*#ZREVERSE
%IF #ARCTYPE<>4 @END
* not unsigned
#IVALUE=#IVALUE+#TOOLXSET*#DIAM
#KVALUE=#KVALUE+#TOOLZSET*#ZREVERSE

@END


****************************************
* Set Feed, Speed, Feedtype
****************************************
@FEED
%CALL=PT_CONTROL_FEEDTYPE

%IF #PROCTRACE=0 @ALLEND
****************************************
* Debug and trace Output
****************************************
* Procedure trace is ON. Additional trace options
* #TRTHREAD,#TRHOLE control array dumps in CY procedure
* #TRX,#TRY,#TRZ,#TRC1,#TRC2,#TRB temporary output vars to protect modality
* Note that diagnostic is context sensitive, shows CAM view of axis position
%IF #MACRO=159 @EXIT
%IF #MACRO=160 @EXIT
%IF #MACRO=161 @EXIT
%IF #MACRO=162 @EXIT
%IF #MACRO=163 @EXIT
%IF #MACRO=187 @EXIT
* Not Drill or Thread Mill
%IF #MACRO=253 @EXIT ; B Index
%IF #MACRO=61 @TRM ; Cyclesub output elsewhere
#TRX=XMOVE
#TRY=YMOVE
#TRZ=ZMOVE
#TRC=CMOVE
#TRR=RMOVE
%IF #MACRO=53 %THEN #TRX=XEND:#TRY=YEND:#TRZ=ZEND:#TRR=REND ; 1607B
%IF #MACRO=54 %THEN #TRX=XEND:#TRY=YEND:#TRZ=ZEND:#TRR=REND ; 1607B
%IF MILLMODE=1 @DONE                                        ; 1607B
%IF #MACRO=53 %THEN #TRC=CEND                               ; 1607B
%IF #MACRO=54 %THEN #TRC=CEND                               ; 1607B

%GOTO @DONE ; Set Cam Coordinates to MOVE values 1710-2012

%IF #MACRO=40 %THEN #TRX=XHOME:#TRY=#FUNNY:#TRZ=ZHOME
%IF #MACRO=41 %THEN #TRX=XTOOL:#TRY=#FUNNY:#TRZ=ZTOOL

@DONE
%IF #MACRO=187 @EXIT

%IF #TRENDS=0 @TRM
* Output End Points
<* CAM Coordinates  X[#TRX=13] Z[#TRZ=13]>

@TRM
%IF #TRMACHINE=0 @TRMODE
* Output position in machine coordinates
<* Machine Coordinates [#XKEEP=0][#ZKEEP=2]>

@TRMODE
%IF #TRMODE=0 @EXIT
* Output Current Mode Settings
<* Move Evaluation Code #MOVE=[#MOVE=13]>

@EXIT
%CALL=EXIT_PROCEDURE

@ALLEND
%ENDM

;                                      
; Procedure = PT_HOLE_CYCLE_APPROACH 
;                                      
%PROCEDURE=PT_HOLE_CYCLE_APPROACH
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_HOLE_CYCLE_APPROACH:%CALL=ENTER_PROCEDURE
* Fixed tool hole cycle approach

* Check static tool option flags, default same as CY
%IF #TRETRACTINC=#FUNNY %THEN #TRETRACTINC=#RETRACTINC
%IF #TZRABSINCR=#FUNNY %THEN #TZRABSINCR=#ZRABSINCR
%IF #TCLEARINC=#FUNNY %THEN #TCLEARINC=#CLEARINC

* Rapid to start position, Clearance
#ZMOVE=ZCLEAR ; 2402
#TMP=#GCODE:#GCODE=DATA1(1)	 ; 2402	Hold onto Cycle G Code and set to Rapid.

%IF SPINDLE=SPINDLEID2 @SUBSPIN
* Main Spindle
%IF #ZKEEP<#ZMOVE @MOVEZ
%GOTO @MOVEALL

@SUBSPIN
* Sub Spindle
%IF #ZKEEP>#ZMOVE @MOVEZ
%GOTO @MOVEALL

@MOVEZ
* Z First for clearance
#XMOVE=#XKEEP/#ABSDIAM ; 2402
%CALL=PT_OUTPUT_RAPID ; 2402

@MOVEALL ; 2402
* Rapid to Centre Line
#ZMOVE=ZCLEAR ; 2402 Reset
#XMOVE=0 ; 2402
* #TMP=#GCODE:#GCODE=DATA1(1) ;	Hold onto Cycle G Code and set to Rapid.
#ZMOVE=#ZMOVE
*%IF #INCRXYZ=1 %THEN #ZMOVE=#ZMOVE-#ZHOLD
%CALL=PT_OUTPUT_RAPID
*
*Set RPLANE
%IF RPLANE=#FUNNY %THEN RPLANE=0
%IF RPLANE=0 %THEN #RPLANE=ZCLEAR %ELSE #RPLANE=RPLANE+ZLEVEL; Absolute

* Move to RPLANE if not already there (tapping)
%IF #MACRO<>10 @SKIP_R
%IF #RPLANE=ZCLEAR @SKIP_R
#GCODE=DATA1(1)					;	Set G Code to Rapid.
#ZMOVE=#RPLANE
*%IF #INCRXYZ=1 %THEN #ZMOVE=#ZMOVE-#ZHOLD
%CALL=PT_OUTPUT_RAPID
*
@SKIP_R
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      
; Procedure = PT_HOLE_CYCLES       
;                                      
%PROCEDURE=PT_HOLE_CYCLES
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_HOLE_CYCLES:%CALL=ENTER_PROCEDURE
* Now called from PMACRO-9 and PMACRO-10 for all static tool holes


%CALL=PT_HOLE_CYCLE_APPROACH

@RETRACT
%IF #TRETRACTINC>1 @INC
%IF #TLOCOMP=1 %THEN #RPLANE=#RPLANE+#TOOLZSET ; Absolute only
%GOTO @JUMP

@INC
#RPLANE=#RPLANE-ZCLEAR; Incremental from Clearance
%IF #TRETRACTINC=4 %THEN #RPLANE=RPLANE  ; Incremental from Level
%IF #TRETRACTINC=3 %THEN #RPLANE=ABS(#RPLANE); Unsigned
*
@JUMP
#RPLANE=#RPLANE*#ZREVERSE

; Error if CSS active
%IF #CSS=1 %THEN $WARNING="ERROR : Constant surface speed active for hole cycle !":%CALL=CODECON_WARNING


#DRGCODE=DATA1(37); Drill
%IF DWELL=#FUNNY %THEN DWELL=0
%IF DWELL>0 %THEN #DRGCODE=DATA1(38); Counterbore
%IF DEPTH>0 %THEN #DRGCODE=DATA1(39); Peck Drill
%IF #MACRO=265 %THEN #DRGCODE=DATA1(35); Chipbreak
%IF #MACRO=266 %THEN #DRGCODE=DATA1(41); Ream
%IF #MACRO=267 %THEN #DRGCODE=DATA1(42); Bore
*
%IF #MACRO<>10 @SKIP_TAP
* Tapping only
%IF PATHTRACE=1 %THEN %CALL=TAP_LONGHAND:%GOTO @END  ; Longhand
#DRGCODE=DATA1(40)	;	Tapping Gcode

@SKIP_TAP

* Depth/Dwell mutual exclusivity removed, 0 values set to FUNNY
#DEPTH=DEPTH
%IF #DEPTH=0 %THEN #DEPTH=#FUNNY
%IF #MACRO=10 @SKIP_DWELL
%IF DWELL=0 %THEN DWELL=#FUNNY
@SKIP_DWELL
%IF #DEGR=0 %THEN #DEGR=#FUNNY
#DEGR=DEGR
*

%IF RPLANE=0 %THEN #RETRACTGCODE=DATA1(50) %ELSE #RETRACTGCODE=DATA1(50)	;	G98 / G99
%IF #SUPPORTG98G99=#FALSE %THEN #RETRACTGCODE=#FUNNY	;	Suppress from output if not supported
*
#ZMOVE=ZEND
%IF #TZRABSINCR>1 @INC2
%IF #TLOCOMP=1 %THEN #ZMOVE=#ZMOVE+#TOOLZSET ; Absolute only
%GOTO @JUMP2
*
@INC2
#ZDEPTH=#ZMOVE-RPLANE-ZLEVEL
%IF #TZRABSINCR=3 %THEN #ZDEPTH=ABS(#ZDEPTH)	;	Incremental, Unsigned
#ZMOVE=#ZDEPTH
*
@JUMP2
#ZMOVE=#ZMOVE*#ZREVERSE ; Depth for cycle

* Set ZCLEAR incremental if required (840D)
#ZCLEAR=ZCLEAR
%IF #TCLEARINC=1 %THEN #ZCLEAR=#ZCLEAR-ZLEVEL
#ZCLEAR=#ZCLEAR*#ZREVERSE
#ZLEVEL=ZLEVEL*#ZREVERSE
*
@END
%CALL=PT_CONTROL_FEEDTYPE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=PT_SPINDLE_REVERSE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SPINDLE_REVERSE:%CALL=ENTER_PROCEDURE
*	Reverse the current spindle direction : called from Tapping when emulating a cycle


* Main spindle static tool
%IF #DIRECTION=DATA2(4) %THEN #DIRECTION=DATA2(5):%GOTO @END 	;	Forward	->	Reverse
%IF #DIRECTION=DATA2(5) %THEN #DIRECTION=DATA2(4):%GOTO @END 	;	Reverse	->	Forward
%IF #DIRECTION=DATA2(14) %THEN #DIRECTION=DATA2(15):%GOTO @END
%IF #DIRECTION=DATA2(15) %THEN #DIRECTION=DATA2(14)
*
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      
; Procedure = PT_BRAKE            
;                                      
%PROCEDURE=PT_SPIN_BRAKE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SPIN_BRAKE:%CALL=ENTER_PROCEDURE

%IF #MACRO=121 @MACROCALL
%IF #AUTOCLAMP=0 @CALL
* Call from token in auto mode
* Set strategy and output
@STRAT
%CALL=SET_SPINDLE_CLAMP
#BRAKE=#SPINBRAKE
%GOTO @CALL

@MACROCALL
#AUTOCLAMP=0
%IF SUBFUNCT=4 %THEN #AUTOCLAMP=1:%GOTO @STRAT; Auto mode set

* Call from macro
#AUTOCLAMP=0
* Check priority
%IF #PRIORITYMAIN<>TURRET @END
%IF #BRAKEHIGH=#FUNNY %THEN #BRAKEHIGH=#BRAKEON
%IF #BRAKELOW=#FUNNY %THEN #BRAKELOW=#BRAKEON
*
%IF SUBFUNCT=1 %THEN #BRAKE=#BRAKEHIGH
%IF SUBFUNCT=2 %THEN #BRAKE=#BRAKEOFF
%IF SUBFUNCT=3 %THEN #BRAKE=#BRAKELOW
@CALL
#BRAKETMP=#BRAKEHOLD
* Force after tool change
%IF #BRAKEFORCE1=#FUNNY %THEN #BRAKEFORCE1=0
%IF #BRAKEFORCE2=#FUNNY %THEN #BRAKEFORCE2=0
*
%IF #MACRO=40 @HOMETC
%IF #MACRO=41 @HOMETC
%IF #MACRO=190 @HOMETC
%IF #MACRO=191 @HOMETC

* Force after ToolChange
* <AfterTC>
* #BRAKEFORCE1=1 Force After ToolChange
%IF #BRAKEFORCE1=0 @NOFORCE1
%IF #TOOLCHANGEROT=#TRUE @FORCE
%GOTO @NOFORCE1

@HOMETC
* <HOMETC>
* For for Rapid Home or ToolChange
* #BRAKEFORCE2=1 Force For Move To ToolChange
%IF #BRAKEFORCE2=1 @FORCE

@NOFORCE1
* Brake control modal
%IF #BRAKE=#BRAKETMP @END
%GOTO @CALL2

@FORCE
* Force Brake control code
%CANCEL=#BRAKE
@CALL2
%CALL=CODECON_SPINDLE_BRAKE
#BRAKEHOLD=#BRAKE
@END
#TOOLCHANGEROT=0
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      
; Procedure = PT_WARNING_COUNT    
;                                      
%PROCEDURE=PT_WARNING_COUNT
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_WARNING_COUNT:%CALL=ENTER_PROCEDURE

%IF #WARNCOUNT=0 @END

%OPTIONS=Errors or Warnings in NC data file^OK=#TMP

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_C_STATUS    
;                                      
%PROCEDURE=PT_C_STATUS
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_C_STATUS:%CALL=ENTER_PROCEDURE

* C axis status, set release if static tool, joint if driven
%IF CAXIS=0 @STATIC
*Driven
#CSTAT=DATA2(67)
%IF #SPINDLE=SPINDLEID2 %THEN #CSTAT=DATA6(67)
%GOTO @END

@STATIC
#CSTAT=DATA2(66)
%IF #SPINDLE=SPINDLEID2 %THEN #CSTAT=DATA6(66)

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_SPIN_STOP    
;                                      
%PROCEDURE=PT_SPIN_STOP
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SPIN_STOP:%CALL=ENTER_PROCEDURE

#DIRHOLD=#DIRECTION
%IF CAXIS=0 @STATIC
* Driven spindle
#DIRECTION=DATA6(13)
%GOTO @END

@STATIC
%IF #SPINDLE=SPINDLEID2 @SUBSPIN
* Main Spindle
%IF #PRIORITYMAIN=TURRET %THEN #DIRECTION=DATA2(6)
%GOTO @END

@SUBSPIN
* Sub Spindle
%IF #PRIORITYSUB=TURRET %THEN #DIRECTION=DATA6(6)

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=PT_TURN_STOP
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_TURN_STOP:%CALL=ENTER_PROCEDURE

#DIRHOLD=#DIRECTION

%IF SPINDLE=SPINDLEID2 @SUBSPIN
* Main Spindle
%IF #SUPPSPEED=0 @CONTROL1
#DIRECTION=#FUNNY
%IF #PRIORITYMAIN<>TURRET %THEN #DIRHOLD=#FUNNY
@CONTROL1
%IF #PRIORITYMAIN=TURRET %THEN #DIRECTION=DATA2(6)
%GOTO @END

@SUBSPIN
* Sub Spindle
%IF #SUPPSPEED=0 @CONTROL2
#DIRECTION=#FUNNY
%IF #PRIORITYSUB<>TURRET %THEN #DIRHOLD=#FUNNY
@CONTROL2
%IF #PRIORITYSUB=TURRET %THEN #DIRECTION=DATA6(6)

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      
; Procedure = PT_TOOL_CODES    
;                                      

%PROCEDURE=PT_TOOL_CODES
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_TOOL_CODES:%CALL=ENTER_PROCEDURE

* #DRIVENTOOL is used as a processing flag with main spindle values
* This procedure switches to sub spindle values for output. Reset after token use

%IF #SPINDLE=SPINDLEID1 @END
* Sub Spindle only
#DRIVENKEEP=#DRIVENTOOL
#DRIVENTOOL=#SUBTOOLSTATIC
%IF #DRIVENKEEP=#TOOLDRIVEN %THEN #DRIVENTOOL=#SUBTOOLDRIVEN

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_TLO_SET    
;                                      

%PROCEDURE=PT_TLO_SET
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_TLO_SET:%CALL=ENTER_PROCEDURE

* #AUTOTLO
* 1= Maximum Tools + Turret Position
* 2= Turret Position
* 3= Position - Last 2 digits
* 4= Position + Adjustment
* 5= Zero
* 6= Specified Rage - uses default and maximum

%IF #AUTOTLO<6 @CONTINUE
%IF #AUTOTLO=#FUNNY @CONTINUE ; protect for INDEXG200
* TLO in specified range
#HCODE=#DEFAULTREG
%IF TOOLOFFSET=#FUNNY @JUMP
%IF TOOLOFFSET<>0 %THEN #HCODE=ABS(TOOLOFFSET)
%IF #HCODE>#MAXREG %THEN #HCODE=#MAXREG:$WARNING="ERROR : Invalid Offset Overwritten":%CALL=CODECON_WARNING
@JUMP
%GOTO @TLODONE

@CONTINUE
* Tool Length Offset - Set by User
%IF TOOLOFFSET<>0 %THEN #HCODE=TOOLOFFSET:%GOTO @TLODONE

* Not set, use default calculation
%IF #AUTOTLO=1 %THEN #HCODE=POSITION+#MAXTOOLS:%GOTO @TLODONE
%IF #AUTOTLO=2 %THEN #HCODE=POSITION:%GOTO @TLODONE
%IF #AUTOTLO=4 %THEN #HCODE=POSITION+#TLOSHIFT:%GOTO @TLODONE
%IF #AUTOTLO=5 %THEN #HCODE=0:%GOTO @TLODONE

* Last 2 digits #AUTOTLO=3
#HCODE=ABS(POSITION); Check positive for safety in loop
%IF #HCODE=#FUNNY @TLODONE
@START
%IF #HCODE<100 @TLODONE
#HCODE=#HCODE-100
%GOTO @START

@TLODONE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

%PROCEDURE=PT_TLO_SET_5AX
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_TLO_SET_5AX:%CALL=ENTER_PROCEDURE
%IF #TLOSHIFT5AX=#FUNNY %THEN #TLOSHIFT5AX=0
* #AUTOTLO
* 1= Maximum Tools + Turret Position
* 2= Turret Position
* 3= Position - Last 2 digits
* 4= Position + Adjustment
* 5= Zero

* Tool Length Offset - Set by User
%IF TOOLOFFSET<>0 %THEN #HCODE5AX=TOOLOFFSET:%GOTO @TLODONE

* Not set, use default calculation
%IF #AUTOTLO=1 %THEN #HCODE5AX=POSITION+#MAXTOOLS:%GOTO @TLODONE
%IF #AUTOTLO=2 %THEN #HCODE5AX=POSITION:%GOTO @TLODONE
%IF #AUTOTLO=4 %THEN #HCODE5AX=POSITION+#TLOSHIFT5AX:%GOTO @TLODONE
%IF #AUTOTLO=5 %THEN #HCODE5AX=0:%GOTO @TLODONE

* Last 2 digits #AUTOTLO=3
#HCODE5AX=ABS(POSITION); Check positive for safety in loop
@START
%IF #HCODE5AX<100 @TLODONE
#HCODE5AX=#HCODE5AX-100
%GOTO @START

@TLODONE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      
; Procedure = SET_WORK_DATUMS    
;                                      

%PROCEDURE=SET_WORK_DATUMS
%IF #PROCTRACE=1 %THEN $PROCEDURE=SET_WORK_DATUMS:%CALL=ENTER_PROCEDURE
#UNIQUEDATUMS=#TRUE

*  < G10 L2 P0 X0 Z0 C0 Y0 A0 (True Datum)>
* Initialise sysid variables before running loop
* So that loop will work again if run at end of program
#G54=#FUNNY
#G55=#FUNNY
#G56=#FUNNY
#G57=#FUNNY
#G58=#FUNNY
#G59=#FUNNY ; 2005

#LOOP=0
#COORDNUM=1
* %IF PASS=1 %THEN TURRET=0 %ELSE TURRET=1
@LOOPSTART
#LOOP=#LOOP+1
*<Loop [#LOOP=0]>
%GETCPL=#LOOP
%IF SYSID=#FUNNY @END

%IF #OUTPUTSHIFTS=1 @SYS ; 2205
%IF STYPE=0 @LOOPSTART		; Datum type is incremental, skip assignment.  ; 2005
@SYS    ; 2205

#SYSID=SYSID*1000000:%IF #UNIQUEDATUMS=#TRUE %THEN #SYSID=(#SYSID+(ROT1*1000)+ROT2) ; Make Datum unique by XYZ and Rotation
;<Sysid = [#SYSID=0]>
;<Uniquedatum = [#UNIQUEDATUMS=24]>

%IF #SYSID=#G54 @LOOPSTART  								; Skip if datum is already assigned.
%IF #SYSID=#G55 @LOOPSTART
%IF #SYSID=#G56 @LOOPSTART
%IF #SYSID=#G57 @LOOPSTART
%IF #SYSID=#G58 @LOOPSTART
%IF #SYSID=#G59 @LOOPSTART ; 2005

%IF #COORDNUM=1 %THEN #G54=#SYSID:#WORKGCODE=54:%GOTO @CARRYON ; 1505
%IF #COORDNUM=2 %THEN #G55=#SYSID:#WORKGCODE=55:%GOTO @CARRYON ; 1505
%IF #COORDNUM=3 %THEN #G56=#SYSID:#WORKGCODE=56:%GOTO @CARRYON ; 1505
%IF #COORDNUM=4 %THEN #G57=#SYSID:#WORKGCODE=57:%GOTO @CARRYON ; 1505
%IF #COORDNUM=5 %THEN #G58=#SYSID:#WORKGCODE=58:%GOTO @CARRYON ; 2005
%IF #COORDNUM=6 %THEN #G59=#SYSID:#WORKGCODE=59:%GOTO @CARRYON ; 2005

%IF #OUTPUTSHIFTS=0 @END ; No available datum codes 2205

@CARRYON ; 1505
#XSUB=XSUB:#YSUB=YSUB:#ZSUB=ZSUB
*<Call>
%CALL=CODECON_SET-WORK-DATUMS
#COORDNUM=#COORDNUM+1
%GOTO @LOOPSTART

@END
#TMP=1
%GETCPL=#TMP  ; Reset     2705

@END2
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_MODIFIERS      
;                                      

%PROCEDURE=PT_MODIFIERS
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_MODIFIERS:%CALL=ENTER_PROCEDURE
* procedure written to calculate settiings of reversal flags and #DIAM modifier

#SUBG2G3DRIVEN=0
%IF CAXIS=3 @CAX3


* Main Spindle
*<XMODIFIER Main>
#ZREVERSE=#ZMAINREVERSE
#XREVERSE=#XMAINREVERSE
%IF CAXIS=0 @DIAM
#YREVERSE=#YMAINDRIVEN
%GOTO @DIAM


@CAX3
* CAXIS=3, B axis moves
#XREVERSE=1
#YREVERSE=1
#ZREVERSE=1

@SUBREV
%IF SPINDLE=SPINDLEID1 @DIAM
* Main spindle B
#XREVERSE=-1
%IF #YBSUBREVERSE=1 %THEN #YREVERSE=-1
#ZREVERSE=-1
#SUBG2G3DRIVEN=1
%GOTO @DIAM

**************************************************
@DIAM
* <* Set DIAM setting [FIVEAXIS=0]>
* Static Tools
%IF CAXIS=0 %THEN #ABSDIAM=#TURNDIAM:#DIAM=#TURNDIAM*#XREVERSE:%GOTO @END   ; Turning
%IF FIVEAXIS=1 %THEN #ABSDIAM=#5AXDIAM:#DIAM=#5AXDIAM*#XREVERSE:%GOTO @END ; 5 Axis Mode

* Driven Tools
%IF CAXIS=2 %THEN #ABSDIAM=#RDIAM:#DIAM=#RDIAM*#XREVERSE:%GOTO @END      ; Radial     2107
%IF $CAXENGAGED=YES @POLAR                                               ; 2107a
%IF CAXIS=3 %THEN #ABSDIAM=#BDIAM:#DIAM=#BDIAM*#XREVERSE:%GOTO @END      ; B Axis Mode
%IF CAXIS=1 %THEN #ABSDIAM=#ADIAM:#DIAM=#ADIAM*#XREVERSE                 ; Axial
*
@POLAR                   ; 2107
* Polar milling (G12) override
%IF #HOLEFLAG<>2 @POLAR2 ; 2107a
%IF #HOLEPOLAR>1 @POLAR3 ; 2107a

@POLAR2                  ; 2107a
%IF $CAXENGAGED=NO @SKIPTHIS
@POLAR3                  ; 2107a
#ABSDIAM=#POLARDIAM:#DIAM=#POLARDIAM*#XREVERSE
%IF #TRANSMITMODE=1 %THEN #DIAM=2*#XREVERSE ; Active for G200
@SKIPTHIS

@END
* Adjust for rotary at B180
%IF MILLMODE=1 @ENDALL
%IF CAXIS<>3 @ENDALL
%IF BMOVE<>180 @ENDALL
#ZREVERSE=#ZREVERSE*-1
*
@ENDALL
#INVDIAM=1/#ABSDIAM
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


*********************************************************

%PROCEDURE=PT_COOL_CANCEL
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_COOL_CANCEL:%CALL=ENTER_PROCEDURE

#COOLHOLD=#COOL

#COOL=DATA2(10)

@TAPS
%IF #AUTOTAPOFF=0 @ENDM
#SETCHUCKCOOL=0 ; Chuck Face
#SETTURRETCOOL=0 ; Turret Face
#SETSPINDLECOOL=0 ; Through Spindle
#SETALLCOOL=0
%CALL=PT_SET_COOLANT_TAPS
%CALL=PT_OUTPUT_COOLANT

@ENDM
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*********************************************************

%PROCEDURE=PT_THRO_TOOL_CANCEL
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_THRO_TOOL_CANCEL:%CALL=ENTER_PROCEDURE
* Called by token

#THROUGHTOOL1=#THROUGHTOOL1OFF
#THROUGHTOOL=#THROUGHTOOL1

@ENDM
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*********************************************************

%PROCEDURE=PT_THROUGH_COOL
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_THROUGH_COOL:%CALL=ENTER_PROCEDURE

#NEEDTHROUGH=0

* Through Tool Coolant
%IF THROUGHCOOLANT=0 %THEN #THROUGHTOOL1=#THROUGHTOOL1OFF:%GOTO @ENDM
#NEEDTHROUGH=1
%IF THROUGHCOOLANT=1 %THEN #THROUGHTOOL1=#THROUGHTOOL1ON
%IF THROUGHCOOLANT=2 %THEN #THROUGHTOOL1=#THROUGHTOOL1HIGH

@ENDM
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*********************************************************




%PROCEDURE=PT_FIX
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_FIX-STUB:%CALL=ENTER_PROCEDURE

; Stub procedure - conversion is needed only if B axis is present

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


*********************************************************

%PROCEDURE=PT_CRC_REVERSE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CY_CRC_REVERSE:%CALL=ENTER_PROCEDURE
* CRC code reversals

%IF CAXIS=0 @NO-SWAP
%IF SPINDLE=SPINDLEID1 @NO-SWAP
%IF #COMPGCODE=40 @NO-SWAP
%IF #COMPGCODE=#FUNNY @NO-SWAP

* %IF #SUBG2G3DRIVEN=0 @NO-SWAP

@SWAP
%IF #COMPGCODEHOLD=41 %THEN #COMPGCODE=42 %ELSE #COMPGCODE=41

@NO-SWAP
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*
********************************************************************************

%PROCEDURE=PT_CAX_REVERSE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CAX_REVERSE:%CALL=ENTER_PROCEDURE
* Sign reversals for driven tools on Lower Turret
%GOTO @VERYVERYEND


%IF CAXIS=0 @END ; Just in case
%IF CAXIS=3 @END
%IF CAXIS=1 @AXIAL

*Radial
%IF SPINDLE=SPINDLEID2 @SUBRAD
%IF #MACRO=159 @FIX ; Canned Hole cycles excluding longhand
%IF #MACRO=160 @FIX
%IF #MACRO=161 @FIX
%IF #MACRO=162 @FIX
%IF #MACRO=163 @FIX
* Not in Drill cycle
#CMOVE=#CMOVE+180
%GOTO @END

@FIX
%IF #X2RADIAL=#FUNNY %THEN #X2RADIAL=#X2DRIVEN
%IF #X2RADIAL=1 %THEN #XMOVE=#XMOVE*-1
%IF #X2RADIAL=1 %THEN #IVALUE=#IVALUE*-1
%GOTO @END

@SUBRAD
%IF #MACRO=159 @FIX2 ; Canned Hole cycles excluding longhand
%IF #MACRO=160 @FIX2
%IF #MACRO=161 @FIX2
%IF #MACRO=162 @FIX2
%IF #MACRO=163 @FIX2
* Not in Drill cycle
#CMOVE=#CMOVE+180
#CMOVE=360-#CMOVE
%GOTO @END

@FIX2
#CMOVE=360-#CMOVE
#XMOVE=#XMOVE*-1
%GOTO @END


@AXIAL
%IF SPINDLE=SPINDLEID2 @SUBAX
#XMOVE=#XMOVE*-1
#IVALUE=#IVALUE*-1
%GOTO @END

@SUBAX
%IF #MACRO=159 @FIX3 ; Canned Hole cycles excluding longhand
%IF #MACRO=160 @FIX3
%IF #MACRO=161 @FIX3
%IF #MACRO=162 @FIX3
%IF #MACRO=163 @FIX3
* Not in Drill cycle
#XMOVE=#XMOVE*-1
#CMOVE=360-#CMOVE
%GOTO @END

@FIX3
#CMOVE=#CMOVE+180
* Needs to be switchable - Lower Turret SS Driven Axial reverse
#XMOVE=#XMOVE*-1

@END
%IF #CANGLIMIT=0 @VERYEND
%IF #CMOVE>360 %THEN #CMOVE=#CMOVE-360
%IF #CMOVE<0 %THEN #CMOVE=#CMOVE+360
@VERYEND
%IF #RESET360=0 @VERYVERYEND
%IF #CMOVE=360 %THEN #CMOVE=0
@VERYVERYEND
%ENDM

*
********************************************************************************
*            CLAMP CONTROL
********************************************************************************

%PROCEDURE=SET_SPINDLE_CLAMP
%IF #PROCTRACE=1 %THEN $PROCEDURE=SET_SPINDLE_CLAMP:%CALL=ENTER_PROCEDURE
* Spindle clamping control for Daewoo
* Note that there is also a spindle brake routine used by other machines.
* <SET_SPINDLE_CLAMP Move [#MOVE=0]>
* Check for priority first

#SPINBRAKE=#BRAKEHOLD
%IF #PRIORITYMAIN<>TURRET @END

%IF CAXIS=0 @TURN ; Spindle running
%IF #MOVE=32 @END ; Baxis only, no change
%IF #MACRO=159 @DRILL ; Hole Cycles
%IF #MACRO=160 @DRILL ; Hole Cycles
%IF #MACRO=161 @DRILL ; Hole Cycles
%IF #MACRO=162 @DRILL ; Hole Cycles
%IF #MACRO=163 @DRILL ; Hole Cycles
%IF #MACRO=190 @TOOLCH ; Move to Home
%IF #MACRO=191 @TOOLCH ; Move to TC
%IF #MACRO=38 @MILLRAPC ; C axis moving
%IF #MACRO=58 @ROTATION ; End of Program
%IF #MOVE>15 @CMOVE ; C axis moving
%IF #GCODE=DATA1(60) @END ; Rapid XYZ, no change
%GOTO @MILLFEED

@CMOVE
%IF #GCODE=DATA1(60) @MILLRAPC
%GOTO @MILLFEED

* Machining conditions, select strategy
@TURN
* <Turn>
%IF #BRAKESTRAT1=0 @ROTATION
%IF #BRAKESTRAT1=1 @LOW
%IF #BRAKESTRAT1=2 @HIGH
%GOTO @ROTATION

@MILLFEED
%IF CAXIS<>2 @MILLAX
%IF MILLMODE=1 @RADPLAN
* <MillFeed Radial Rotary>
%IF #BRAKESTRAT2C=3 @AXPLAN
%IF #BRAKESTRAT2C=0 @ROTATION
%IF #BRAKESTRAT2C=1 @LOW
%IF #BRAKESTRAT2C=2 @HIGH
%GOTO @ROTATION

@RADPLAN
* <MillFeed Radial Planar>
%IF #BRAKESTRAT2B=3 @AXPLAN
%IF #BRAKESTRAT2B=0 @ROTATION
%IF #BRAKESTRAT2B=1 @LOW
%IF #BRAKESTRAT2B=2 @HIGH
%GOTO @ROTATION

@MILLAX
%IF MILLMODE=1 @AXPLAN
* <MillFeed Axial Rotary>
%IF #BRAKESTRAT2A=3 @AXPLAN
%IF #BRAKESTRAT2A=0 @ROTATION
%IF #BRAKESTRAT2A=1 @LOW
%IF #BRAKESTRAT2A=2 @HIGH
%GOTO @ROTATION

@AXPLAN
* <MillFeed Axial Planar>
%IF #BRAKESTRAT2=0 @ROTATION
%IF #BRAKESTRAT2=1 @LOW
%IF #BRAKESTRAT2=2 @HIGH
%GOTO @ROTATION

@MILLRAPC
* <MillRapC>
%IF #BRAKESTRAT3=0 @ROTATION
%IF #BRAKESTRAT3=1 @LOW
%IF #BRAKESTRAT3=2 @HIGH
%IF #BRAKESTRAT3=3 @END ;No Change
%GOTO @ROTATION

@DRILL
#CYCSPINBRAKE=#FUNNY
* <Drill>
%IF MILLMODE=0 @DRILLROT
%IF #BRAKESTRAT4=0 @ROTATION
%IF #BRAKESTRAT4=1 @LOW
%IF #BRAKESTRAT4=2 @HIGH
%GOTO @ROTATION

@DRILLROT
* <DrillRot>
%IF #BRAKESTRAT6=4 %THEN #BRAKESTRAT6=#BRAKESTRAT4
%IF #BRAKESTRAT6=0 @ROTATION
%IF #BRAKESTRAT6=1 @LOW
%IF #BRAKESTRAT6=2 @HIGH
* Strategy 3
#CYCSPINBRAKE=#BRAKEHIGH

#BRAKEHOLD=#FUNNY ; Force Output

%GOTO @ROTATION ; Set normal brake off

@TOOLCH
* <ToolChange>
%IF #BRAKESTRAT5=0 @ROTATION
%IF #BRAKESTRAT5=1 @LOW
%IF #BRAKESTRAT5=2 @HIGH
%IF #BRAKESTRAT5=3 @END ;No Change
%GOTO @ROTATION

* Spindle clamping actions
@HIGH
* <High>
* Set High
#SPINBRAKE=#BRAKEHIGH
%GOTO @END

@LOW
* <Low>
* Set Low
#SPINBRAKE=#BRAKELOW
%GOTO @END

@ROTATION
* <Run>
* Set clamp off - C movement
#SPINBRAKE=#BRAKEOFF

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


*
********************************************************************************
*            Set macro name for Siemens
********************************************************************************

%PROCEDURE=PT_SET_TCMACRO
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_TCMACRO:%CALL=ENTER_PROCEDURE
* Set ToolChange macro name for Siemens 840. Called by token
%IF TURRET=1 @LWR
$TCMAC=$TCU
%IF CAXIS>0 %THEN $TCMAC=$TCUD
%GOTO @END

@LWR
$TCMAC=$TCL
%IF CAXIS>0 %THEN $TCMAC=$TCLD

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM



%PROCEDURE=PT_SET_TLO_CANCEL
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_TLO_CANCEL:%CALL=ENTER_PROCEDURE

* Cancel TLO if in use
#CANCELCODE=#CANCELTLO
%IF #MACRO=51 @END
%IF #TLOMODAL=0 @END
%IF #TLOACTIVE<>1 %THEN #CANCELCODE=#FUNNY
#TLOACTIVE=0

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=PT_ADJUST_TLO
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ADJUST_TLO:%CALL=ENTER_PROCEDURE
#TLOACTIVE=1
* Added for mazak to add adjustment when on sub spindle
%IF CAXIS=0 @END ; Driven only
%IF #SUBTLOADJUST=#FUNNY @END
%IF #SUBTLOADJUST=0 @END
%IF SPINDLE=SPINDLEID1 @END

#HCODE=#HCODE+#SUBTLOADJUST
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM



;                                      
; Procedure = PT_TAPPING_REVERSE    
;                                      
%PROCEDURE=PT_TAPPING_REVERSE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_TAPPING_REVERSE:%CALL=ENTER_PROCEDURE
* Called by Attribute macro to reverse spindle when longhand tapping
%IF DWELL=#FUNNY %THEN DWELL=0


%IF FIELD5=2 %THEN %CALL=CODECON_TAPREV_T:%GOTO @ENDM
%IF FIELD5=1 %THEN %CALL=CODECON_TAPREV_B
#SKIPTAP=1
@ENDM
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_CONTROL_FEEDTYPE    
;                                      
%PROCEDURE=PT_CONTROL_FEEDTYPE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CONTROL_FEEDTYPE:%CALL=ENTER_PROCEDURE
* Force Feedtype if required
* Switches for Static (#FTYPETURN), Driven (#FTYPEMILL) and Driven tapping/threading (#FTYPETAP) tools
* Unchanged, Force FPR, Force FPM
* #THRDFLAG is set 0 at toolchange and 1 for tap cycle, 2 for threading cycle
* Feed is not set here for macro 187 thread milling
* Feed is not set here for sub-spindle movements
* #FEEDMODEHOLD is now set when token is used

%CALL=PT_SET_SPEED

#FEEDMODEGCODE=DATA1(46) ;	Feed / min
%IF FEEDTYPE=2 %THEN #FEEDMODEGCODE=DATA1(47) ;	Feed / rev


* Set feed
%IF #CONVERTEDMOVE<>1 @FEED

#FEED=#RAPIDFEEDRATE

%GOTO @CONTINUE  ; Converted rapid move

@FEED
%IF #MACRO=1 %THEN #FEED=NEXTFEED:%GOTO @CONTINUE  ; Uncoverted rapid
%IF #MACRO=44 %THEN #FEED=NEXTFEED:%GOTO @CONTINUE  ; Rapid to Y0
#FEED=FEED
@CONTINUE

*
* Turning moves and cycles
@TURN
* Static tools only
%IF #CONVERTEDMOVE=0 @TURN2
* Converted Rapid move
%IF #FTYPETURN>0 @TURN2
* Follow CAM type
%IF FEEDTYPE=2 @CONVERT_FPR
%GOTO @ENDM

@TURN2
%IF #THRDFLAG=2 @THREAD
* CHANGE 10/11/10
%IF #THRDFLAG=1 @FIXEDTAP
%IF #FTYPETURN=0 @ENDM
%IF #FTYPETURN=1 @CONVERT_FPR
%GOTO @CONVERT_FPM
*
* CHANGE 10/11/10
@FIXEDTAP
%IF FEEDTYPE=1 %THEN #FEED=#FEED/#RPM
%GOTO @JUMP2
*
@THREAD
%IF #CONVERTEDMOVE=1 @JUMP2 ; Converted move in FPM
#FEED=PITCH
%IF FEEDTYPE=1 %THEN #FEED=#FEED*SPEED
*
@JUMP2
%IF #FTYPETHRD=0 @ENDM
%IF #FTYPETHRD=1 @CONVERT_FPR
*
* FPM Wanted
@CONVERT_FPM
#FEEDMODEGCODE=DATA1(46)
%IF FEEDTYPE=1 @ENDM
%IF #CONVERTEDMOVE=1  @ENDM ; Converted move already FPM
*
@SET_FPM
#FEED=#FEED*#RPM
%GOTO @ENDM
*
@CONVERT_FPR
%IF #RPM=0 @ENDM ; Protect against spindle stop
* FPR Wanted
#FEEDMODEGCODE=DATA1(47)
%IF #CONVERTEDMOVE=1 @SET_FPR
%IF FEEDTYPE=2 @ENDM
*
@SET_FPR
#FEED=#FEED/#RPM
*
@ENDM
#CONVERTEDMOVE=0 ; Reset
%IF #FEED=0 %THEN #FEED=#FUNNY ; Suppress F0 output
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = DWELL_CONTROL     
;                                      

%PROCEDURE=DWELL_CONTROL
%IF #PROCTRACE=1 %THEN $PROCEDURE=DWELL_CONTROL:%CALL=ENTER_PROCEDURE
* Called by token from docking code constructors
* Only calls dwell codecon if not zero dwell
%IF DWELL=0 @END
%IF DWELL=#FUNNY @END

%CALL=CODECON_DWELL
* Output trace end mark when called as secondary code constructor
%IF $CONDEBUG=N @NO_CON-DEBUG
<***** End 	Code Constructor	:	Dwell	*****>
@NO_CON-DEBUG

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_SET_MULTIPOINT     
;                                      

%PROCEDURE=PT_SET_MULTIPOINT
%IF #PROCTRACE=1 %THEN $PROCEDURE=SET_MULTIPOINT:%CALL=ENTER_PROCEDURE
* Called from token, sets multipoint angle or code
* Setvar^#MPTCODE^0^Multipoint Tooling^YESNO^Convert Angle to Code
* Setvar^#MPTSTART^1^Multipoint Tooling^REAL^Code for angle 0
* Setvar^#MPTCODEINC^3^Multipoint Tooling^REAL^Code Increment
* Setvar^#MPTANGINC^6^Multipoint Tooling^REAL^Number of Codes
* <PT_SET_MULTIPOINT  [MULTIPOINT]>
#MULTIPOINT=ATCSPINANGLE
* <ATCSPINANGLE [ATCSPINANGLE=13]>
* %IF #MULTIPOINT>360 %THEN #MULTIPOINT=#MULTIPOINT-360
*
#TEMP=360/#MPTANGINC ; Permitted angular increment
#TEMP=#MULTIPOINT/#TEMP ; Number of increments
#MULTIPOINT=#TEMP+0.5
#MULTIPOINT=INT(#MULTIPOINT)
* <#TEMP=[#TEMP=13] #Mpt=[#MULTIPOINT=13]>
%IF #MPTCHECK=0 @OK
%IF #TEMP=#MULTIPOINT @OK
$WARNING="ERROR : Invalid multitool angle":%CALL=CODECON_WARNING
@OK
#TEMP=360/#MPTANGINC ; Permitted angular increment
* #MULTIPOINT=#MULTIPOINT*#TEMP
%IF #MPTCODE=1 @CODE
#MULTIPOINT=ATCSPINANGLE:%GOTO @END ; Use angle
@CODE
%IF #MPTCODE=0 @END
#MULTIPOINT=#MULTIPOINT*#MPTCODEINC
#MULTIPOINT=#MULTIPOINT+#MPTSTART

* <Check Result [#MULTIPOINT=13]>

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_CHECK_TAPPING         
;                                      

%PROCEDURE=PT_CHECK_TAPPING
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CHECK_TAPPING:%CALL=ENTER_PROCEDURE
* Check that cycle tap type matches tool tap type if set.
* USERVAR3 set by cycle 1=Float, 2=Rigid
* TAPTYPE set by Toolchange, 0=Unset, 1=Float, 2=Rigid

*  %IF DWELL=0 %THEN DWELL=#FUNNY
#TAPTYPE=USERVAR3 ; Cycle value
%IF TAPTYPE=0 @END ; Tool not set
%IF TAPTYPE=USERVAR3 @END ; Compatible
* TAPTYPE over-rules USERVAR3
#TAPTYPE=TAPTYPE
%IF #TAPWARN=0 @END
$WARNING="Warning - Tap cycle type incompatible":%CALL=CODECON_WARNING

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_ATTRIBUTE_CONTROL 
;                                      

%PROCEDURE=PT_ATTRIBUTE_CONTROL
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ATTRIBUTE_CONTROL:%CALL=ENTER_PROCEDURE
* Control processing of Attribute macro by SUBFUNCT value

%IF SUBFUNCT<200 %THEN %CALL=ATTRIBUTE_EXTENSION:%GOTO @END

%IF SUBFUNCT=201 %THEN %CALL=PT_TAPPING_REVERSE:%GOTO @END ;Reverse spindle, longhand tapping


%IF SUBFUNCT=205 %THEN %CALL=CODECON_CYCLE_STOP



@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                  
; Procedure = PT_SET_STOP     
;                                  

%PROCEDURE=PT_SET_STOP
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_STOP:%CALL=ENTER_PROCEDURE

* If called by token from Turn_Cycle_Stop code constructor
%IF #MACRO=4 %THEN #MCODE=DATA2(1):%GOTO @CALL
%IF #MACRO=501 %THEN #MCODE=DATA2(1):%GOTO @CALL

* If called by token from SYNCH code constructor
* Calls Stop code constructor if needed
%IF USERVAR9=1 @END ;No Stop
#MCODE=#FUNNY ; 1501
%IF #OUTPUTSTOP=0 @CALL ; 1501 suppress stop codes when spindle docking etc.
%IF USERVAR9=2 %THEN #MCODE=DATA2(1)   ; Program
%IF USERVAR9=3 %THEN #MCODE=DATA2(2) ; Optional

@CALL
%CALL=CODECON_PROGRAM-STOP


@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                  
; Procedure = PT_ROUND_VALUE     
;                                  


%PROCEDURE=PT_ROUND_VALUE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ROUND_VALUE:%CALL=ENTER_PROCEDURE
*  #TEMPROUND - value being worked on
*  #TEMPSIGN - holding variable for sign
* general purpose routine to round a value within precision limit for positive and negative values

%IF #TEMPROUND<0 @NEG
* Round positive values
#TEMPROUND=#TEMPROUND*#PRECISION
#TEMPROUND=#TEMPROUND+0.5
#TEMPROUND=INT(#TEMPROUND)
#TEMPROUND=#TEMPROUND/#PRECISION
%GOTO @END

@NEG
* Round negative values
#TEMPSIGN=-1
#TEMPROUND=#TEMPROUND*#TEMPSIGN
#TEMPROUND=#TEMPROUND*#PRECISION
#TEMPROUND=#TEMPROUND+0.5
#TEMPROUND=INT(#TEMPROUND)
#TEMPROUND=#TEMPROUND/#PRECISION
#TEMPROUND=#TEMPROUND*#TEMPSIGN

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                  
; Procedure = PT_ROUND_ANGLE     
;                                  


%PROCEDURE=PT_ROUND_ANGLE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ROUND_ANGLE:%CALL=ENTER_PROCEDURE
*  #TEMPROUND - value being worked on
*  #TEMPSIGN - holding variable for sign
* general purpose routine to round a value within precision limit for positive and negative values
* Angular values should not be subjected to linear precision, since the linear varies for inch and metric

%IF #TEMPROUND<0 @NEG
* Round positive values
#TEMPROUND=#TEMPROUND*#ANGPRECISION
#TEMPROUND=#TEMPROUND+0.5
#TEMPROUND=INT(#TEMPROUND)
#TEMPROUND=#TEMPROUND/#ANGPRECISION
%GOTO @END

@NEG
* Round negative values
#TEMPSIGN=-1
#TEMPROUND=#TEMPROUND*#TEMPSIGN
#TEMPROUND=#TEMPROUND*#ANGPRECISION
#TEMPROUND=#TEMPROUND+0.5
#TEMPROUND=INT(#TEMPROUND)
#TEMPROUND=#TEMPROUND/#ANGPRECISION
#TEMPROUND=#TEMPROUND*#TEMPSIGN

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;                                  
; Procedure = STRIP_BRACKETS     
;                                  

%PROCEDURE=STRIP_BRACKETS
%IF #PROCTRACE=1 %THEN $PROCEDURE=STRIP_BRACKETS:%CALL=ENTER_PROCEDURE
* Strip brackets from Tool description & comment

$TEMP=$TOOLDESCRIPTION
%CALL=STRIP_BRACKETS_2
$TOOLDESCRIPTION=$NEWSTRING
*
$TEMP=USERDEFINEDSTRING
%CALL=STRIP_BRACKETS_2
USERDEFINEDSTRING=$NEWSTRING

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=STRIP_BRACKETS_2
%IF #PROCTRACE=1 %THEN $PROCEDURE=STRIP_BRACKETS:%CALL=ENTER_PROCEDURE
* procedure to strip ( ) from string
#INPUTLEN=STRLENGTH($TEMP)
#TMP=0
$NEWSTRING=""
@START
#TMP=#TMP+1
%IF #TMP>#INPUTLEN @DONE
$CHAR=STRMID($TEMP,#TMP,#TMP)
*<Strip [#TMP=13] [$CHAR]>
%IF $CHAR="(" %THEN $CHAR=" "
%IF $CHAR=")" %THEN $CHAR=" "
$NEWSTRING=STRCAT($NEWSTRING,$CHAR)
%GOTO @START
@DONE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                  
; Procedure = PT_CHANGE_OFFSET     
;                                  

%PROCEDURE=PT_CHANGE_OFFSET
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CHANGE_OFFSET:%CALL=ENTER_PROCEDURE
* Called by CHANGEOFFSET token - sets variables for related tokens

%CALL=PT_TLO_SET
$IDINTEGREX2=""
%IF #HCODE=#HCODEHOLD @END

%CANCEL=#POSREP
#HCODEHOLD=#HCODE
%CALL=PT_ADJUST_TLO
$IDINTEGREX2=$IDINTEGREX  ; ID repeat for Integrex machines

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;                                      
; Procedure = PT_ARC_CENTRE_ROUNDING     
;                                      

%PROCEDURE=PT_ARC_CENTRE_ROUNDING
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_ARC_CENTRE_ROUNDING:%CALL=ENTER_PROCEDURE
* Rounds arc centre (IJK) values to required precision.
* Now called for Turn and CY

%IF #IVALUE=#FUNNY @JVAL
#TEMPROUND=#IVALUE
%IF #ARCTYPE=4 %THEN #TEMPROUND=#TEMPROUND*#ABSDIAM
%CALL=PT_ROUND_VALUE
#IVALUE=#TEMPROUND

@JVAL
@KVAL
%IF #KVALUE=#FUNNY @END
#TEMPROUND=#KVALUE
%CALL=PT_ROUND_VALUE
#KVALUE=#TEMPROUND

@END
%IF #ARCTYPE=3 @END2
* Reversals of centre point
%IF #IVALUE<>#FUNNY %THEN #IVALUE=#IVALUE*#XREVERSE
%IF #KVALUE<>#FUNNY %THEN #KVALUE=#KVALUE*#ZREVERSE

@END2
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;                                      
; Procedure = PT_VARI_SET     
;                                      

%PROCEDURE=PT_VARI_SET
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_VARI_SET:%CALL=ENTER_PROCEDURE
* Sets VARI code, machining conditions for S840
* Called by Token
* Vari values <10 deemed unnecessary as chf/chr handled by Edgecam

%IF SUBFUNCT=1 @TURN1
%IF SUBFUNCT=2 @FACE1
%IF SUBFUNCT=3 @TURN2
%IF SUBFUNCT=4 @FACE2
%IF SUBFUNCT=5 @TURN3
%IF SUBFUNCT=6 @FACE3
%IF SUBFUNCT=7 @TURN4
%IF SUBFUNCT=8 @FACE4
*
@TURN1
* External back turn
#VARI=11
%GOTO @END

@TURN2
* Internal bore
#VARI=17
%GOTO @END

@TURN3
* Internal back turn
#VARI=13
%GOTO @END

@TURN4
* External turn
#VARI=15
%GOTO @END

@FACE1
* Internal back face
#VARI=14
%GOTO @END

@FACE2
* External face
#VARI=16
%GOTO @END

@FACE3
*Internal face
#VARI=12
%GOTO @END

@FACE4
* External back face
#VARI=18

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

%PROCEDURE=PT_SET_CRC_ACTIVE
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_CRC_ACTIVE:%CALL=ENTER_PROCEDURE
* sets active flag on output for rapid checking

#COMPACTIVE=1
%IF #COMPGCODE=DATA1(85) %THEN #COMPACTIVE=0
%IF #COMPGCODE=#FUNNY %THEN #COMPACTIVE=0

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


%PROCEDURE=PT_CALL_DEVICE_SYNC
* Depending on configuration, this procedure may be a stub
* Trace output only used if procedure is active
%ENDM

%PROCEDURE=PT_CHECK_CONTENT
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_CHECK_CONTENT:%CALL=ENTER_PROCEDURE
* Called IF #LTSTART=1 to supppress output on unused turret
*

%IF #NUMTOOLS<1 @MASK
%GOTO @END

****************************************************************************************************
* Do not activate yet. Waiting investigation and fix for Macro look-ahead with more than 1 turret.
****************************************************************************************************

#MASKHOLD=MASK

%IF #MACRO=58 @ENDMAC     ; 1002
%IF #MACRO=57 @ENDMAC     ; 1002
%GOTO @START              ; 1002

* Processing for End Macro
@ENDMAC                   ; 1002
* Processing for End Macro
%IF #ACTIVE=1 @END
%GOTO @MASK

@START
* Processing for Start macro
#ACTIVE=1
%IF #NUMTOOLS>0 @END ; Tools found, process
#TEMP=0
#ACTIVE=0

@LOOP
#TEMP=#TEMP+1         ; start with second macro
*
%IF MACTYPE=58 @MASK  ; End
* %IF #TEMP>INSCOUNT @MASK ; longstop
%LOADINS=#TEMP
%IF MACTYPE=23 @LOOP  ; Synchronise
%IF MACTYPE=24 @LOOP  ; Priority
%IF MACTYPE=71 @LOOP  ; Attribute
%IF MACTYPE=251 @LOOP  ; Spindle select
%IF MACTYPE=252 @LOOP  ; Spindle control
; %IF MACTYPE=16 ;  End of turret processing
*
#ACTIVE=1
%GOTO @END ; Active macro found

****************************************************************************************************
@MASK
MASK=1
@END
* %LOADINS=INSNUM ; Reset macro status       ; removed 1002
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
*
*********************************
*
*  Code Wizard Templates
*  File Turn-Procedures-basic-2.cgi
*
*********************************
*
* Created from turn-procedures-basic.cgi 06 January 2015
* Placed under change control
* Gabriel Stein
*
* File contains procedures for basic turn templates.
* which are shared by Turn and ToM templates
*
*********************************
*
*  Macro related procedures
*
*********************************

* Version 2015.2
* 06/01/15 GST W66367 Separate common procedures for ToM and Turn
* 13/01/15 GST W66367 Restructure - second batch
* 19/01/15 GST W66367 Restructure - last batch
* 29/01/15 RHA W47884 fix G76 regression X sign, lower turret
* 04/02/15 RHA W47884 Correct I value, lower turret G76
* Version 2016.1
* 16/06/15 GST W83495 Allow thread turn on YZ plane
* 25/05/15 GST ECAM-321 Fix pitch for threads in YZ plane
*
********************************************************************************


;
;___________________________________________________________ Macro = 8 _____
;

%PROCEDURE=PMACRO-8
* Processing logic called by macro 8, Threading Cycle
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-8:%CALL=ENTER_PROCEDURE


* Longstop for unset variables
%IF TOOLANGLE1=#FUNNY %THEN TOOLANGLE1=0
%IF TOOLANGLE2=#FUNNY %THEN TOOLANGLE2=0
%IF USERVAR7=#FUNNY %THEN USERVAR7=0
%IF USERVAR8=#FUNNY %THEN USERVAR8=0
*
#NUMSTARTS=ABS(FIELD1)
%IF #NUMSTARTS=0 %THEN #NUMSTARTS=1
%IF #NUMSTARTS=#FUNNY %THEN #NUMSTARTS=1
* <#NUMSTARTS=[#NUMSTARTS=13] #XSTART=[#XSTART=0]>
*
#THRDFLAG=2 ; Threading flag for feedtype control

%CALL=PRIORITY_CHECK
@ToM1

#ATREFPT=0 ; Position checking

%CANCEL=PITCH  ;	Force pitch output on first block


%IF USERVAR7=1 %THEN #INTHRD=#TRUE:#PASSCNT=0:$CYCLE=G32:%NOCYCLE ; Longhand
%IF USERVAR7=2 %THEN #GCODE=DATA1(19):$CYCLE=G92:#INTHRD=#TRUE    ; Single block
%IF USERVAR7=3 %THEN #GCODE=DATA1(20):$CYCLE=G76:#INTHRD=#FALSE   ; Canned cycle


#CUTCOUNT=0         						;	Used for G92 : 5 vector cycle
#CHAMFSTAT=USERVAR6:#MINDOC=USERVAR3
*
#XCYCLESTART=XSTART*#DIAM
#ZCYCLESTART=ZSTART*#ZREVERSE

*Set total depth and number of cuts
#TOTALDEPTH=TOTALDEPTH
#NUMCUTS=FIELD6

%IF #CSS=1 %THEN #CSS=0:#CSSOUT=#TRUE              ;removed  #INDIAM=XSTART*2:
*
;    Calc Approach and Retract Angles
%CALL=THD_GET_ANGLES
*
@CHECKMODS
; Validate modifiers for canned cycle.
*								Longhand would never visit here since %NOCYCLE

%IF #GCODE=DATA1(20) @CHECKG76
*
************************************************************
@CHECKG92
* Single block threading
#XSTART=XSTART
#ZSTART=ZSTART
%IF FIELD12=0 %THEN $WARNING="Warning - Thread single block cycle doesn't support Finish at Cycle End":%CALL=CODECON_WARNING
%IF #COANG<>0 %THEN $WARNING="Warning - Thread single block cycle - retract angle must be zero":%CALL=CODECON_WARNING
%IF TOOLTYPE=0 @OK92
%IF TOOLTYPE=4 @OK92
%IF ZSTART=ZEND @OK92
$WARNING="ERROR : Tapered face threading is not supported."
%CALL=CODECON_WARNING
$WARNING="ERROR : Cycle output aborted."
%CALL=CODECON_WARNING
%GOTO @END
*
@OK92
%CALL=THD_PREPARATION
%CALL=PT_TURN_APPROACH ; Approach Move
%CALL=THD_INIT    ;    Initialize Thread Flags
%CALL=THD_CHAMFER ;    Chamfer M Code
#THDSTART=#FALSE
%IF FIELD5>1 %THEN #NUMVECS=1 %ELSE #NUMVECS=2
#INTHRD=#TRUE
%NOCYCLE

************************************************************
@CHECKG76
* Full canned cycle
* Number of starts = FIELD1
* Lead = PITCH
%IF FIELD5>1 %THEN #NUMVECS=1 %ELSE #NUMVECS=2
#XSTART=XSTART
#ZSTART=ZSTART

%IF FIELD12=0 %THEN $WARNING="Warning - Thread canned cycle doesn't support Finish at Cycle End":%CALL=CODECON_WARNING
%IF #NUMSTARTS=1 @OK76 ; Single start
%IF #ALLOWG76STARTS=1 @OK76A
%IF FIELD1<>1 %THEN $WARNING="Warning - Multi-start threading not supported via Canned Cycle":%CALL=CODECON_WARNING
%NOCYCLE
*
@OK76A
%IF FIELD1>0 @OK76
$WARNING="Warning - Alternate thread passes not supported via Canned Cycle":%CALL=CODECON_WARNING
%NOCYCLE
*
@OK76
* <OK76>
%CALL=THD_PREPARATION
%CALL=PT_TURN_APPROACH ; Approach Move
#XSTART=#XMOVE/#DIAM ; Reset start in line with THD_FIRST_MOVE
#ZSTART=#ZCYCLEAPP   ; Adjust for safe distance
* <Check [#XSTART=0]>
%CALL=THD_INIT    ;    Initialize Thread Flags
%CALL=THD_CHAMFER ;    Chamfer M Code
*
@AGAIN
#MACRO=8 ; Reset
%CALL=THD_OP_G76  ;    Check parameters (needed in loop
*
#GCODE=DATA1(20)
%CALL=CODECON_THREAD-CANNED-CYCLE
#XKEEP=#XMOVE*#XREVERSE
#ZKEEP=#ZMOVE/#ZREVERSE
#NUMSTARTS=#NUMSTARTS-1
*
#XSTART=#XSTART+#XTHRDSHIFT
#ZSTART=#ZSTART+#ZTHRDSHIFT

%IF #NUMSTARTS=0 @DONE
* Move to next start point
#THDSTART=#TRUE
#XMOVE=#XSTART
* #USER1=#XMOVE:<Check2 [#USER1=0]>
%IF TURRET=1 %THEN #XMOVE=ABS(#XMOVE):#XMOVE=#XMOVE*-1
#ZMOVE=#ZSTART
*
#MACRO=1 ; For move control
* #USER1=#XMOVE:<Move [#USER1=0]>
%CALL=PT_OUTPUT_RAPID ; Approach next cycle
* <Done>
%GOTO @AGAIN ; Repeat cycles

@DONE
#GCODE=DATA1(1) ; Reset

************************************************************

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;___________________________________________________________ Macro = 12 _____
;

%PROCEDURE=PMACRO-12
* Processing logic called by macro 15, Toolchange
%IF #PROCTRACE=1 %THEN $PROCEDURE=PMACRO-12:%CALL=ENTER_PROCEDURE

#INTHRD=#FALSE
%IF USERVAR1=#FUNNY %THEN USERVAR1=0 ; Check
%IF USERVAR1<>0 %THEN #COMPDCODE1=USERVAR1

%CALL=PT_TLO_SET

%IF XCPL<>#FUNNY %THEN #XKEEP=XCPL*#DIAM:#XMOVE=#XKEEP:<[#XMOVE=10]> ; Reset for effective datum shift
%IF YCPL<>#FUNNY %THEN #YKEEP=YCPL:#YMOVE=#YKEEP*#YREVERSE:<[#YMOVE=10]>
%IF ZCPL<>#FUNNY %THEN #ZKEEP=ZCPL:#ZMOVE=#ZKEEP*#ZREVERSE:<[#ZMOVE=10]>

%CALL=CODECON_SELECT-LENGTH-OFFSET

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;______________________________________ GET_QUADRANT __
;
%PROCEDURE=GET_QUADRANT
%IF #PROCTRACE=1 %THEN $PROCEDURE=GET_QUADRANT:%CALL=ENTER_PROCEDURE
* Set up the tool tip quadrant number used for tool store info.

%IF $MACHINE<>"GE1050" @STANDARD
* Based on the GE1050 convention.
%IF TOOLTYPE=0 %THEN #QUAD=2:%GOTO @END
%IF TOOLTYPE=1 %THEN #QUAD=1:%GOTO @END
%IF TOOLTYPE=2 %THEN #QUAD=8:%GOTO @END
%IF TOOLTYPE=3 %THEN #QUAD=7:%GOTO @END
%IF TOOLTYPE=4 %THEN #QUAD=6:%GOTO @END
%IF TOOLTYPE=5 %THEN #QUAD=5:%GOTO @END
%IF TOOLTYPE=6 %THEN #QUAD=4:%GOTO @END
%IF TOOLTYPE=7 %THEN #QUAD=3
%GOTO @END

@STANDARD
* Based on the Fanuc/Siemens convention.
%IF TOOLTYPE=0 %THEN #QUAD=8:%GOTO @END
%IF TOOLTYPE=1 %THEN #QUAD=4:%GOTO @END
%IF TOOLTYPE=2 %THEN #QUAD=5:%GOTO @END
%IF TOOLTYPE=3 %THEN #QUAD=1:%GOTO @END
%IF TOOLTYPE=4 %THEN #QUAD=6:%GOTO @END
%IF TOOLTYPE=5 %THEN #QUAD=2:%GOTO @END
%IF TOOLTYPE=6 %THEN #QUAD=7:%GOTO @END
%IF TOOLTYPE=7 %THEN #QUAD=3

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PT_THD_BLOCK _____
;
%PROCEDURE=PT_THD_BLOCK
* Output single block threading
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_THD_BLOCK:%CALL=ENTER_PROCEDURE
*	For G92 cycle, only output Cut pass
* <#PASSCNT=[#PASSCNT=13] #NUMVECS=[#NUMVECS=13]>
%IF #PASSCNT<>#NUMVECS @END

#THDBLKCOUNT=#THDBLKCOUNT+1
#THDPASSCOUNT=#THDPASSCOUNT+1
#THDPASSES=ABS(FIELD1) ; Number of starts
#THDPITCH=PITCH/#THDPASSES

%IF FIELD1<0 @ALTERNATE
* Not Alternated
%IF #THDBLKCOUNT<FIELD6 @G92OUT
%CALL=EVALUATE_MOVE
%CALL=CODECON_THREAD-G92-CYCLE

#TMP1=#XMOVE
#TMP2=#ZMOVE
#ZMOVE=#ZHOLD+#THDPITCH
#XMOVE=#XHOLD

%IF #THDPASSCOUNT<#THDLAST %THEN %CALL=PT_THD_RETURN

#XMOVE=#TMP1
#ZMOVE=#TMP2

#THDSHIFT=#THDSHIFT+1
#THDBLKCOUNT=0
%GOTO @END

@ALTERNATE
* Alternate passes
#THDSHIFT=#THDSHIFT+1
%CALL=EVALUATE_MOVE
%CALL=CODECON_THREAD-G92-CYCLE

#TMP1=#XMOVE
#TMP2=#ZMOVE
#ZMOVE=#ZHOLD+#THDPITCH
#XMOVE=#XHOLD
#TEMP=#THDPASSES-1
%IF #THDBLKCOUNT=#THDPASSES %THEN #ZMOVE=#ZHOLD-(#THDPITCH*#TEMP) ;Reset
%IF #THDPASSCOUNT<#THDLAST %THEN %CALL=PT_THD_RETURN

#XMOVE=#TMP1
#ZMOVE=#TMP2
%IF #THDBLKCOUNT<#THDPASSES @END
#THDSHIFT=-1
#THDBLKCOUNT=0

%GOTO @END

@G92OUT
%CALL=EVALUATE_MOVE
%CALL=CODECON_THREAD-G92-CYCLE


@END
%IF #THDBLKCOUNT=#THDLAST %THEN #ZHOLD=#ZMOVE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;___________________________________________________________ Procedure = PT_THD_BLOCK _____
;
%PROCEDURE=PT_THD_RETURN
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_THD_RETURN:%CALL=ENTER_PROCEDURE

* Manage convert to high feed for thread return moves

%IF #FEEDRAPIDS=1 @CONVERT_TO_FEED
%IF #RAPDIST=0 @MISS_CONVERT_TO_FEED
%CALL=PT_CALC_VECTOR_DISTANCE ; Sets #TMP
%IF #TMP>#RAPDIST @MISS_CONVERT_TO_FEED

@CONVERT_TO_FEED
* Convert Rapid to Feed Move
* #GCODE=DATA1(2)
#CONVERTEDMOVE=1
* #FEEDMODETEMP=#FEEDMODEGCODE	; Store current feed/rev - feed/min
* #FEEDMODEGCODE=DATA1(46)	;	Feed / Min for high feed move
%CALL=PT_CONTROL_FEEDTYPE
%CALL=CODECON_LINEAR-INTERPOLATION
* #FEEDMODEGCODE=#FEEDMODETEMP	;	Restore feed/rev - feed/min status
%GOTO @END

@MISS_CONVERT_TO_FEED
#GCODE=DATA1(1)
%CALL=CODECON_RAPID-MOVE

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = THD_APPR_POS _____
;

%PROCEDURE=THD_APPR_POS
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_APPR_POS:%CALL=ENTER_PROCEDURE
* Calculate thread approach position, allowing for taper and XSAFE

* Adjust for Z safe distance
* #ZCYCLEAPP=#ZSTART+ZSAFE
* %IF ZSTART<ZEND %THEN #ZCYCLEAPP=#ZSTART-ZSAFE

* #XCYCLEAPP=XSTART

* New Setting of Approach Position
#YMOVE=0 ; force for ToM
#ZCYCLEAPP=ZRAPIDAPPROACH
#XCYCLEAPP=XRAPIDAPPROACH

* Set #THRDINTFLG
* NB TOOLTYPE = 0 (external) or 4 (internal)
* If tool tip crosses centreline this setting is reversed.
#THRDINTFLG=0 ; External
%IF TURRET=1 @LWRINT
* Upper turret
%IF XEND<0 @REVTYPE
%IF TOOLTYPE=4 %THEN #THRDINTFLG=1 ; Internal
%GOTO @CHECK_TAPER
@REVTYPE
* Crossed centreline
%IF TOOLTYPE=0 %THEN #THRDINTFLG=1 ; Internal
%GOTO @CHECK_TAPER

@LWRINT
* Lower turret
%IF XEND>0 @REVTYPE1
%IF TOOLTYPE=4 %THEN #THRDINTFLG=1 ; Internal
%GOTO @CHECK_TAPER
@REVTYPE1
* Crossed centreline
%IF TOOLTYPE=0 %THEN #THRDINTFLG=1 ; Internal

@CHECK_TAPER
%IF #NUMVECS=4 @CONTINUE

%IF #GCODE=DATA1(18) @CONTINUE

;
;   Get ABS Bearing of Thread Stroke
;
#XTEMP=XSTART-XEND:#ZTEMP=ZSTART-ZEND	;	X and Z components of move

%CALL=MTH-LINBRG
* <#Bearing =[#BEARING=13]>
;
;   Determine Z direction of Thread Stroke
;
%IF #BEARING=0 @END   ; Parallel
%IF #BEARING=180 @END ; Parallel
%IF #BEARING>270 @BACKWARDS
%IF #BEARING<90 @BACKWARDS
%IF TOOLTYPE=0 %THEN #PERPBRG=#BEARING-90
%IF TOOLTYPE=4 %THEN #PERPBRG=#BEARING+90
%GOTO @GOT-IT
@BACKWARDS
%IF TOOLTYPE=0 %THEN #PERPBRG=#BEARING+90
%IF TOOLTYPE=4 %THEN #PERPBRG=#BEARING-90
@GOT-IT
%IF #PERPBRG>360 %THEN #PERPBRG=#PERPBRG-360
%IF #PERPBRG<0 %THEN #PERPBRG=#PERPBRG+360
;
;   Determine Angle and X point to Calc High point from
;

; Force X start/end to be positive then adjust after calc. Fix for Lower turret SME

#TMP1=XSTART:#TMP2=XEND
XSTART=ABS(XSTART):XEND=ABS(XEND)

%IF #THRDINTFLG=1 @CHKID
* External
%IF XEND<XSTART %THEN #ANG=#CIANG:#XPOINT=XSTART %ELSE #ANG=#COANG:#XPOINT=XEND
#BRG=#ANG+90:#BEARING=#BRG-#PERPBRG
%GOTO @CHKDIR

@CHKID
* Internal
%IF XEND>XSTART %THEN #ANG=#CIANG:#XPOINT=XSTART %ELSE #ANG=#COANG:#XPOINT=XEND
#BRG=270-#COANG:#BEARING=#PERPBRG-#BRG

@CHKDIR
* %GOTO @END
* W47884 might be able to remove following code - await test results
*
*   Calc distance from X point to xsafe
*
* <**** PB = [#PERPBRG=13]  CO = [#COBRG=13]  DIFF = [#BEARING=13] ****>
* #COS=COS(#BEARING)
* DEV00022626 Divide by zero error replace line
* #TMP=ABS(#BEARING)
* #TMP=ABS(#COS)
* <#Bearing =[#BEARING=13] #COS=[#COS=13]>
* %IF #TMP<#INCR %THEN #COLEN=XSAFE %ELSE #COLEN=XSAFE/#COS
* <**** LN = [#COLEN=13] ****>
*
*   Calc X coord of high point
*
XSTART=#TMP1:XEND=#TMP2 ; Reset values - needed 2901
* #XTEMP=SIN(#BRG)
* #XSAFE=#XTEMP*#COLEN
* XSAFE=ABS(#XSAFE)
*
* #XCYCLEAPP=#XPOINT
* %IF XSTART<0 %THEN #XCYCLEAPP=#XCYCLEAPP*-1

@CONTINUE
* <Continue>



* Adjust for X safe distance
* <Continue  #XCYCLEAPP=[#XCYCLEAPP=0]>
* %IF XEND<0 @BOTTOMSIDE

* @TOPSIDE
* <Topside XSTART=[XSTART=13] XSAFE=[XSAFE=13] XEND=[XEND=13] #THRDINTFLG=[#THRDINTFLG=13]>
* Natural side of centreline for turret
* %IF #THRDINTFLG=1 @INTERNAL1
* <External>
* #XCYCLEAPP=#XCYCLEAPP+XSAFE
* %GOTO @END
* @INTERNAL1
* <Internal>
* #XCYCLEAPP=#XCYCLEAPP-XSAFE
* %GOTO @END

* @BOTTOMSIDE
* <Bottomside>
* Other side of centreline from turret
* Note internal/external tool types interchanged
* %IF #THRDINTFLG=1 @INTERNAL2
* <External>
* #XCYCLEAPP=#XCYCLEAPP-XSAFE
* %GOTO @END
* @INTERNAL2
* <Internal>
* #XCYCLEAPP=#XCYCLEAPP+XSAFE
* %GOTO @END

@END
* <End  #XCYCLEAPP=[#XCYCLEAPP=0]>
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Procedure = THD_CALC_THDANGLE _____
;
%PROCEDURE=THD_CALC_THDANGLE
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_CALC_THDANGLE:%CALL=ENTER_PROCEDURE

*
#THRDANGLE=(TOOLANGLE1-TOOLANGLE2):%IF #THRDANGLE<0 %THEN #THRDANGLE=#THRDANGLE*-1

* Check
%IF #G76CHECK=0 @END
%IF #G76CHECK=2 @END
%IF #THRDANGLE=80 @END
%IF #THRDANGLE=60 @END
%IF #THRDANGLE=55 @END
%IF #THRDANGLE=30 @END
%IF #THRDANGLE=29 @END
%IF #THRDANGLE=0 @END
$WARNING="Warning - Tool Angle must be 80, 60, 55, 30, 29, or 0":%CALL=CODECON_WARNING

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Procedure = THD_CALC_IKPITCH _____
;
%PROCEDURE=THD_CALC_IKPITCH
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_CALC_IKPITCH:%CALL=ENTER_PROCEDURE
*
#XTHRDSHIFT=0
#ZTHRDSHIFT=0

#XTHRDSHIFT=0:#ZTHRDSHIFT=0


#TMP=#XMOVE-#XHOLD:#TMP=(ABS(#TMP))/#DIAM
#TMP1=#ZMOVE-#ZHOLD:#TMP1=ABS(#TMP1)
%IF #INCRXYZ=1 %THEN #TMP=#XMOVE/#DIAM:#TMP=ABS(#TMP):#TMP1=ABS(#ZMOVE)
@XYZTHREADDONE
%IF #TMP<#INCR %THEN #IPITCH=#FUNNY:#KPITCH=PITCH:#ZTHRDSHIFT=#KPITCH:%GOTO @END
%IF #TMP1<#INCR %THEN #KPITCH=#FUNNY:#IPITCH=PITCH:#XTHRDSHIFT=#IPITCH:%GOTO @END
%IF #TMP1>#TMP @ZMAJOR
@XMAJOR
#KPITCH=#TMP1/#TMP
#KPITCH=#KPITCH*PITCH:#IPITCH=PITCH
#XTHRDSHIFT=#IPITCH
%GOTO @END
@ZMAJOR
#IPITCH=#TMP/#TMP1
#IPITCH=#IPITCH*PITCH:#KPITCH=PITCH
#ZTHRDSHIFT=#KPITCH
@END
*
#IPITCH=#IPITCH*#IKDIAM
#ZTHRDSHIFT=#ZTHRDSHIFT/#NUMSTARTS  ; Pitch
#XTHRDSHIFT=#XTHRDSHIFT/#NUMSTARTS

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = THD_CHAMFER _____
;
%PROCEDURE=THD_CHAMFER
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_CHAMFER:%CALL=ENTER_PROCEDURE

*
%IF #GCODE=DATA1(18) @END			;	Longhand mode
%IF #CHAMFSTAT=1 %THEN #CHAMFMCODE=DATA2(32) %ELSE #CHAMFMCODE=DATA2(33)
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = THD_PREPARATION_____
;
%PROCEDURE=THD_PREPARATION
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_PREPARATION:%CALL=ENTER_PROCEDURE

#THDSTART=#TRUE
*    Calc number of moves in cycle
%CALL=THD_GET_VEC_CNT
*  #THREADING should only be #TRUE if we have consecutive THREAD commands
*  Sets up I & K pitch tokens in case used. Fanuc uses PITCH
%CALL=THD_CALC_IKPITCH

%CALL=THD_APPR_POS ; Adjusts for safe start

@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PT_TURN_APPROACH_____
;
%PROCEDURE=PT_TURN_APPROACH
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_TURN_APPROACH:%CALL=ENTER_PROCEDURE
* Calc Approach moves for Canned Cycles
* X then Z or Z then X, as required

%IF FIELD7=#FUNNY @NOSAFE
%IF FIELD7=0 @NOSAFE  ; Avoid regression

%IF XFIRST=1 @XFIRST ; Use cycle flag if available
%IF XFIRST=0 @ZFIRST

#THRDINTFLG=0 ; External
%IF TOOLTYPE=4 %THEN #THRDINTFLG=1:%GOTO @XFIRST ; Internal

@ZFIRST
#XMOVE=#XKEEP*#INVDIAM
%IF #XCYCLEAPP>#XMOVE @XFIRST ; Override to lift in X
#ZMOVE=#ZCYCLEAPP
%GOTO @LEG_ONE


@XFIRST
* <Internal Bottom X then Z>
#ZMOVE=#ZKEEP
#XMOVE=#XCYCLEAPP

@LEG_ONE
#MACRO=1
#PASSCNT=#FUNNY
%CALL=PT_OUTPUT_RAPID
* Safe complete

@NOSAFE
*    Output Approach Move
#THDSTART=#TRUE
#ZMOVE=#ZCYCLEAPP
#XMOVE=#XCYCLEAPP
#MACRO=1
#PASSCNT=#FUNNY
%CALL=PT_OUTPUT_RAPID
*<*** Thread start complete>
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = THD_GET_ANGLES _____
;
%PROCEDURE=THD_GET_ANGLES
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_GET_ANGLES:%CALL=ENTER_PROCEDURE


#TMP=TOOLANGLE1-TOOLANGLE2:#TMP=ABS(#TMP)
%IF #TMP>180 %THEN #TMP=#TMP-180
#TMP=#TMP/2
%IF ANGLE=#FUNNY %THEN ANGLE=#TMP
%IF STANGLE=#FUNNY %THEN STANGLE=#TMP
#CIANG=ANGLE:#COANG=STANGLE
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Procedure = THD_GET_VEC_CNT _____
;
%PROCEDURE=THD_GET_VEC_CNT
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_GET_VEC_CNT:%CALL=ENTER_PROCEDURE

#NUMVECS=5
#TMP=XSTART-XEND:#TMP=ABS(#TMP):%IF #TMP<#INCR %THEN #NUMVECS=4
#TMP=ZSTART-ZEND:#TMP=ABS(#TMP):%IF #TMP<#INCR %THEN #NUMVECS=4

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Procedure = THD_INIT _____
;
%PROCEDURE=THD_INIT
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_INIT:%CALL=ENTER_PROCEDURE

;
;         #THREADING is #TRUE if we have consecutive THREAD commands
%IF #THREADING<>#TRUE %THEN %CANCEL=#PITCH
#CUTCOUNT=0
#PASSCNT=0
#THDBLKCOUNT=0 ; Blocks per thread count
#THDPASSCOUNT=0 ; Total passes count
* <F1= [FIELD1=0]>
* <F6= [FIELD6=0]>
#THDLAST=FIELD1*FIELD6 ; Total passes
#THDLAST=ABS(#THDLAST)
#THDSHIFT=0
%IF FIELD1<2 %THEN #THDSHIFT=-1  ;Alternate passes
#THREADING=#TRUE
#PITCH=PITCH
#ITAPER=(XEND-XSTART)*#IKDIAM
%IF TURRET=1 %THEN #ITAPER=#ITAPER*#X2REVERSE ; 0402
#KTAPER=ZEND-ZSTART
*%DONT-OUTPUT=#FEED
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
;
;___________________________________________________________ Procedure = THD_OP_G76 _____
;
%PROCEDURE=THD_OP_G76
%IF #PROCTRACE=1 %THEN $PROCEDURE=THD_OP_G76:%CALL=ENTER_PROCEDURE


#TMP=TOOLANGLE1-TOOLANGLE2
#TMP=ABS(#TMP)
%IF #TMP>180 %THEN #TMP=#TMP-180
%IF ANGLE=#FUNNY %THEN ANGLE=#TMP/2
%IF STANGLE=#FUNNY %THEN STANGLE=#TMP
#CIANG=ANGLE
#COANG=STANGLE

*************************************
%IF #G76CHECK=0 @OK
%IF #G76CHECK=1 @OK

* Check approach angle against half angles in Fanuc permitted list
%IF #CIANG=40 @OK
%IF #CIANG=30 @OK
%IF #CIANG=27.5 @OK
%IF #CIANG=15 @OK
%IF #CIANG=14.5 @OK
%IF #CIANG=0 @OK
$WARNING="Warning - Chase-in must be 80, 60, 55, 30, 29, or 0":%CALL=CODECON_WARNING
#CIANG=0									;	Force to 0

@OK
#IVALUE=XSTART-XEND:%IF #DIAM<0 %THEN #IVALUE=#IVALUE*-1
#TMP=ABS(#IVALUE):%IF #TMP<#INCR %THEN #IVALUE=#FUNNY
#DIRCUT=1
%IF TOOLTYPE=1 %THEN %GOTO @GOTTYPE
%IF TOOLTYPE=0 %THEN %GOTO @GOTTYPE
%IF TOOLTYPE=7 %THEN %GOTO @GOTTYPE
#DIRCUT=-1
%IF TOOLTYPE=5 %THEN %GOTO @GOTTYPE
%IF TOOLTYPE=4 %THEN %GOTO @GOTTYPE
%IF TOOLTYPE=3 %THEN %GOTO @GOTTYPE

;<***** Unsupported Tooltype *****>
$WARNING="Warning - Unsupported tool type for threading cycle":%CALL=CODECON_WARNING
@GOTTYPE

%IF #DIAM<0 %THEN #DIRCUT=#DIRCUT*-1		;	reverse sign of cut depth

#KVALUE=TOTALDEPTH*#DIRCUT:#KVALUE=ABS(#KVALUE):#TMP=TOTALDEPTH

*Set target depth
#XMOVE=XEND
%IF #THRDROOT=1 @DONE
*Upper Turret (0)
%IF TURRET=1 @LOWER
%IF TOOLTYPE=4 %THEN #XMOVE=XEND+TOTALDEPTH %ELSE #XMOVE=XEND-TOTALDEPTH
%GOTO @DONE
@LOWER
*Lower Turret (1)
%IF TOOLTYPE=4 %THEN #XMOVE=XEND-TOTALDEPTH %ELSE #XMOVE=XEND+TOTALDEPTH
@DONE

#XMOVE=#XMOVE*#DIAM

#ZMOVE=ZEND*#ZREVERSE:#PITCH=PITCH:#GCODE=DATA1(20)
%CANCEL=#XMOVE,#ZMOVE,#PITCH,#GCODE
*
#TMP=FIELD4*FPASS
#TMP1=TOOLANGLE1-TOOLANGLE2
#TMP1=ABS(#TMP1)
%IF #TMP1>180 %THEN #TMP1=#TMP1-180
#TMP1=#TMP1/2
%IF FPASS=#FUNNY %THEN FPASS=0
%IF FIELD4=#FUNNY %THEN FIELD4=0
@END
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
*
*	*********************************************
*	Procedures for performing calculations		*
*	*********************************************
*
;
;___________________________________________________________ Procedure = MTH-HYPE _____
;
%PROCEDURE=MTH-HYPE
%IF #PROCTRACE=1 %THEN $PROCEDURE=MTH_HYPE:%CALL=ENTER_PROCEDURE


#TMP1=#XTEMP^2
#TMP2=#ZTEMP^2
#TEMP=#TMP1+#TMP2
#TEMP=SQR(#TEMP)

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM
*

;
;___________________________________________________________ Procedure = MTH-LINBRG _____
;
%PROCEDURE=MTH-LINBRG
%IF #PROCTRACE=1 %THEN $PROCEDURE=MTH_LINBRG:%CALL=ENTER_PROCEDURE

;=============================================================================
;   Procedure : LINBRG
;   Purpose   : Calculate the absolute bearing between 2 points.
;   Recieves  : #ZST, #XST, #ZND, #XND,
;   Returns   : #BEARING
;=============================================================================
%CALL=MTH-HYPE						;	Calculate the hypoteneuse of the triangle
#BEARING=#XTEMP
%IF #TEMP>0 %THEN #BEARING=#BEARING/#TEMP %ELSE %GOTO @END
#BEARING=ASIN(#BEARING)
%IF #XTEMP<0 @BRGNEG
%IF #ZTEMP<0 %THEN #BEARING=180-#BEARING
%GOTO @END
@BRGNEG
%IF #BEARING=270 @END ;FIX FOR ASIN BUG
%IF #ZTEMP>0 %THEN #BEARING=360+#BEARING %ELSE #BEARING=180-#BEARING
@END
%IF #BEARING>=360 %THEN #BEARING=#BEARING-360

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

;
;___________________________________________________________ Procedure = PT_GET-TNRXZ _____
;
%PROCEDURE=PT_GET-TNRXZ
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_GET-THRXZ:%CALL=ENTER_PROCEDURE


#TNRX=0:#TNRZ=0

%IF TOOLTYPE=0 %THEN #TNRX=TOOLRAD:#TNRZ=0:%GOTO @END
%IF TOOLTYPE=1 %THEN #TNRX=TOOLRAD:#TNRZ=-TOOLRAD:%GOTO @END
%IF TOOLTYPE=2 %THEN #TNRX=0:#TNRZ=-TOOLRAD:%GOTO @END
%IF TOOLTYPE=3 %THEN #TNRX=TOOLRAD*-1:#TNRZ=-TOOLRAD:%GOTO @END
%IF TOOLTYPE=4 %THEN #TNRX=TOOLRAD*-1:#TNRZ=0:%GOTO @END
%IF TOOLTYPE=5 %THEN #TNRX=TOOLRAD*-1:#TNRZ=TOOLRAD:%GOTO @END
%IF TOOLTYPE=6 %THEN #TNRX=0:#TNRZ=TOOLRAD:%GOTO @END
%IF TOOLTYPE=7 %THEN #TNRX=TOOLRAD:#TNRZ=TOOLRAD
@END

%IF TURRET=1 %THEN #TNRX=#TNRX*-1	;	accomodate for multiple turrets

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM


;
;_____________________________________________________ Procedure = PT_SET_TOOL_TURN _____
;
%PROCEDURE=PT_SET_TOOL_TURN
%IF #PROCTRACE=1 %THEN $PROCEDURE=PT_SET_TOOL_TURN:%CALL=ENTER_PROCEDURE
*  Routine to reset MOVE and KEEP values after a Turning Tool Change
*  Modified from PT_SET_TOOL_POS Jan 2010

#XKEEP=XCPL*#ABSDIAM
#ZKEEP=ZCPL
*
* Set Precision
#TEMPROUND=#XKEEP
%CALL=PT_ROUND_VALUE
#XKEEP=#TEMPROUND
*
#TEMPROUND=#ZKEEP
%CALL=PT_ROUND_VALUE
#ZKEEP=#TEMPROUND

#XMOVE=#XKEEP*#XREVERSE
* Remove duplicate reversal
*#XMOVE=#XMOVE*#XREVERSE
#ZMOVE=#ZKEEP*#ZREVERSE
<[#XMOVE=10][#ZMOVE=10]>    ; Initialise


@END
%IF #PROCTRACE=0 @ENDALL
%IF #TRSTARTS=0 @CALL
* Output initial position
#TRX=XCPL
#TRZ=ZCPL
<* Current CPL position [#TRX=0] [#TRZ=2]>
#TRX=#XMOVE
#TRZ=#ZMOVE
<* Current Move set at [#TRX=0] [#TRZ=2]>

@CALL
%CALL=EXIT_PROCEDURE

@ENDALL
%ENDM


;                                      
; Procedure = PRIORITY_CHECK    
;                                      
%PROCEDURE=PRIORITY_CHECK
%IF #PROCTRACE=1 %THEN $PROCEDURE=PRIORITY_CHECK:%CALL=ENTER_PROCEDURE
* Check Spindle Priority when tapping or threading
*<Spindle= [SPINDLE=0]   [SPINDLEID1=1]   [SPINDLEID2=1]>
*<Turret [TURRET=0]>
*<Priority Main [PRIORITYMAIN=0]   Sub [PRIORITYSUB=0]>

%IF SPINDLE=SPINDLEID2 @SUBCHECK
*Main
%IF #PRIORITYMAIN=TURRET @SPINDLE_OK
%GOTO @SPINDLE_ERROR

@SUBCHECK
*Sub Spindle
%IF #PRIORITYSUB=TURRET @SPINDLE_OK

@SPINDLE_ERROR
$WARNING="ERROR : Thread turn or Tapping without control of spindle speed !"
%CALL=CODECON_WARNING
%NOCYCLE

@SPINDLE_OK
%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

*
*
*********************************
*
*  Code Wizard Templates
*  File Turn-Procedures-4CY.cgi
*
*********************************
*

***********************************************************************
*
*********************************
*
*  Code Wizard Templates
*  File Turn-4-Axis-ISO.cgi
*
*********************************
*




*
*

*
*
*********************************
*
*  Code Wizard Templates
*  File Turn-Procedures-CYB.cgi
*
*********************************



#SETCHUCKCOOL=#AUTOCHUCKFACE     ; Coolant taps as required
#SETSPINDLECOOL=#AUTOSPINDLE
#SETTURRETCOOL=#AUTOTURRET
@NOTAUTO

*Manual Over-ride
* %CALL=PT_COOL_CANCEL
%CALL=PT_THROUGH_COOL
%CALL=PT_SET_COOLANT_FLOW
%CALL=PT_SET_COOLANT_TAPS


* Set Angle at Tool Change


























*
*********************************
*
*  Code Wizard Templates
*  File Turn-Macros-CYB-ISO.cgi
*
*********************************





























































*
*
*********************************
*
*  Code Wizard Templates
*  File Turn-Procedures-Sub-Spindle.cgi
*
*********************************
*



*
*********************************
*
*  Code Wizard Templates
*  File Turn-SubSpin-ISO.cgi
*
*********************************





*
**************************************************************************
*   Machine independant Code Generator include file
*
*   Filename:	Whiteboard.cgi
*	Author:		RHA
*   Date:       09 December 2005
*
* New file for all adaptive template
**************************************************************************
*   Change History
* Version 10.5
*          FIRST ISSUE
* 14/02/05 RHA DEV00016309 Fix long lines for codecon.txt
* Version 12.5
* 19/02/08 RHA DEV00022469 Add note prohibiting duplicate macros and procedures
* Version 2009.2
* 26/01/09 RHA DEV00025914 Add attribute_extension to macros and whiteboard
* 27/01/09 RHA DEV00025914 Put new procedure in new code constructor - allows CGD compilation
* 17/02/09 RHA DEV00025914 Prevent user deletion of new procedure
* Version 2013.2
* 29/11/12 RHA W54439 Make Customisation Whiteboard and PDI attribute user tokens green
* Version 2014.2
* 05/03/14 RHA W55288 Add Whiteboard_breakout Code Constructor
* 13/03/14 RHA W55288 Add Default Sequence to breakout Code Constructor
*
**************************************************************************






*	*****************************************
*	*	Tab Name	:	Hackers Corner	*
*	*****************************************
*
%PROCEDURE=ATTRIBUTE_EXTENSION
%IF #PROCTRACE=1 %THEN $PROCEDURE=ATTRIBUTE_EXTENSION:%CALL=ENTER_PROCEDURE

;Sequence Definition^<3797>PDI Attribute Extension^-1^<903>Miscellaneous^
;Use Tokens^IF_CSS^IF_RPM^DELETE^BLKNUM^SAFEBLKNUM^ABS-INC^TOOLDESCR^TOOLTYPE^COMMENT^TURRETNO^TURRETNAME^FEEDMODEGCODE^FEEDGCODE^RAPIDGCODE^EXACTSTOPGCODE^XMOVE^YMOVE^ZMOVE^COMPGCODE^CRC REGISTER^FEED^SPEED^SPINDIR^GEARMCODE^LENGTHOFFSET^SPEED^NEXTTOOL^COOLANT^COOLANT OFF^COOLTHROTOOL^COMPGCODE^COMP OFF^WORKGCODE^ZGAUGELENGTH^XGAUGELENGTH^TOOLDIAM^UNITSGCODE^PLANEGCODE^CSSGCODE^CSSRAD^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^;CODE:* Procedure for additional attribute function in connection with PDI customisation
;TEXT^This procedure is called from Macro 71 if SUBFUNCT<200
;TEXT^Allows customisation in connection with PDIs
;TEXT^Note that 5AX uses SUBFUNCT 2,3 and Thread Mill uses 2,10
;TEXT^It is the users responsibility to ensure that TOKENS are correct in the
;TEXT^   context in which they are used.
* Procedure for additional attribute function in connection with PDI customisation





%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM

%PROCEDURE=CODECON_WHITEBOARD
;Sequence Definition^<2845>Customisation Whiteboard^-1^<903>Miscellaneous^
;Use Tokens^IF_CSS^IF_RPM^DELETE^BLKNUM^SAFEBLKNUM^ABS-INC^TOOLDESCR^TOOLTYPE^COMMENT^TURRETNO^TURRETNAME^FEEDMODEGCODE^FEEDGCODE^RAPIDGCODE^EXACTSTOPGCODE^XMOVE^YMOVE^ZMOVE^COMPGCODE^CRC REGISTER^FEED^SPEED^SPINDIR^GEARMCODE^LENGTHOFFSET^SPEED^NEXTTOOL^COOLANT^COOLANT OFF^COOLTHROTOOL^COMPGCODE^COMP OFF^WORKGCODE^ZGAUGELENGTH^XGAUGELENGTH^TOOLDIAM^UNITSGCODE^PLANEGCODE^CSSGCODE^CSSRAD^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^;CODE:* Terminate the procedure defining the code_constructor
;Default Sequence^;CODE:%ENDM
;Default Sequence^;CODE:
;Default Sequence^;CODE:
;Default Sequence^;CODE:%PROCEDURE=NEW_FUNCTION_1
;Default Sequence^;CODE:%IF #PROCTRACE=1 %THEN $PROCEDURE=NEW_FUNCTION_1:%CALL=ENTER_PROCEDURE
;Default Sequence^;CODE:
;Default Sequence^;CODE:* Dummy procedure for customised function
;Default Sequence^;CODE:
;Default Sequence^;CODE:%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
;Default Sequence^;CODE:%ENDM
;Default Sequence^;CODE:
;Default Sequence^;CODE:
;Default Sequence^;CODE:
;Default Sequence^;CODE:* Example declaration
;Default Sequence^;CODE:%DECLARE=#NEWVARIABLE
;Default Sequence^;CODE:
;Default Sequence^;CODE:%PROCEDURE=NEW_FUNCTION_2
;Default Sequence^;CODE:%IF #PROCTRACE=1 %THEN $PROCEDURE=NEW_FUNCTION_2:%CALL=ENTER_PROCEDURE
;Default Sequence^;CODE:
;Default Sequence^;CODE:* Dummy procedure for customised function
;Default Sequence^;CODE:
;Default Sequence^;CODE:%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
;Default Sequence^;CODE:* %ENDM for the last procedure is contained within the code_constructor
;TEXT^Dummy CODE_CONSTRUCTOR for customisation procedures etc.
;TEXT^Not called by any Code Generator functions
;TEXT^Duplicate macro and procedure definitions are not permitted
;TEXT^It is the users responsibility to ensure that TOKENS are correct in the
;TEXT^   context in which they are used.
;TEXT^A CODE_CONSTRUCTOR is a PROCEDURE. The matching of %PROCEDURE and %ENDM
;TEXT^   statements must be preserved.
;TEXT^Instructions such as %DECLARE should only be used between procedures.
* Terminate the procedure defining the code_constructor
%ENDM


%PROCEDURE=NEW_FUNCTION_1
%IF #PROCTRACE=1 %THEN $PROCEDURE=NEW_FUNCTION_1:%CALL=ENTER_PROCEDURE

* Dummy procedure for customised function

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
%ENDM



* Example declaration
%DECLARE=#NEWVARIABLE

%PROCEDURE=NEW_FUNCTION_2
%IF #PROCTRACE=1 %THEN $PROCEDURE=NEW_FUNCTION_2:%CALL=ENTER_PROCEDURE

* Dummy procedure for customised function

%IF #PROCTRACE=1 %THEN %CALL=EXIT_PROCEDURE
* %ENDM for the last procedure is contained within the code_constructor





%ENDM

%PROCEDURE=CODECON_BREAKOUT
;Sequence Definition^<4427>Customisation Breakout^-1^<903>Miscellaneous^
;Use Tokens^USER-STRING^USER-STRING-1^USER-STRING-2^USER-STRING-3^USER-STRING-4^USER-STRING-5^USER-1^USER-2^USER-3^USER-4^USER-5^USER-6^USER-7^USER-8^USER-9^USER-10^USER-11^USER-12^USER-13^USER-14^USER-15^USER-16^USER-17^USER-18^USER-19^USER-20
;Default Sequence^
;TEXT^Dummy CODE_CONSTRUCTOR for customisation procedures etc.
;TEXT^Called at MACRO level of processing, structure similar to Whiteboard
;TEXT^Use #MACRO and #EXECMACRO to allocate procedures



%ENDM

